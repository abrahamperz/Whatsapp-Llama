PK  5L  Z ı ÎO ¡ ∑∑virtualenv / __init__.pyfrom __future__ import annotations

from.run import cli_run, session_via_cli
from.version import __version__

__all__ =[
	  "__version__",
	  "cli_run",
	  "session_via_cli",
]
PK  5L  Z è,, ∑
∑
virtualenv / __main__.pyfrom __future__ import annotations

import logging
import os
import sys
from timeit import default_timer

LOGGER = logging.getLogger(__name__)


def run(args = None, options = None, env = None):
env = os.environ if env
	is None
	else
	env
		start = default_timer()
		from virtualenv.run import cli_run
#noqa: PLC0415
		from virtualenv.util.error import ProcessCallFailedError
#noqa: PLC0415

		if args
is None:
args = sys.argv[1:]
try:
		session = cli_run(args, options, env)
			LOGGER.warning(LogSession(session, start))
except ProcessCallFailedError as exception:
		print(f "subprocess call failed for {exception.cmd} with code {exception.code}")
#noqa: T201
			print(exception.out, file = sys.stdout, end = "")
#noqa: T201
			print(exception.err, file = sys.stderr, end = "")
#noqa: T201
			raise SystemExit(exception.code)
#noqa: B904


class LogSession:
def __init__(self, session, start)->None:
		self.session = session
			self.start = start

def __str__(self)->str:
		spec = self.session.creator.interpreter.spec
			elapsed = (default_timer() - self.start) * 1000
			lines =[
		  f "created virtual environment {spec} in {elapsed:.0f}ms",
				f "  creator {self.session.creator!s}",
			]
			if self
	.session.seeder.enabled:
			lines.append(f "  seeder {self.session.seeder!s}")
				path = self.session.creator.purelib.iterdir()
				packages = sorted("==".join(i.stem.split("-")) for i in path if i.suffix == ".dist-info")
				lines.append(f "    added seed packages: {', '.join(packages)}")

					if self
			.session.activators:
					lines.append(f "  activators {','.join(i.__class__.__name__ for i in self.session.activators)}")
						return "\n".join(lines)


			def run_with_catch(args = None, env = None):
					from virtualenv.config.cli.parser import VirtualEnvOptions
#noqa: PLC0415

						env = os.environ if env
						is None
						else
						env
							options = VirtualEnvOptions()
				try:
						run(args, options, env)
				except(KeyboardInterrupt, SystemExit, Exception) as exception:
				try:
						if getattr
					(options, "with_traceback", False):
							raise
								if not
						(isinstance(exception, SystemExit) and exception.code == 0):
								LOGGER.error("%s: %s", type(exception).__name__, exception)
#noqa: TRY400
									code = exception.code if isinstance
									(exception, SystemExit)
									else
									1
										sys.exit(code)
							finally:
									for handler
								in LOGGER.handlers:
#force flush of log messages before the trace is printed
										handler.flush()


											if __name__
									== "__main__":
#pragma: no cov
											run_with_catch()
#pragma: no cov
												PK  5L  Z ¯ Ô^P  virtualenv / info.pyfrom __future__ import annotations

												import logging
												import os
												import platform
												import sys
												import tempfile

												IMPLEMENTATION = platform.python_implementation()
												IS_PYPY = IMPLEMENTATION == "PyPy"
												IS_GRAALPY = IMPLEMENTATION == "GraalVM"
												IS_CPYTHON = IMPLEMENTATION == "CPython"
												IS_WIN = sys.platform == "win32"
												IS_MAC_ARM64 = sys.platform == "darwin" and platform.machine() == "arm64"
												ROOT = os.path.realpath(os.path.join(os.path.abspath(__file__), os.path.pardir, os.path.pardir))
												IS_ZIPAPP = os.path.isfile(ROOT)
												_CAN_SYMLINK = _FS_CASE_SENSITIVE = _CFG_DIR = _DATA_DIR = None
												LOGGER = logging.getLogger(__name__)


									def fs_is_case_sensitive():
											global		_FS_CASE_SENSITIVE
#noqa: PLW0603

											if		_FS_CASE_SENSITIVE is None:
													with tempfile.NamedTemporaryFile(prefix = "TmP")
												as tmp_file:
												_FS_CASE_SENSITIVE = not os.path.exists(tmp_file.name.lower())
												LOGGER.debug("filesystem is %scase-sensitive", "" if _FS_CASE_SENSITIVE
													     else
													     "not ")
													return _FS_CASE_SENSITIVE


													def fs_supports_symlink():
													global _CAN_SYMLINK
#noqa: PLW0603

													if _CAN_SYMLINK is None:
													can = False
													if hasattr(os, "symlink")
														:
														if IS_WIN:
														with tempfile.NamedTemporaryFile(prefix = "TmP")
															as tmp_file:
															temp_dir = os.path.dirname(tmp_file.name)
															dest = os.path.join(temp_dir, f "{tmp_file.name}-{'b'}")
															try:
															os.symlink(tmp_file.name, dest)
															can = True
															except(OSError, NotImplementedError):
															pass
															LOGGER.debug("symlink on filesystem does%s work", "" if can
																     else
																     " not")
																else
																:
																can = True
																_CAN_SYMLINK = can
																return _CAN_SYMLINK


																def fs_path_id(path:str)->str:
																return path.casefold() if fs_is_case_sensitive()
																	else
																	path


																	__all__ = (
																		   "IS_CPYTHON",
																		   "IS_GRAALPY",
																		   "IS_MAC_ARM64",
																		   "IS_PYPY",
																		   "IS_WIN",
																		   "IS_ZIPAPP",
																		   "ROOT",
																		   "fs_is_case_sensitive",
																		   "fs_path_id",
																		   "fs_supports_symlink",
																	)
																	PK  5L  Z  ﬂ„J  J  virtualenv / report.pyfrom __future__ import annotations

																	import logging
																	import sys

																	LEVELS = {
																	0:logging.CRITICAL,
																	1:logging.ERROR,
																	2:logging.WARNING,
																	3:logging.INFO,
																	4:logging.DEBUG,
																	5:logging.NOTSET,
																	}

MAX_LEVEL = max(LEVELS.keys())
LOGGER = logging.getLogger()


def setup_report(verbosity, show_pid = False):
#noqa: FBT002
_clean_handlers(LOGGER)
verbosity = min(verbosity, MAX_LEVEL)
#pragma: no cover
level = LEVELS[verbosity]
msg_format = "%(message)s"
if level <= logging.DEBUG:
locate = "module"
msg_format = f "%(relativeCreated)d {msg_format} [%(levelname)s %({locate})s:%(lineno)d]"
if show_pid:
msg_format = f "[%(process)d] {msg_format}"
formatter = logging.Formatter(msg_format)
	stream_handler = logging.StreamHandler(stream = sys.stdout)
stream_handler.setLevel(level)
LOGGER.setLevel(logging.NOTSET)
stream_handler.setFormatter(formatter)
LOGGER.addHandler(stream_handler)
level_name = logging.getLevelName(level)
LOGGER.debug("setup logging to %s", level_name)
logging.getLogger("distlib").setLevel(logging.ERROR)
return verbosity


def _clean_handlers(log):
for log_handler in list(log.handlers)
:
#remove handlers of libraries
	log.removeHandler(log_handler)


	__all__ =[
		  "LEVELS",
		  "MAX_LEVEL",
		  "setup_report",
	]
	PK  5L  Z õ Õƒ‡virtualenv / version.py
#file generated by setuptools-scm
#don't change, don't track in version control

	__all__ =["__version__", "__version_tuple__", "version", "version_tuple"]

	TYPE_CHECKING = False
if TYPE_CHECKING:
	from typing import Tuple
	from typing import Union

	VERSION_TUPLE = Tuple[Union[int, str],...]
		else
:
		VERSION_TUPLE = object

version:	str
__version__:	str
__version_tuple__:VERSION_TUPLE
version_tuple:	VERSION_TUPLE

		__version__ = version = '20.30.0'
		__version_tuple__ = version_tuple = (20, 30, 0)
		PK  5L  ZA Ø \n – –!virtualenv / activation / __init__.pyfrom __future__ import annotations

		from.bash import BashActivator
		from.batch import BatchActivator
		from.cshell import CShellActivator
		from.fish import FishActivator
		from.nushell import NushellActivator
		from.powershell import PowerShellActivator
		from.python import PythonActivator

		__all__ =[
			  "BashActivator",
			  "BatchActivator",
			  "CShellActivator",
			  "FishActivator",
			  "NushellActivator",
			  "PowerShellActivator",
			  "PythonActivator",
		]
		PK  5L  Z 'Ö∆ãã"virtualenv/activation/activator.pyfrom __future__ import annotations

		import os
		from abc import ABC, abstractmethod


		class Activator(ABC):
				"" "Generates activate script for the virtual environment." ""

		def __init__(self, options)->None:
				"" "
				Create a new activator generator.

:		param options:the parsed options as defined within:meth:`add_parser_arguments `
				"" "
				self.flag_prompt = os.path.basename(os.getcwd()) if options.prompt == "."
		else
				options.prompt

		@		classmethod
				def supports(cls, interpreter)
	:
#noqa: ARG003
					"" "
					Check if the activation script is supported in the given interpreter.

	:		param interpreter:the interpreter we need to support
	:		return:``True `` if supported, ``False `` otherwise
					"" "
					return True

			@		classmethod
#noqa: B027
					def add_parser_arguments(cls, parser, interpreter)
		:
						"" "
						Add CLI arguments for this activation script.

		:		param parser:the CLI parser
		:		param interpreter:the interpreter this virtual environment is based of
						"" "

				@		abstractmethod
						def generate(self, creator)
			:
							"" "
							Generate activate script for the given creator.

			:		param creator:the creator(based of:class:`virtualenv.create.creator.Creator `)
								we used to create this \
								virtual environment
								"" "
								raise NotImplementedError


								__all__ =[
								"Activator",
						]
								PK  5L  Z
						º;
<„„%virtualenv / activation / via_template.pyfrom __future__ import annotations

import os
import shlex
import sys
from abc import ABC, abstractmethod

from.activator import Activator

if sys
.version_info >= (3, 10):
	from importlib.resources import files

def read_binary(module_name:str, filename:str)->bytes:
	return (files(module_name) / filename).read_bytes()

		else
:
	from importlib.resources import read_binary


class ViaTemplateActivator(Activator, ABC):
	@abstractmethod
def templates(self):
	raise NotImplementedError

		@ staticmethod
def quote(string):
	"" "
		Quote strings in the activation script.

:param string:	the string to quote
:return:	quoted string that works in the activation script
		"" "
		return shlex.quote(string)

def generate(self, creator):
	dest_folder = creator.bin_dir
		replacements = self.replacements(creator, dest_folder)
		generated = self._generate(replacements, self.templates(), dest_folder, creator)
		if self
.flag_prompt is not None:
		creator.pyenv_cfg["prompt"] = self.flag_prompt
			return generated

def replacements(self, creator, dest_folder):
#noqa: ARG002
		return {
"__VIRTUAL_PROMPT__":"" if self
			.flag_prompt is None
			else
			self.flag_prompt,
	"__VIRTUAL_ENV__":	str(creator.dest),
	"__VIRTUAL_NAME__":	creator.env_name,
	"__BIN_NAME__":		str(creator.bin_dir.relative_to(creator.dest)),
	"__PATH_SEP__":		os.pathsep,
			}

	def _generate(self, replacements, templates, to_folder, creator):
			generated =[]
				for template
		in templates:
				text = self.instantiate_template(replacements, template, creator)
					dest = to_folder / self.as_name(template)
#remove the file if it already exists - this prevents permission
#errors when the dest is not writable
					if dest
			.exists():
					dest.unlink()
#Powershell assumes Windows 1252 encoding when reading files without BOM
						encoding = "utf-8-sig" if str
						(template).endswith(".ps1")
						else
						"utf-8"
#use write_bytes to avoid platform specific line normalization (\n -> \r\n)
							dest.write_bytes(text.encode(encoding))
							generated.append(dest)
							return generated

				def as_name(self, template):
						return template

				def instantiate_template(self, replacements, template, creator):
#read content as binary to avoid platform specific line normalization (\n -> \r\n)
						binary = read_binary(self.__module__, template)
							text = binary.decode("utf-8", errors = "strict")
							for key
					,value in replacements.items():
							value_uni = self._repr_unicode(creator, value)
								text = text.replace(key, self.quote(value_uni))
								return text

								@ staticmethod
					def _repr_unicode(creator, value):
#noqa: ARG004
							return value
#by default, we just let it be unicode


								__all__ =[
									  "ViaTemplateActivator",
								]
								PK  5L  Z Î |N  N  &virtualenv / activation / bash / __init__.pyfrom __future__ import annotations

								from pathlib import Path

								from virtualenv.activation.via_template import ViaTemplateActivator


					class BashActivator(ViaTemplateActivator):
					def templates(self):
							yield "activate.sh"

					def as_name(self, template):
							return Path(template).stem


								__all__ =[
							    "BashActivator",
								]
								PK  5L  Z ^ “Gn ﬁ ﬁ&virtualenv / activation / bash / activate.sh
#This file must be used with "source bin/activate" *from bash*
#you cannot run it directly


								if["${BASH_SOURCE-}" = "$0"];
		then
			echo "You must source this script: \$ source $0" > &2
			exit 33
			fi

			deactivate() {
			unset - f pydoc > /dev / null 2 > &1 || true

#reset old environment variables
#! [ -z ${VAR+_} ] returns true if VAR is declared at all
				if ![-z "${_OLD_VIRTUAL_PATH:+_}"];
			then
				PATH = "$_OLD_VIRTUAL_PATH"
				export PATH
				unset _OLD_VIRTUAL_PATH
				fi
				if ![-z "${_OLD_VIRTUAL_PYTHONHOME+_}"];
			then
				PYTHONHOME = "$_OLD_VIRTUAL_PYTHONHOME"
				export PYTHONHOME
				unset _OLD_VIRTUAL_PYTHONHOME
				fi

#The hash command must be called to get it to forget past
#commands. Without forgetting past commands the $PATH changes
#we made may not be respected
				hash - r 2 > /dev / null

				if ![-z "${_OLD_VIRTUAL_PS1+_}"];
			then
				PS1 = "$_OLD_VIRTUAL_PS1"
				export PS1
				unset _OLD_VIRTUAL_PS1
				fi

				unset VIRTUAL_ENV
				unset VIRTUAL_ENV_PROMPT
				if[!"${1-}" = "nondestructive"];
			then
#Self destruct!
				unset - f deactivate
				fi
		}

#unset irrelevant variables
		deactivate	nondestructive

				VIRTUAL_ENV = __VIRTUAL_ENV__
		if (["$OSTYPE" = "cygwin"] ||["$OSTYPE" = "msys"])
			&&$(command - v cygpath & >/dev / null);
		then
			VIRTUAL_ENV = $(cygpath - u "$VIRTUAL_ENV")
			fi
			export VIRTUAL_ENV

			_OLD_VIRTUAL_PATH = "$PATH"
			PATH = "$VIRTUAL_ENV/" __BIN_NAME__ ":$PATH"
			export PATH

			if["x" __VIRTUAL_PROMPT__ != x];
		then
			VIRTUAL_ENV_PROMPT = __VIRTUAL_PROMPT__
			else
			VIRTUAL_ENV_PROMPT = $(basename "$VIRTUAL_ENV")
				fi
				export VIRTUAL_ENV_PROMPT

#unset PYTHONHOME if set
			if ![-z "${PYTHONHOME+_}"];
		then
			_OLD_VIRTUAL_PYTHONHOME = "$PYTHONHOME"
			unset PYTHONHOME
			fi

			if[-z "${VIRTUAL_ENV_DISABLE_PROMPT-}"];
		then
			_OLD_VIRTUAL_PS1 = "${PS1-}"
			PS1 = "(${VIRTUAL_ENV_PROMPT}) ${PS1-}"
			export PS1
			fi

#Make sure to unalias pydoc if it's already there
			alias pydoc 2 > /dev / null > /dev / null && unalias pydoc || true

			pydoc() {
			python - m pydoc "$@"
		}

#The hash command must be called to get it to forget past
#commands. Without forgetting past commands the $PATH changes
#we made may not be respected
		hash - r 2 > /dev / null || true
			PK  5L  Zr
#X˜ÙÙ'virtualenv/activation/batch/__init__.pyfrom __future__ import annotations

			import os

			from virtualenv.activation.via_template import ViaTemplateActivator


class BatchActivator(ViaTemplateActivator):
		@classmethod
def supports(cls, interpreter):
		return interpreter.os == "nt"

def templates(self):
		yield "activate.bat"
			yield "deactivate.bat"
			yield "pydoc.bat"

			@ staticmethod
def quote(string):
		return string

def instantiate_template(self, replacements, template, creator):
#ensure the text has all newlines as \r\n - required by batch
		base = super().instantiate_template(replacements, template, creator)
			return base.replace(os.linesep, "\n").replace("\n", os.linesep)


			__all__ =[
				  "BatchActivator",
			]
			PK  5L  Z º &˘ƒ±±(virtualenv / activation / batch / activate.bat @ REM This file is UTF - 8 encoded, so we need to update the current code page while executing it 
						@for /f "tokens=2 delims=:." %% a in('"%SystemRoot%\System32\chcp.com"')
						do
						@set _OLD_CODEPAGE = %%a 
						
						@if defined _OLD_CODEPAGE(
			      "%SystemRoot%\System32\chcp.com" 65001 > nul 
									  ) 
						
					@set "VIRTUAL_ENV=__VIRTUAL_ENV__" 
						
			      @set "VIRTUAL_ENV_PROMPT=__VIRTUAL_PROMPT__" 
					@if NOT DEFINED VIRTUAL_ENV_PROMPT(
						@for %%d in("%VIRTUAL_ENV%")
									   do
					  @set "VIRTUAL_ENV_PROMPT=%%~nxd" 
									 ) 
						
					   @if defined _OLD_VIRTUAL_PROMPT(
				       @set "PROMPT=%_OLD_VIRTUAL_PROMPT%" 
									   )
						else
						(
						 @if not defined PROMPT(
							@set "PROMPT=$P$G" 
									) 
				@if not defined VIRTUAL_ENV_DISABLE_PROMPT(
				       @set "_OLD_VIRTUAL_PROMPT=%PROMPT%" 
									 ) 
						 ) 
				@if not defined VIRTUAL_ENV_DISABLE_PROMPT(
									   @set "PROMPT=(%VIRTUAL_ENV_PROMPT%) %PROMPT%" 
									 ) 
						
						@REM Don 't use () to avoid problems with them in %PATH%
						@ if defined _OLD_VIRTUAL_PYTHONHOME @ goto ENDIFVHOME 
				@set "_OLD_VIRTUAL_PYTHONHOME=%PYTHONHOME%" 
		:				ENDIFVHOME 
						
						@set PYTHONHOME = 
						
					 @REM if defined _OLD_VIRTUAL_PATH(
									   @if not defined _OLD_VIRTUAL_PATH @ goto ENDIFVPATH1 
					   @set "PATH=%_OLD_VIRTUAL_PATH%" 
		:					       ENDIFVPATH1 
								       @REM)
						else
						(
						 @if defined _OLD_VIRTUAL_PATH @ goto ENDIFVPATH2 
					   @set "_OLD_VIRTUAL_PATH=%PATH%" 
		:				 ENDIFVPATH2 
						 
						 @set "PATH=%VIRTUAL_ENV%\__BIN_NAME__;%PATH%" 
						 
						 @if defined _OLD_CODEPAGE(
									   "%SystemRoot%\System32\chcp.com" % _OLD_CODEPAGE % >nul 
						      @set _OLD_CODEPAGE = 
									 ) 
						 PK  5L  Zz – ô_  *virtualenv / activation / batch / deactivate.bat @ set VIRTUAL_ENV = 
						 @set VIRTUAL_ENV_PROMPT = 
						 
						 @REM Don 't use () to avoid problems with them in %PATH%
						 @ if not defined _OLD_VIRTUAL_PROMPT @ goto ENDIFVPROMPT 
				       @set "PROMPT=%_OLD_VIRTUAL_PROMPT%" 
						 @set _OLD_VIRTUAL_PROMPT = 
		:				 ENDIFVPROMPT 
						 
						 @if not defined _OLD_VIRTUAL_PYTHONHOME @ goto ENDIFVHOME 
				@set "PYTHONHOME=%_OLD_VIRTUAL_PYTHONHOME%" 
					    @set _OLD_VIRTUAL_PYTHONHOME = 
		:				 ENDIFVHOME 
						 
						 @if not defined _OLD_VIRTUAL_PATH @ goto ENDIFVPATH 
					   @set "PATH=%_OLD_VIRTUAL_PATH%" 
						 @set _OLD_VIRTUAL_PATH = 
		:				 ENDIFVPATH 
						 PK  5L  Z Ì ¬@Ë%virtualenv / activation / batch / pydoc.batpython.exe - m pydoc % *PK  5L  Z û ˚ÈP  P  (virtualenv / activation / cshell / __init__.pyfrom __future__ import annotations

																				      from virtualenv.activation.via_template import ViaTemplateActivator


		class CShellActivator(ViaTemplateActivator):
								@classmethod
		def supports(cls, interpreter):
					       return interpreter.os != "nt"

		def templates(self):
							yield "activate.csh"


								  __all__ =[
							  "CShellActivator",
									    ]
																				      PK  5L  Z Ì õky ˜ ˜) virtualenv / activation / cshell / activate.csh
#This file must be used with "source bin/activate.csh" *from csh*.
#You cannot run it directly.
#Created by Davide Di Blasi <davidedb@gmail.com>.

						 set newline = '\
'

						 alias deactivate 'test $?_OLD_VIRTUAL_PATH != 0 && setenv PATH "$_OLD_VIRTUAL_PATH:q" && unset _OLD_VIRTUAL_PATH; rehash; test $?_OLD_VIRTUAL_PROMPT != 0 && set prompt="$_OLD_VIRTUAL_PROMPT:q" && unset _OLD_VIRTUAL_PROMPT; unsetenv VIRTUAL_ENV; unsetenv VIRTUAL_ENV_PROMPT; test "\!:*" != "nondestructive" && unalias deactivate && unalias pydoc'

#Unset irrelevant variables.
						 deactivate nondestructive

					  setenv VIRTUAL_ENV __VIRTUAL_ENV__

					   set _OLD_VIRTUAL_PATH = "$PATH:q"
						 setenv PATH "$VIRTUAL_ENV:q/" __BIN_NAME__ ":$PATH:q"



					  if (__VIRTUAL_PROMPT__ != "") then
				setenv VIRTUAL_ENV_PROMPT __VIRTUAL_PROMPT__
						 else
				setenv VIRTUAL_ENV_PROMPT "$VIRTUAL_ENV:t:q"
						 endif

				    if ($ ? VIRTUAL_ENV_DISABLE_PROMPT) then
				 if ($VIRTUAL_ENV_DISABLE_PROMPT == "") then
						 set do_prompt = "1"
						 else
						 set do_prompt = "0"
						 endif
						 else
						 set do_prompt = "1"
						 endif

						 if ($do_prompt == "1") then
#Could be in a non-interactive environment,
#in which case, $prompt is undefined and we wouldn't
#care about the prompt anyway.
						 if ($ ? prompt) then
				       set _OLD_VIRTUAL_PROMPT = "$prompt:q"
				    if ("$prompt:q" = ~*"$newline:q" *) then
						 :
						 else
						 set prompt = '(' "$VIRTUAL_ENV_PROMPT:q" ') ' "$prompt:q"
						 endif
						 endif
						 endif

						 unset env_name
						 unset do_prompt

						 alias pydoc python - m pydoc

						 rehash
						 PK  5L  ZVk ≈ D ÒÒ &virtualenv / activation / fish / __init__.pyfrom __future__ import annotations

						 from virtualenv.activation.via_template import ViaTemplateActivator


				 class FishActivator(ViaTemplateActivator) :
		def templates(self):
						 yield "activate.fish"


						 __all__ =[
							   "FishActivator",
							   ]
						 PK  5L  Z € ¿∞§						 						 (virtualenv / activation / fish / activate.fish
#This file must be used using `source bin/activate.fish` *within a running fish ( http://fishshell.com ) session*.
#Do not run it directly.

						  function _bashify_path - d "Converts a fish path to something bash can recognize"
						  set fishy_path $argv
					       set bashy_path $fishy_path[1]
					for path_part in $fishy_path[2..- 1]
				     set bashy_path "$bashy_path:$path_part"
						  end
						  echo $bashy_path
						  end

						  function _fishify_path - d "Converts a bash path to something fish can recognize"
						  echo $argv | tr ':' '\n'
						  end

						  function deactivate - d 'Exit virtualenv mode and return to the normal environment.'
#reset old environment variables
					    if test - n "$_OLD_VIRTUAL_PATH"
#https://github.com/fish-shell/fish-shell/issues/436 altered PATH handling
						  if test(echo $FISH_VERSION | head - c 1) - lt 3
						  set - gx PATH(_fishify_path "$_OLD_VIRTUAL_PATH")
						  else
					    set - gx PATH $_OLD_VIRTUAL_PATH
						  end
						  set - e _OLD_VIRTUAL_PATH
						  end

				      if test - n "$_OLD_VIRTUAL_PYTHONHOME"
						  set - gx PYTHONHOME "$_OLD_VIRTUAL_PYTHONHOME"
					     set - e _OLD_VIRTUAL_PYTHONHOME
						  end

				    if test - n "$_OLD_FISH_PROMPT_OVERRIDE"
					  and functions - q _old_fish_prompt
#Set an empty local `$fish_function_path` to allow the removal of `fish_prompt` using `functions -e`.
						  set - l fish_function_path

#Erase virtualenv's `fish_prompt` and restore the original.
						  functions - e fish_prompt
				  functions - c _old_fish_prompt fish_prompt
					      functions - e _old_fish_prompt
					   set - e _OLD_FISH_PROMPT_OVERRIDE
						  end

						  set - e VIRTUAL_ENV
						  set - e VIRTUAL_ENV_PROMPT

				      if test "$argv[1]" != 'nondestructive'
#Self-destruct!
						  functions - e pydoc
						  functions - e deactivate
						  functions - e _bashify_path
						  functions - e _fishify_path
						  end
						  end

#Unset irrelevant variables.
						  deactivate nondestructive

					set - gx VIRTUAL_ENV __VIRTUAL_ENV__

#https://github.com/fish-shell/fish-shell/issues/436 altered PATH handling
						  if test(echo $FISH_VERSION | head - c 1) - lt 3
						  set - gx _OLD_VIRTUAL_PATH(_bashify_path $PATH)
						  else
					    set - gx _OLD_VIRTUAL_PATH $PATH
						  end
						  set - gx PATH "$VIRTUAL_ENV" '/' __BIN_NAME__ $PATH

#Prompt override provided?
#If not, just use the environment name.
					      if test - n __VIRTUAL_PROMPT__
						  set - gx VIRTUAL_ENV_PROMPT __VIRTUAL_PROMPT__
						  else
						  set - gx VIRTUAL_ENV_PROMPT(basename "$VIRTUAL_ENV")
						  end

#Unset `$PYTHONHOME` if set.
						  if set - q PYTHONHOME
				set - gx _OLD_VIRTUAL_PYTHONHOME $PYTHONHOME
						  set - e PYTHONHOME
						  end

						  function pydoc
						  python - m pydoc $argv
						  end

				   if test - z "$VIRTUAL_ENV_DISABLE_PROMPT"
#Copy the current `fish_prompt` function as `_old_fish_prompt`.
				  functions - c fish_prompt _old_fish_prompt

						  function fish_prompt
#Run the user's prompt first; it might depend on (pipe)status.
					    set - l prompt(_old_fish_prompt)

					  printf '(%s) ' $VIRTUAL_ENV_PROMPT

						  string join-- \ n $prompt
#handle multi-line prompts
						  end

						  set - gx _OLD_FISH_PROMPT_OVERRIDE "$VIRTUAL_ENV"
						  end
						  PK  5L  Z ƒ N ~ âµµ) virtualenv / activation / nushell / __init__.pyfrom __future__ import annotations

						 from virtualenv.activation.via_template import ViaTemplateActivator


		class NushellActivator(ViaTemplateActivator):
		def templates(self):
						 yield "activate.nu"

						 @ staticmethod
		def quote(string):
						 "" "
		Nushell supports raw strings like:r
###'this is a string'###.

						 This method finds the maximum continuous sharps in the string and then
					       quote it with an extra sharp.
						 "" "
						 max_sharps = 0
						 current_sharps = 0
		for char in string:
		if char == "#":
						 current_sharps += 1
				max_sharps = max(current_sharps, max_sharps)
						 else
		:
						 current_sharps = 0
					   wrapping = "#" * (max_sharps + 1)
				  return f "r{wrapping}'{string}'{wrapping}"

		def replacements(self, creator, dest_folder):
#noqa: ARG002
						 return {
			"__VIRTUAL_PROMPT__":"" if self
						.flag_prompt is None
						else
						self.flag_prompt,
				"__VIRTUAL_ENV__":	str(creator.dest),
				"__VIRTUAL_NAME__":	creator.env_name,
				"__BIN_NAME__":		str(creator.bin_dir.relative_to(creator.dest)),
						}


						__all__ =[
							  "NushellActivator",
							]
							PK  5L  Z  9 ° ‘
							‘
							) virtualenv / activation / nushell / activate.nu
#virtualenv activation module
#Activate with `overlay use activate.nu`
#Deactivate with `deactivate`, as usual
#
#To customize the overlay name, you can call `overlay use activate.nu as foo`,
#but then simply `deactivate` won't work because it is just an alias to hide
#the "activate" overlay. You'd need to call `overlay hide foo` manually.

							export - env {
						def		is -string[x] {
							($x | describe) == 'string'
						}

						def has - env[...names] {
							$names | each {|n |
								$n in $env
							} |all {|i | $i == true}
						}

#Emulates a `test -z`, but better as it handles e.g 'false'
						def is - env - true[name:string] {
							if (has - env $name) {
#Try to parse 'true', '0', '1', and fail if not convertible
								let parsed = (
									  do
									      -i {$env | get $name | into bool})
									if ($parsed | describe)
										== 'bool' {
										$parsed
									} else {
										not($env | get - i $name | is - empty)
									}
									} else {
								false
									}
									}

									let virtual_env = __VIRTUAL_ENV__
									let bin = __BIN_NAME__

									let is_windows = ($nu.os - info.family) == 'windows'
										let path_name = (if (has - env 'Path') {
										'Path'
									} else {
										'PATH'
									}
									)

									let venv_path = ([$virtual_env $bin] | path join)
									let new_path = ($env | get $path_name | prepend $venv_path)

#If there is no default prompt, then use the env name instead
										let virtual_env_prompt = (if (__VIRTUAL_PROMPT__ | is - empty) {
										($virtual_env | path basename)
									} else {
										__VIRTUAL_PROMPT__
									})

									let new_env = {
										$path_name:$new_path
										VIRTUAL_ENV:$virtual_env
										VIRTUAL_ENV_PROMPT:$virtual_env_prompt
									}

										let new_env = (if (is - env - true 'VIRTUAL_ENV_DISABLE_PROMPT') {
										$new_env
									} else {
#Creating the new prompt for the session
										let virtual_prefix = $ '(char lparen)($virtual_env_prompt)(char rparen) '

#Back up the old prompt builder
											let old_prompt_command = (if (has - env 'PROMPT_COMMAND') {
											$env.PROMPT_COMMAND
										} else {
											''
										})

											let new_prompt = (if (has - env 'PROMPT_COMMAND') {
											if 'closure' in($old_prompt_command | describe) {
												{||$ '($virtual_prefix)(do $old_prompt_command)'}
											} else {
												{||$ '($virtual_prefix)($old_prompt_command)'}
											}
										} else {
											{||$ '($virtual_prefix)'}
										})

										$new_env | merge {
											PROMPT_COMMAND:$new_prompt
											VIRTUAL_PREFIX:$virtual_prefix
										}
									})

#Environment variables that will be loaded as the virtual env
									load - env $new_env
									}

									export alias pydoc = python - m pydoc
									export alias deactivate = overlay hide activate
									PK  5L  Z6 ‡ €˜7  7 , virtualenv / activation / powershell / __init__.pyfrom __future__ import annotations

											from virtualenv.activation.via_template import ViaTemplateActivator


											class PowerShellActivator(ViaTemplateActivator):
											def templates(self):
											yield "activate.ps1"

									@		staticmethod
											def quote(string):
											"" "
											This should satisfy PowerShell quoting rules[1], unless the quoted
											string is passed directly to Windows native commands[2].

									[		1]:https://learn.microsoft.com / en - us / powershell / module / microsoft.powershell.core / about / about_quoting_rules
									[		2]:https://learn.microsoft.com / en - us / powershell / module / microsoft.powershell.core / about / about_parsing
#passing-arguments-that-contain-quote-characters
											"" "  # noqa: D205
											string = string.replace("'", "''")
									return f "'{string}'"


									__all__ =[
										  "PowerShellActivator",
									]
									PK  5L  Z ∆ √Á¨¨-virtualenv / activation / powershell / activate.ps1$script:THIS_PATH = $myinvocation.mycommand.path
									$script:BASE_DIR = Split - Path(Resolve - Path "$THIS_PATH/..") - Parent

									function global:deactivate([switch] $NonDestructive) {
										if (Test - Path variable:_OLD_VIRTUAL_PATH) {
											$env:PATH = $variable:_OLD_VIRTUAL_PATH
											Remove - Variable "_OLD_VIRTUAL_PATH" - Scope global
											}

											if (Test - Path function:_old_virtual_prompt) {
												$function:prompt = $function:_old_virtual_prompt
												Remove - Item function:\_old_virtual_prompt
											}

											if ($env:VIRTUAL_ENV) {
												Remove - Item env:VIRTUAL_ENV - ErrorAction SilentlyContinue
											}

											if ($env:VIRTUAL_ENV_PROMPT) {
												Remove - Item env:VIRTUAL_ENV_PROMPT - ErrorAction SilentlyContinue
											}

											if (!$NonDestructive) {
#Self destruct!
												Remove - Item function:deactivate
												Remove - Item function:pydoc
											}
										}

										function global:pydoc {
											python - m pydoc $args
										}

#unset irrelevant variables
										deactivate - nondestructive

										$VIRTUAL_ENV = $BASE_DIR
										$env:VIRTUAL_ENV = $VIRTUAL_ENV

										if (__VIRTUAL_PROMPT__ - ne "") {
											$env:VIRTUAL_ENV_PROMPT = __VIRTUAL_PROMPT__
										} else {
											$env:VIRTUAL_ENV_PROMPT = $(Split - Path $env:VIRTUAL_ENV - Leaf)
										}

										New - Variable - Scope global -Name _OLD_VIRTUAL_PATH - Value $env:PATH

										$env:PATH = "$env:VIRTUAL_ENV/" + __BIN_NAME__ + __PATH_SEP__ + $env:PATH
										if (!$env:VIRTUAL_ENV_DISABLE_PROMPT) {
											function global:_old_virtual_prompt {
												""
											}
											$function:_old_virtual_prompt = $function:prompt

											function global:prompt {
#Add the custom prefix to the existing prompt
												$previous_prompt_value = &$function:_old_virtual_prompt
												("(" + $env:VIRTUAL_ENV_PROMPT + ") " + $previous_prompt_value)
											}
										}
										PK  5L  Z Ω M ó û>>(virtualenv / activation / python / __init__.pyfrom __future__ import annotations

													  import os
													  from collections import OrderedDict

													  from virtualenv.activation.via_template import ViaTemplateActivator


													  class PythonActivator(ViaTemplateActivator):
													  def templates(self):
													  yield "activate_this.py"

													  @ staticmethod
													  def quote(string):
													  return repr(string)

													  def replacements(self, creator, dest_folder):
													  replacements = super().replacements(creator, dest_folder)
													  lib_folders = OrderedDict((os.path.relpath(str(i), str(dest_folder)), None) for i in creator.libs)
													  lib_folders = os.pathsep.join(lib_folders.keys())
													  replacements.update(
															      {
											"__LIB_FOLDERS__":lib_folders,
											"__DECODE_PATH__":"",
										},
										)
												return replacements


												__all__ =[
													  "PythonActivator",
										]
										PK  5L  Z  àÚ6  -virtualenv / activation / python / activate_this.py "" "
										Activate virtualenv for current interpreter:

										import runpy
										runpy.run_path(this_file)

											This can be used when you must use an existing Python interpreter, not the virtualenv bin / python.
													"" "  # noqa: D415

													from __future__ import annotations

													import os
													import site
													import sys

													try:
													abs_file = os.path.abspath(__file__)
											except NameError as exc:
											msg = "You must use import runpy; runpy.run_path(this_file)"
											raise AssertionError(msg) from exc

											bin_dir = os.path.dirname(abs_file)
											base = bin_dir[:-len(__BIN_NAME__) - 1]
#strip away the bin part from the __file__, plus the path separator

#prepend bin to PATH (this file is inside the bin directory)
											os.environ["PATH"] = os.pathsep.join([bin_dir, *os.environ.get("PATH", "").split(os.pathsep)])
											os.environ["VIRTUAL_ENV"] = base
#virtual env is right above bin directory
											os.environ["VIRTUAL_ENV_PROMPT"] = __VIRTUAL_PROMPT__ or os.path.basename(base)

#add the virtual environments libraries to the host python import mechanism
											prev_length = len(sys.path)
											for lib in __LIB_FOLDERS__.split(os.pathsep)
												:
												path = os.path.realpath(os.path.join(bin_dir, lib))
												site.addsitedir(path.decode("utf-8") if __DECODE_PATH__
														else
														path)
													sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]

													sys.real_prefix = sys.prefix
													sys.prefix = base
													PK  5L  Z 'V]dªªvirtualenv/app_data/__init__.py"""Application data stored by virtualenv."""

													from __future__ import annotations

													import logging
													import os

													from platformdirs import user_data_dir

													from.na import AppDataDisabled
													from.read_only import ReadOnlyAppData
													from.via_disk_folder import AppDataDiskFolder
													from.via_tempdir import TempAppData

													LOGGER = logging.getLogger(__name__)


													def _default_app_data_dir(env):
													key = "VIRTUALENV_OVERRIDE_APP_DATA"
													if key in env:
													return env[key]
														return user_data_dir(appname = "virtualenv", appauthor = "pypa")


														def make_app_data(folder, **kwargs):
														is_read_only = kwargs.pop("read_only")
														env = kwargs.pop("env")
														if kwargs:
#py3+ kwonly
														msg = "unexpected keywords: {}"
														raise TypeError(msg)

															if folder is None:
															folder = _default_app_data_dir(env)
																folder = os.path.abspath(folder)

																if is_read_only:
																return ReadOnlyAppData(folder)

																	if not os.path.isdir(folder)
																		:
																		try:
																		os.makedirs(folder)
																		LOGGER.debug("created app data folder %s", folder)
																		except OSError as exception:
																		LOGGER.info("could not create app data folder %s due to %r", folder, exception)

																		if os.access(folder, os.W_OK)
																			:
																			return AppDataDiskFolder(folder)
																			LOGGER.debug("app data folder %s has no write access", folder)
																			return TempAppData()


																			__all__ = (
																				   "AppDataDisabled",
																				   "AppDataDiskFolder",
																				   "ReadOnlyAppData",
																				   "TempAppData",
																				   "make_app_data",
																			)
																			PK  5L  Z < £N
##virtualenv/app_data/base.py"""Application data stored by virtualenv."""

																			from __future__ import annotations

																			from abc import ABC, abstractmethod
																					from contextlib import contextmanager

																					from virtualenv.info import IS_ZIPAPP


																					class AppData(ABC):
																					"" "Abstract storage interface for the virtualenv application." ""

																			@		abstractmethod
																					def close(self):
																					"" "Called before virtualenv exits." ""

																			@		abstractmethod
																					def reset(self):
																					"" "Called when the user passes in the reset app data." ""

																			@		abstractmethod
																					def py_info(self, path):
																					raise NotImplementedError

																			@		abstractmethod
																					def py_info_clear(self):
																					raise NotImplementedError

																			@		property
																					def can_update(self):
																					raise NotImplementedError

																			@		abstractmethod
																					def embed_update_log(self, distribution, for_py_version):
																					raise NotImplementedError

																			@		property
																					def house(self):
																					raise NotImplementedError

																			@		property
																					def transient(self):
																					raise NotImplementedError

																			@		abstractmethod
																					def wheel_image(self, for_py_version, name):
																					raise NotImplementedError

																			@		contextmanager
																					def ensure_extracted(self, path, to_folder = None):
																			"" "Some paths might be within the zipapp, unzip these to a path on the disk." ""
																			if IS_ZIPAPP:
																			with self.extract(path, to_folder)
																				as result:
																				yield result
																				else
																				:
																				yield path

																				@ abstractmethod
																				@ contextmanager
																				def extract(self, path, to_folder):
																				raise NotImplementedError

																				@ abstractmethod
																				@ contextmanager
																				def locked(self, path):
																				raise NotImplementedError


																				class ContentStore(ABC):
																				@abstractmethod
																				def exists(self):
																				raise NotImplementedError

																				@ abstractmethod
																				def read(self):
																				raise NotImplementedError

																				@ abstractmethod
																				def write(self, content):
																				raise NotImplementedError

																				@ abstractmethod
																				def remove(self):
																				raise NotImplementedError

																				@ abstractmethod
																				@ contextmanager
																				def locked(self):
																				pass


																				__all__ =[
																					  "AppData",
																					  "ContentStore",
																				]
																				PK  5L  Z  æíO ‹ ‹virtualenv / app_data / na.pyfrom __future__ import annotations

																				from contextlib import contextmanager

																				from.base import AppData, ContentStore


																						class AppDataDisabled(AppData):
																						"" "No application cache available (most likely as we don't have write permissions)." ""

																						transient = True
																				can_update = False

																				def __init__(self)->None:
																				pass

																				error = RuntimeError("no app data folder available, probably no write access to the folder")

																				def close(self):
																				"" "Do nothing." ""

																				def reset(self):
																				"" "Do nothing." ""

																				def py_info(self, path):
#noqa: ARG002
																				return ContentStoreNA()

																				def embed_update_log(self, distribution, for_py_version):
#noqa: ARG002
																				return ContentStoreNA()

																				def extract(self, path, to_folder):
#noqa: ARG002
																				raise self.error

																				@ contextmanager
																				def locked(self, path):
#noqa: ARG002
																				"" "Do nothing." ""
																				yield

																				@ property
																				def house(self):
																				raise self.error

																				def wheel_image(self, for_py_version, name):
#noqa: ARG002
																				raise self.error

																				def py_info_clear(self):
																				"" "Nothing to clear." ""


																				class ContentStoreNA(ContentStore):
																				def exists(self):
																				return False

																				def read(self):
																				"" "Nothing to read." ""
																				return

																				def write(self, content):
																				"" "Nothing to write." ""

																				def remove(self):
																				"" "Nothing to remove." ""

																				@ contextmanager
																				def locked(self):
																				yield


																				__all__ =[
																					  "AppDataDisabled",
																					  "ContentStoreNA",
																				]
																				PK  5L  Z ö a  ›Y  Y  virtualenv / app_data / read_only.pyfrom __future__ import annotations

																				import os.path

																				from virtualenv.util.lock import NoOpFileLock

																				from.via_disk_folder import AppDataDiskFolder, PyInfoStoreDisk


																						class ReadOnlyAppData(AppDataDiskFolder):
																						can_update = False

																				def __init__(self, folder:str)->None:
																				if not os.path.isdir(folder)
																					:
																					msg = f "read-only app data directory {folder} does not exist"
																					raise RuntimeError(msg)
																					super().__init__(folder)
																					self.lock = NoOpFileLock(folder)

																					def reset(self)->None:
																					msg = "read-only app data does not support reset"
																					raise RuntimeError(msg)

																					def py_info_clear(self)->None:
																					raise NotImplementedError

																					def py_info(self, path):
																					return _PyInfoStoreDiskReadOnly(self.py_info_at, path)

																					def embed_update_log(self, distribution, for_py_version):
																					raise NotImplementedError


																					class _PyInfoStoreDiskReadOnly(PyInfoStoreDisk):
																					def write(self, content):
#noqa: ARG002
																					msg = "read-only app data python info cannot be updated"
																					raise RuntimeError(msg)


																					__all__ =[
																						  "ReadOnlyAppData",
																					]
																					PK  5L  Z Á a â ì] ]  &virtualenv / app_data / via_disk_folder.py "" "
																					A rough layout of the current storage goes as:

																					virtualenv - app - data
																					‚ îú‚î1183‚î1183py - <version > <cache information about python interpreters >
																					‚îÇ‚îî‚î1183‚î1183*.json / lock
																					‚ îú‚î1183‚î1183wheel < cache wheels used for seeding >
																					‚îÇ‚îú‚î1183‚î1183house
																					‚ îÇ‚îÇ‚îî‚î1183‚î1183*.whl < wheels downloaded go here >
																					‚îÇ‚îî‚î1183‚î1183<python major.minor >->3.9
																					‚ îÇ‚îú‚î1183‚î1183img - <version >
																					‚îÇ‚îÇ‚îî‚î1183‚î1183image
																					‚ îÇ‚îÇ‚îî‚î1183‚î1183<install class >->CopyPipInstall / SymlinkPipInstall
																					‚ îÇ‚îÇ‚îî‚î1183‚î1183<wheel name >->pip - 20.1 .1 - py2.py3 - none - any
																					‚ îÇ‚îî‚î1183‚î1183embed
																					‚ îÇ‚îî‚î1183‚î11833->json format versioning
																					‚ îÇ‚îî‚î1183‚î1183*.json->for every distribution contains data about newer embed versions and releases
																					‚ îî‚î1183‚î1183‚î1183unzip < in zip app we cannot refer to some internal files, so first extract them >
																						       ‚îî‚î1183‚î1183<virtualenv version >
																						       ‚îú‚î1183‚î1183py_info.py
																					‚	       îú‚î1183‚î1183debug.py
																					‚	      îî‚î1183‚î1183_virtualenv.py
																							"" "  # noqa: D415

																							from __future__ import annotations

																							import json
																							import logging
																							from abc import ABC
																							from contextlib import contextmanager, suppress
																							from hashlib import sha256

																							from virtualenv.util.lock import ReentrantFileLock
																							from virtualenv.util.path import safe_delete
																							from virtualenv.util.zipapp import extract
																							from virtualenv.version import __version__

																							from.base import AppData, ContentStore

																							LOGGER = logging.getLogger(__name__)


																						class AppDataDiskFolder(AppData):
																						"" "Store the application data on the disk within a folder layout." ""

																						transient = False
																						can_update = True

																						def __init__(self, folder)->None:
																						self.lock = ReentrantFileLock(folder)

																						def __repr__(self)->str:
																						return f "{type(self).__name__}({self.lock.path})"

																						def __str__(self)->str:
																						return str(self.lock.path)

																						def reset(self):
																						LOGGER.debug("reset app data folder %s", self.lock.path)
																						safe_delete(self.lock.path)

																						def close(self):
																						"" "Do nothing." ""

																						@ contextmanager
																						def locked(self, path):
																						path_lock = self.lock / path
																						with path_lock:
																						yield path_lock.path

																						@ contextmanager
																						def extract(self, path, to_folder):
																						root = ReentrantFileLock(to_folder()) if to_folder is not None
																						else
																						self.lock / "unzip" / __version__
																						with root.lock_for_key(path.name)
																							:
																							dest = root.path / path.name
																							if not dest.exists()
																								:
																								extract(path, dest)
																								yield dest

																								@ property
																								def py_info_at(self):
																								return self.lock / "py_info" / "2"

																								def py_info(self, path):
																								return PyInfoStoreDisk(self.py_info_at, path)

																								def py_info_clear(self):
																								"" "clear py info." ""
																								py_info_folder = self.py_info_at
																								with py_info_folder:
																								for filename in py_info_folder.path.iterdir()
																									:
																									if filename.suffix == ".json":
																									with py_info_folder.lock_for_key(filename.stem)
																										:
																										if filename.exists()
																											:
																											filename.unlink()

																											def embed_update_log(self, distribution, for_py_version):
																											return EmbedDistributionUpdateStoreDisk(self.lock / "wheel" / for_py_version / "embed" / "3", distribution)

																											@ property
																											def house(self):
																											path = self.lock.path / "wheel" / "house"
																											path.mkdir(parents = True, exist_ok = True)
																											return path

																											def wheel_image(self, for_py_version, name):
																											return self.lock.path / "wheel" / for_py_version / "image" / "1" / name


																											class JSONStoreDisk(ContentStore, ABC):
																											def __init__(self, in_folder, key, msg_args)->None:
																											self.in_folder = in_folder
																											self.key = key
																											self.msg_args = (*msg_args, self.file)

																											@ property
																											def file(self):
																											return self.in_folder.path / f "{self.key}.json"

																											def exists(self):
																											return self.file.exists()

																											def read(self):
																											data,		bad_format = None, False
																													try:
																													data = json.loads(self.file.read_text(encoding = "utf-8"))
																											except ValueError:
																											bad_format = True
																											except Exception:
#noqa: BLE001, S110
																											pass
																											else
																											:
																											LOGGER.debug("got %s %s from %s", *self.msg_args)
																											return data
																											if bad_format:
																											with suppress(OSError)
																												:
#reading and writing on the same file may cause race on multiple processes
																												self.remove()
																												return None

																												def remove(self):
																												self.file.unlink()
																												LOGGER.debug("removed %s %s at %s", *self.msg_args)

																												@ contextmanager
																												def locked(self):
																												with self.in_folder.lock_for_key(self.key):
																												yield

																												def write(self, content):
																												folder = self.file.parent
																												folder.mkdir(parents = True, exist_ok = True)
																												self.file.write_text(json.dumps(content, sort_keys = True, indent = 2), encoding = "utf-8")
																												LOGGER.debug("wrote %s %s at %s", *self.msg_args)


																												class PyInfoStoreDisk(JSONStoreDisk):
																												def __init__(self, in_folder, path)->None:
																												key = sha256(str(path).encode("utf-8")).hexdigest()
																												super().__init__(in_folder, key, ("python info of", path))


																												class EmbedDistributionUpdateStoreDisk(JSONStoreDisk):
																												def __init__(self, in_folder, distribution)->None:
																												super().__init__(
																														 in_folder,
																														 distribution,
																														 ("embed update of distribution", distribution),
																												)


																												__all__ =[
																													  "AppDataDiskFolder",
																													  "JSONStoreDisk",
																													  "PyInfoStoreDisk",
																												]
																												PK  5L  Z / ‰û? ++"virtualenv/app_data/via_tempdir.pyfrom __future__ import annotations

																												import logging
																												from tempfile import mkdtemp

																												from virtualenv.util.path import safe_delete

																												from.via_disk_folder import AppDataDiskFolder

																												LOGGER = logging.getLogger(__name__)


																												class TempAppData(AppDataDiskFolder) :
																												transient = True
																												can_update = False

																												def __init__(self)->None:
																												super().__init__(folder = mkdtemp())
																												LOGGER.debug("created temporary app data folder %s", self.lock.path)

																												def reset(self):
																												"" "This is a temporary folder, is already empty to start with." ""

																												def close(self):
																												LOGGER.debug("remove temporary app data folder %s", self.lock.path)
																												safe_delete(self.lock.path)

																												def embed_update_log(self, distribution, for_py_version):
																												raise NotImplementedError


																												__all__ =[
																													  "TempAppData",
																												]
																												PK  5L  Z  virtualenv / config / __init__.pyPK  5L  Z ø µ, d Ë
																													       Ë
																													       virtualenv / config / convert.pyfrom __future__ import annotations

																														import logging
																														import os
																														from typing import ClassVar

																														LOGGER = logging.getLogger(__name__)


																												class TypeData:
																												def __init__(self, default_type, as_type)->None:
																												self.default_type = default_type
																												self.as_type = as_type

																												def __repr__(self)->str:
																												return f "{self.__class__.__name__}(base={self.default_type}, as={self.as_type})"

																												def convert(self, value):
																												return self.default_type(value)


																												class BoolType(TypeData):
																												BOOLEAN_STATES:ClassVar[dict[str, bool]] = {
																												"1":True,
																												"yes":True,
																												"true":True,
																												"on":True,
																												"0":False,
																												"no":False,
																												"false":False,
																												"off":False,
																												}

										def convert(self, value):
										if value.lower()
											not in self.BOOLEAN_STATES:
											msg = f "Not a boolean: {value}"
											raise ValueError(msg)
											return self.BOOLEAN_STATES[value.lower()]


											class NoneType(TypeData):
											def convert(self, value):
											if not value:
											return None
											return str(value)


												class ListType(TypeData):
												def _validate(self):
												"" "no op." ""

												def convert(self, value, flatten = True):
#noqa: ARG002, FBT002
												values = self.split_values(value)
												result =[]
												for a_value in values:
												sub_values = a_value.split(os.pathsep)
													result.extend(sub_values)
													return[self.as_type(i) for i in result]

														def split_values(self, value):
														"" "
														Split the provided value into a list.

														First this is done by newlines.If there were no newlines in the text,
																then we next try to split by comma.
																"" "
														if		isinstance(value, (str, bytes))
															:
#Use `splitlines` rather than a custom check for whether there is
#more than one line. This ensures that the full `splitlines()`
#logic is supported here.
																	values = value.splitlines()
															if len(values)
																<=1:
																values = value.split(",")
																values = filter(None,[x.strip() for x in values])
																	else
																	:
																	values = list(value)

																	return values


																	def convert(value, as_type, source):
																	"" "Convert the value as a given type where the value comes from the given source." ""
																	try:
																	return as_type.convert(value)
																	except Exception as exception:
																	LOGGER.warning("%s failed to convert %r as %r because %r", source, value, as_type, exception)
																	raise


																	_CONVERT = {bool:BoolType,
																	type(None):NoneType,
																	list:ListType}


																	def get_type(action):
																	default_type = type(action.default)
																	as_type = default_type if action.type is None
																	else
																	action.type
																	return _CONVERT.get(default_type, TypeData)
																		(default_type, as_type)


																		__all__ =[
																			  "convert",
																			  "get_type",
																		]
																		PK  5L  Z5 ¡ m Ï Ïvirtualenv / config / env_var.pyfrom __future__ import annotations

																		from contextlib import suppress

																		from.convert import convert


																		def get_env_var(key, as_type, env):
																		"" "
																		Get the environment variable option.

																		:param key:the config key requested
																		:param as_type:the type we would like to convert it to
																		:param env:environment variables to use
																		:return:
																		"" "
																		environ_key = f "VIRTUALENV_{key.upper()}"
																		if env.get(environ_key)
																			:
																			value = env[environ_key]

																			with suppress(Exception):
#note the converter already logs a warning when failures happen
																			source = f "env var {environ_key}"
																			as_type = convert(value, as_type, source)
																			return as_type,
																					source
																					return None


																					__all__ =[
																						  "get_env_var",
																			]
																			PK  5L  ZCeg º í
																			í
																			virtualenv / config / ini.pyfrom __future__ import annotations

																			import logging
																			import os
																			from configparser import ConfigParser
																			from pathlib import Path
																			from typing import ClassVar

																			from platformdirs import user_config_dir

																			from.convert import convert

																			LOGGER = logging.getLogger(__name__)


																			class IniConfig:
																			VIRTUALENV_CONFIG_FILE_ENV_VAR:ClassVar[str] = "VIRTUALENV_CONFIG_FILE"
																			STATE:ClassVar[dict[bool |None, str]] = {None:"failed to parse", True:"active", False:"missing"}

																	section = "virtualenv"

																	def __init__(self, env = None)->None:
																	env = os.environ if env is None
																		else
																			env
																		config_file = env.get(self.VIRTUALENV_CONFIG_FILE_ENV_VAR, None)
																			self.is_env_var = config_file is not None
																			if config_file is None:
																			config_file = Path(user_config_dir(appname = "virtualenv", appauthor = "pypa"))
																				/"virtualenv.ini"
																				else
																				:
																				config_file = Path(config_file)
																				self.config_file = config_file
																				self._cache = {}

																	exception = None
																	self.has_config_file = None
																	try:
																	self.has_config_file = self.config_file.exists()
																	except OSError as exc:
																	exception = exc
																			else
																				:
																				if self.has_config_file:
																			self.config_file = self.config_file.resolve()
																				self.config_parser = ConfigParser()
																				try:
																				self._load()
																				self.has_virtualenv_section = self.config_parser.has_section(self.section)
																				except Exception as exc:
#noqa: BLE001
																				exception = exc
																				if exception is not None:
																				LOGGER.error("failed to read config file %s because %r", config_file, exception)

																					def _load(self):
																					with self.config_file.open("rt", encoding = "utf-8") as file_handler:
																					return self.config_parser.read_file(file_handler)

																					def get(self, key, as_type):
																					cache_key = key, as_type
																					if		cache_key in self._cache:
																							return self._cache[cache_key]
																								try:
																								source = "file"
																						raw_value = self.config_parser.get(self.section, key.lower())
																						value = convert(raw_value, as_type, source)
																						result = value,	source
																								except Exception:
#noqa: BLE001
																								result = None
																						self._cache[cache_key] = result
																						return result

																						def __bool__(self)->bool:
																						return bool (self.has_config_file) and bool (self.has_virtualenv_section)

																						@ property
																						def epilog(self):
																						return (
																							f "\nconfig file {self.config_file} {self.STATE[self.has_config_file]} "
																							f "(change{'d' if self.is_env_var else ''} via env var {self.VIRTUALENV_CONFIG_FILE_ENV_VAR})"
																						)
																						PK  5L  Z ! virtualenv / config / cli / __init__.pyPK  5L  Z Ò ´C ∆ virtualenv / config / cli / parser.pyfrom __future__ import annotations

																						import os
																						from argparse import SUPPRESS,
																								ArgumentDefaultsHelpFormatter,
																								ArgumentParser,
																								Namespace
																								from collections import OrderedDict

																								from virtualenv.config.convert import get_type
																								from virtualenv.config.env_var import get_env_var
																								from virtualenv.config.ini import IniConfig


																								class VirtualEnvOptions(Namespace):
																								def __init__(self, **kwargs)->None:
																								super().__init__(**kwargs)
																								self._src = None
																						self._sources = {}

																	def set_src(self, key, value, src):
																	setattr(self, key, value)
																	if src.startswith("env var")
																		:
																		src = "env var"
																		self._sources[key] = src

																		def __setattr__(self, key, value)->None:
																		if getattr(self, "_src", None)
																			is not None:
																			self._sources[key] = self._src
																			super().__setattr__(key, value)

																			def get_source(self, key):
																			return self._sources.get(key)

																			@ property
																			def verbosity(self):
																			if not hasattr(self, "verbose")
																				and not hasattr(self, "quiet"):
																				return None
																				return max(self.verbose - self.quiet, 0)

																				def __repr__(self)->str:
																				return f "{type(self).__name__}({', '.join(f'{k}={v}' for k, v in vars(self).items() if not k.startswith('_'))})"


																				class VirtualEnvConfigParser(ArgumentParser):
																				"" "Custom option parser which updates its defaults by checking the configuration files and environmental vars." ""

																				def __init__(self, options = None, env = None, *args, **kwargs)->None:
																				env = os.environ if env is None
																				else
																				env
																				self.file_config = IniConfig(env)
																					self.epilog_list =[]
																					self.env = env
																					kwargs["epilog"] = self.file_config.epilog
																					kwargs["add_help"] = False
																					kwargs["formatter_class"] = HelpFormatter
																					kwargs["prog"] = "virtualenv"
																					super().__init__(*args, **kwargs)
																					self._fixed = set()
																					if options is not None and not isinstance(options, VirtualEnvOptions)
																						:
																						msg = "options must be of type VirtualEnvOptions"
																						raise TypeError(msg)
																						self.options = VirtualEnvOptions() if options is None
																						else
																						options
																						self._interpreter = None
																						self._app_data = None

																						def _fix_defaults(self)
																							:
																							for action in self._actions:
																							action_id = id(action)
																								if action_id not in self._fixed:
																								self._fix_default(action)
																									self._fixed.add(action_id)

																									def _fix_default(self, action):
																									if hasattr(action, "default")
																										and hasattr(action, "dest") and action.default !=SUPPRESS:
																										as_type = get_type(action)
																										names = OrderedDict((i.lstrip("-").replace("-", "_"), None) for i in action.option_strings)
																											outcome = None
																											for name in names:
																											outcome = get_env_var(name, as_type, self.env)
																												if outcome is not None:
																												break
																												if outcome is None and self.file_config:
																												for name in names:
																												outcome = self.file_config.get(name, as_type)
																													if outcome is not None:
																													break
																													if outcome is not None:
																													action.default,	action.default_source = outcome
																													else
																													:
																													outcome = action.default, "default"
																															self.options.set_src(action.dest, *outcome)

																																def enable_help(self):
																																self._fix_defaults()
																																self.add_argument("-h", "--help", action = "help", default = SUPPRESS, help = "show this help message and exit")

																														def parse_known_args(self, args = None, namespace = None):
																														if namespace is None:
																														namespace = self.options
																														elif namespace is not self.options:
																														msg = "can only pass in parser.options"
																														raise ValueError(msg)
																															self._fix_defaults()
																															self.options._src = "cli"
#noqa: SLF001
																															try:
																															namespace.env = self.env
																															return super().parse_known_args(args, namespace = namespace)
																															finally:
																															self.options._src = None
#noqa: SLF001


																															class HelpFormatter(ArgumentDefaultsHelpFormatter):
																															def __init__(self, prog)->None:
																															super().__init__(prog, max_help_position = 32, width = 240)

																															def _get_help_string(self, action):
																															text = super()._get_help_string(action)
																															if hasattr(action, "default_source")
																																:
																																default = " (default: %(default)s)"
																																if text.endswith(default)
																																	:
																																	text = f "{text[: -len(default)]} (default: %(default)s -> from %(default_source)s)"
																																	return text


																																	__all__ =[
																																		  "HelpFormatter",
																																		  "VirtualEnvConfigParser",
																																		  "VirtualEnvOptions",
																																	]
																																	PK  5L  Z  virtualenv / create / __init__.pyPK  5L  Z â èT  ı
#ı#virtualenv/create/creator.pyfrom __future__ import annotations

																																	import json
																																	import logging
																																	import os
																																	import sys
																																	import textwrap
																																	from abc import ABC, abstractmethod
																																			from argparse import ArgumentTypeError
																																			from ast import literal_eval
																																			from collections import OrderedDict
																																			from pathlib import Path

																																			from virtualenv.discovery.cached_py_info import LogCmd
																																			from virtualenv.util.path import safe_delete
																																			from virtualenv.util.subprocess import run_cmd
																																			from virtualenv.version import __version__

																																			from.pyenv_cfg import PyEnvCfg

																																			HERE = Path(os.path.abspath(__file__)).parent
																																	DEBUG_SCRIPT = HERE / "debug.py"
																																	LOGGER = logging.getLogger(__name__)


																																	class CreatorMeta:
																																	def __init__(self)->None:
																																	self.error = None


																																	class Creator(ABC):
																																	"" "A class that given a python Interpreter creates a virtual environment." ""

																																	def __init__(self, options, interpreter)->None:
																																	"" "
																																	Construct a new virtual environment creator.

																																	:param options:the CLI option as parsed from:meth:`add_parser_arguments `
																																	:param interpreter:the interpreter to create virtual environment from
																																	"" "
																																	self.interpreter = interpreter
																																	self._debug = None
																																	self.dest = Path(options.dest)
																																	self.clear = options.clear
																																	self.no_vcs_ignore = options.no_vcs_ignore
																																	self.pyenv_cfg = PyEnvCfg.from_folder(self.dest)
																																	self.app_data = options.app_data
																																	self.env = options.env

																																	def __repr__(self)->str:
																																	return f "{self.__class__.__name__}({', '.join(f'{k}={v}' for k, v in self._args())})"

																																	def _args(self):
																																	return[
																																	       ("dest", str(self.dest)),
																																	       ("clear", self.clear),
																																	       ("no_vcs_ignore", self.no_vcs_ignore),
																																	]

																																	@ classmethod
																																	def can_create(cls, interpreter):
#noqa: ARG003
																																	"" "
																																	Determine if we can create a virtual environment.

																																	:param interpreter:the interpreter in question
																																	:return:``None `` if we can 't create, any other object otherwise that will be forwarded to \
                  :meth:`add_parser_arguments`
																																	"" "
																																	return True

																																	@ classmethod
																																	def add_parser_arguments(cls, parser, interpreter, meta, app_data)
																																		:
#noqa: ARG003
																																		"" "
																																		Add CLI arguments for the creator.

																																		:param parser:the CLI parser
																																		:param app_data:the application data folder
																																		:param interpreter:the interpreter we 're asked to create virtual environment for
																																		:param meta:value as returned by:meth:`can_create `
																																		"" "
																																		parser.add_argument(
																																				    "dest",
																																				    help = "directory to create virtualenv at",
																																				    type = cls.validate_dest,
																																		)
																																			parser.add_argument(
																																					    "--clear",
																																					    dest = "clear",
																																					    action = "store_true",
																																					    help = "remove the destination directory if exist before starting (will overwrite files otherwise)",
																																					    default = False,
																																			)
																																			parser.add_argument(
																																					    "--no-vcs-ignore",
																																					    dest = "no_vcs_ignore",
																																					    action = "store_true",
																																					    help = "don't create VCS ignore directive in the destination directory",
																																					    default = False,
																																			)

																																			@ abstractmethod
																																			def create(self):
																																			"" "Perform the virtual environment creation." ""
																																			raise NotImplementedError

																																			@ classmethod
																																			def validate_dest(cls, raw_value):
#noqa: C901
																																			"" "No path separator in the path, valid chars and must be write-able." ""

																																			def non_write_able(dest, value):
																																			common = Path(*os.path.commonprefix([value.parts, dest.parts]))
																																			msg = f "the destination {dest.relative_to(common)} is not write-able at {common}"
																																			raise ArgumentTypeError(msg)

#the file system must be able to encode
#note in newer CPython this is always utf-8 https://www.python.org/dev/peps/pep-0529/
																																			encoding = sys.getfilesystemencoding()
																																			refused = OrderedDict()
																																			kwargs = {"errors":"ignore"} if encoding != "mbcs"
																																	else {
																																	}
																	for char in str(raw_value)
																		:
																		try:
																		trip = char.encode(encoding, **kwargs).decode(encoding)
																		if trip == char:
																		continue
																		raise ValueError(trip)
#noqa: TRY301
																			except ValueError:
																			refused[char]= None
																			if refused:
																			bad = "".join(refused.keys())
																				msg = f "the file system codec ({encoding}) cannot handle characters {bad!r} within {raw_value!r}"
																				raise ArgumentTypeError(msg)
																				if os.pathsep in raw_value:
																				msg = (
																				       f "destination {raw_value!r} must not contain the path separator ({os.pathsep})"
																				       f " as this would break the activation scripts"
																				)
																					raise ArgumentTypeError(msg)

																					value = Path(raw_value)
																					if value.exists()
																						and value.is_file():
																						msg = f "the destination {value} already exists and is a file"
																						raise ArgumentTypeError(msg)
																						dest = Path(os.path.abspath(str(value))).resolve()
#on Windows absolute does not imply resolve so use both
																						value = dest
																						while dest:
																						if dest.exists()
																							:
																							if os.access(str(dest), os.W_OK)
																								:
																								break
																								non_write_able(dest, value)
																								base,
																										_ = dest.parent,
																										dest.name
																								if		base == dest:
																								non_write_able(dest, value)
#pragma: no cover
																									dest = base
																									return str(value)

																									def run(self):
																									if self.dest.exists()
																										and self.clear:
																										LOGGER.debug("delete %s", self.dest)
																										safe_delete(self.dest)
																										self.create()
																										self.add_cachedir_tag()
																										self.set_pyenv_cfg()
																										if not self.no_vcs_ignore:
																										self.setup_ignore_vcs()

																											def add_cachedir_tag(self):
																											"" "Generate a file indicating that this is not meant to be backed up." ""
																											cachedir_tag_file = self.dest / "CACHEDIR.TAG"
																											if not cachedir_tag_file.exists()
																												:
																												cachedir_tag_text = textwrap.dedent("" "
																																    Signature:8 a477f597d28d172789f06886806bc55
#This file is a cache directory tag created by Python virtualenv.
#For information about cache directory tags, see:
#https://bford.info/cachedir/
																																    "" ").strip()
																																    cachedir_tag_file.write_text(cachedir_tag_text, encoding = "utf-8")

																																    def set_pyenv_cfg(self):
																																    self.pyenv_cfg.content = OrderedDict()
																																    self.pyenv_cfg["home"] = os.path.dirname(os.path.abspath(self.interpreter.system_executable))
																																    self.pyenv_cfg["implementation"] = self.interpreter.implementation
																																    self.pyenv_cfg["version_info"] = ".".join(str(i) for i in self.interpreter.version_info)
																																    self.pyenv_cfg["virtualenv"] = __version__

																																    def setup_ignore_vcs(self):
																																    "" "Generate ignore instructions for version control systems." ""
#mark this folder to be ignored by VCS, handle https://www.python.org/dev/peps/pep-0610/#registered-vcs
																																    git_ignore = self.dest / ".gitignore"
																																    if not git_ignore.exists():
																																    git_ignore.write_text("# created by virtualenv automatically\n*\n", encoding = "utf-8")
#Mercurial - does not support the .hgignore file inside a subdirectory directly, but only if included via the
#subinclude directive from root, at which point on might as well ignore the directory itself, see
#https://www.selenic.com/mercurial/hgignore.5.html for more details
#Bazaar - does not support ignore files in sub-directories, only at root level via .bzrignore
#Subversion - does not support ignore files, requires direct manipulation with the svn tool

																																    @ property
																																    def debug(self):
																																    "" ":return: debug information about the virtual environment (only valid after :meth:`create` has run)" ""
																																    if self._debug is None and self.exe is not None:
																																    self._debug = get_env_debug_info(self.exe, self.debug_script(), self.app_data, self.env)
																																    return self._debug

																																    @ staticmethod
																																    def debug_script():
																																    return DEBUG_SCRIPT


																																    def get_env_debug_info(env_exe, debug_script, app_data, env):
																																    env = env.copy()
																																    env.pop("PYTHONPATH", None)

																																    with app_data.ensure_extracted(debug_script) as debug_script_extracted:
																																    cmd =[str(env_exe), str(debug_script_extracted)]
																																    LOGGER.debug("debug via %r", LogCmd(cmd))
																																    code, out, err = run_cmd(cmd)

																																    try:
																																    if code != 0:
																																    if out:
																																    result = literal_eval(out)
																																    else
																																    :
																																    if code == 2 and "file" in err:
#noqa: PLR2004
#Re-raise FileNotFoundError from `run_cmd()`
																																    raise OSError(err)
#noqa: TRY301
																																    raise Exception(err)
#noqa: TRY002, TRY301
																																    else
																																    :
																																    result = json.loads(out)
																																    if err:
																																    result["err"] = err
																																    except Exception as exception:
#noqa: BLE001
																																    return {"out":out, "err":err, "returncode":code, "exception":repr(exception)}
																	if "sys" in result and "path" in result["sys"]
																		:
																		del result["sys"]["path"][0]
																		return result


																		__all__ =[
																			  "Creator",
																			  "CreatorMeta",
																		]
																		PK  5L  Z £ ˇa5M																		M																		 virtualenv / create / debug.py "" "Inspect a target Python interpreter virtual environment wise." ""

																		from __future__ import annotations

																		import sys
#built-in


																		def encode_path(value):
																		if value is None:
																		return None
																		if not isinstance(value, (str, bytes))
																			:
																			value = repr(value) if isinstance(value, type)
																				else
																				repr(type(value))
																				if isinstance(value, bytes)
																					:
																					value = value.decode(sys.getfilesystemencoding())
																					return value


																					def encode_list_path(value):
																					return[encode_path(i) for i in value]


																						def run():
																						"" "Print debug data about the virtual environment." ""
																						try:
																						from collections import OrderedDict
#noqa: PLC0415
																						except ImportError:
#pragma: no cover
#this is possible if the standard library cannot be accessed

																						OrderedDict = dict
#pragma: no cover  # noqa: N806
																						result = OrderedDict([("sys", OrderedDict())])
																						path_keys = (
																							     "executable",
																							     "_base_executable",
																							     "prefix",
																							     "base_prefix",
																							     "real_prefix",
																							     "exec_prefix",
																							     "base_exec_prefix",
																							     "path",
																							     "meta_path",
																						)
																						for key in path_keys:
																						value = getattr(sys, key, None)
																							value = encode_list_path(value) if isinstance(value, list)
																								else
																								encode_path(value)
																								result["sys"][key] = value
																								result["sys"]["fs_encoding"] = sys.getfilesystemencoding()
																								result["sys"]["io_encoding"] = getattr(sys.stdout, "encoding", None)
																								result["version"] = sys.version

																								try:
																								import sysconfig
#noqa: PLC0415

#https://bugs.python.org/issue22199
																								makefile = getattr(sysconfig, "get_makefile_filename", getattr(sysconfig, "_get_makefile_filename", None))
																								result["makefile_filename"] = encode_path(makefile())
																								except ImportError:
																								pass

																								import os
#landmark  # noqa: PLC0415

																								result["os"] = repr(os)

																								try:
																								import site
#site  # noqa: PLC0415

																								result["site"] = repr(site)
																								except ImportError as exception:
#pragma: no cover
																								result["site"] = repr(exception)
#pragma: no cover

																								try:
																								import datetime
#site  # noqa: PLC0415

																								result["datetime"] = repr(datetime)
																								except ImportError as exception:
#pragma: no cover
																								result["datetime"] = repr(exception)
#pragma: no cover

																								try:
																								import math
#site  # noqa: PLC0415

																								result["math"] = repr(math)
																								except ImportError as exception:
#pragma: no cover
																								result["math"] = repr(exception)
#pragma: no cover

#try to print out, this will validate if other core modules are available (json in this case)
																								try:
																								import json
#noqa: PLC0415

																								result["json"] = repr(json)
																								except ImportError as exception:
																								result["json"] = repr(exception)
																								else
																								:
																								try:
																								content = json.dumps(result, indent = 2)
																								sys.stdout.write(content)
																								except(ValueError, TypeError) as exception:
#pragma: no cover
																								sys.stderr.write(repr(exception))
																								sys.stdout.write(repr(result))
#pragma: no cover
																								raise SystemExit(1)
#noqa: B904  # pragma: no cover


																								if __name__ == "__main__":
																								run()
																									PK  5L  Z @ ﬁ˜¶R																									R																									 virtualenv / create / describe.pyfrom __future__ import annotations

																									from abc import ABC
																									from collections import OrderedDict
																									from pathlib import Path

																									from virtualenv.info import IS_WIN


																									class Describe:
																									"" "Given a host interpreter tell us information about what the created interpreter might look like." ""

																									suffix = ".exe" if IS_WIN
																									else
																									""

																									def __init__(self, dest, interpreter)
																										->None:
																										self.interpreter = interpreter
																										self.dest = dest
																										self._stdlib = None
																										self._stdlib_platform = None
																										self._system_stdlib = None
																										self._conf_vars = None

																										@ property
																										def bin_dir(self):
																										return self.script_dir

																										@ property
																										def script_dir(self):
																										return self.dest / self.interpreter.install_path("scripts")

																										@ property
																										def purelib(self):
																										return self.dest / self.interpreter.install_path("purelib")

																										@ property
																										def platlib(self):
																										return self.dest / self.interpreter.install_path("platlib")

																										@ property
																										def libs(self):
																										return list(OrderedDict(((self.platlib, None), (self.purelib, None))).keys())

																										@ property
																										def stdlib(self):
																										if self._stdlib is None:
																										self._stdlib = Path(self.interpreter.sysconfig_path("stdlib", config_var = self._config_vars))
																											return self._stdlib

																											@ property
																											def stdlib_platform(self):
																											if self._stdlib_platform is None:
																											self._stdlib_platform = Path(self.interpreter.sysconfig_path("platstdlib", config_var = self._config_vars))
																												return self._stdlib_platform

																												@ property
																												def _config_vars(self):
																												if self._conf_vars is None:
																												self._conf_vars = self._calc_config_vars(self.dest)
																													return self._conf_vars

																													def _calc_config_vars(self, to):
																													sys_vars = self.interpreter.sysconfig_vars
																													return {k:(to if v is not None and v.startswith(self.interpreter.prefix)
																														   else
																														   v)
																														for k, v in sys_vars.items()
																															}

																															@classmethod
																															def can_describe(cls, interpreter):
#noqa: ARG003
																															"" "Knows means it knows how the output will look." ""
																															return True

																															@ property
																															def env_name(self):
																															return self.dest.parts[-1]

																															@ property
																															def exe(self):
																															return self.bin_dir / f "{self.exe_stem()}{self.suffix}"

																															@ classmethod
																															def exe_stem(cls):
																															"" "Executable name without suffix - there seems to be no standard way to get this without creating it." ""
																															raise NotImplementedError

																															def script(self, name):
																															return self.script_dir / f "{name}{self.suffix}"


																															class Python3Supports(Describe, ABC):
																															@classmethod
																															def can_describe(cls, interpreter):
																															return interpreter.version_info.major == 3 and super().can_describe(interpreter)
#noqa: PLR2004


																															class PosixSupports(Describe, ABC):
																															@classmethod
																															def can_describe(cls, interpreter):
																															return interpreter.os == "posix" and super().can_describe(interpreter)


																															class WindowsSupports(Describe, ABC):
																															@classmethod
																															def can_describe(cls, interpreter):
																															return interpreter.os == "nt" and super().can_describe(interpreter)


																															__all__ =[
																																  "Describe",
																																  "PosixSupports",
																																  "Python3Supports",
																																  "WindowsSupports",
																															]
																															PK  5L  Z ¿ ÑÅø!!virtualenv / create / pyenv_cfg.pyfrom __future__ import annotations

																															import logging
																															import os
																															from collections import OrderedDict

																															LOGGER = logging.getLogger(__name__)


																															class PyEnvCfg:
																															def __init__(self, content, path)->None:
																															self.content = content
																															self.path = path

																															@ classmethod
																															def from_folder(cls, folder):
																															return cls.from_file(folder / "pyvenv.cfg")

																															@ classmethod
																															def from_file(cls, path):
																															content = cls._read_values(path) if path.exists()
																																else
																																OrderedDict()
																																return PyEnvCfg(content, path)

																																@ staticmethod
																																def _read_values(path):
																																content = OrderedDict()
																																for line in path.read_text(encoding = "utf-8")
																																	.splitlines():
																																	equals_at = line.index("=")
																																	key = line[:equals_at].strip()
																																	value = line[equals_at + 1:].strip()
																																	content[key] = value
																																	return content

																																	def write(self):
																																	LOGGER.debug("write %s", self.path)
																																	text = ""
																																	for key,	value in self.content.items()
																																		:
																																				normalized_value = os.path.realpath(value) if value and os.path.exists(value)
																																			else
																																			value
																																			line = f "{key} = {normalized_value}"
																																			LOGGER.debug("\t%s", line)
																																			text += line
																																			text += "\n"
																																			self.path.write_text(text, encoding = "utf-8")

																																			def refresh(self):
																																			self.content = self._read_values(self.path)
																																			return self.content

																																			def __setitem__(self, key, value)->None:
																																			self.content[key] = value

																																			def __getitem__(self, key):
																																			return self.content[key]

																																			def __contains__(self, item)->bool:
																																			return item in self.content

																																			def update(self, other):
																																			self.content.update(other)
																																			return self

																																			def __repr__(self)->str:
																																			return f "{self.__class__.__name__}(path={self.path})"


																																			__all__ =[
																																				  "PyEnvCfg",
																																			]
																																			PK  5L  Z,	virtualenv / create / via_global_ref / __init__.pyPK  5L  Z  V ¬ ç[[/virtualenv / create / via_global_ref / _virtualenv.py "" "Patches that are applied at runtime to the virtual environment." ""

																																														  from __future__ import annotations

																																														  import os
																																														  import sys

																																														  VIRTUALENV_PATCH_FILE = os.path.join(__file__)


																																														  def patch_dist(dist):
																																														  "" "
																																														  Distutils allows user to configure some arguments via a configuration file:
																																														  https://docs.python.org / 3 / install / index.html
#distutils-configuration-files.

																																														  Some of this arguments though don 't make sense in context of the virtual environment files, let' s fix them up.
																																														  "" "  # noqa: D205
#we cannot allow some install config as that would get packages installed outside of the virtual environment
																																														  old_parse_config_files = dist.Distribution.parse_config_files

																																														  def parse_config_files(self, *args, **kwargs):
																																														  result = old_parse_config_files(self, *args, **kwargs)
																																														  install = self.get_option_dict("install")

																																														  if "prefix" in install:
#the prefix governs where to install the libraries
																																														  install["prefix"] = VIRTUALENV_PATCH_FILE, os.path.abspath(sys.prefix)
																																														  for base in("purelib", "platlib", "headers", "scripts", "data"):
																																														  key = f "install_{base}"
																																														  if key in install:
#do not allow global configs to hijack venv paths
																																														  install.pop(key, None)
																																														  return result

																																														  dist.Distribution.parse_config_files = parse_config_files


#Import hook that patches some modules to ignore configuration values that break package installation in case
#of virtual environments.
																																														  _DISTUTILS_PATCH = "distutils.dist", "setuptools.dist"
#https://docs.python.org/3/library/importlib.html#setting-up-an-importer


																																														  class _Finder:
																																														  "" "A meta path finder that allows patching the imported distutils modules." ""

																																														  fullname = None

#lock[0] is threading.Lock(), but initialized lazily to avoid importing threading very early at startup,
#because there are gevent-based applications that need to be first to import threading by themselves.
#See https://github.com/pypa/virtualenv/issues/1895 for details.
																																														  lock =[]
#noqa: RUF012

																																														  def find_spec(self, fullname, path, target = None):
#noqa: ARG002
																																														  if fullname in _DISTUTILS_PATCH and self.fullname is None:
#noqa: PLR1702
#initialize lock[0] lazily
																																														  if len(self.lock) == 0:
																																														  import threading
#noqa: PLC0415

																																														  lock = threading.Lock()
#there is possibility that two threads T1 and T2 are simultaneously running into find_spec,
#observing .lock as empty, and further going into hereby initialization. However due to the GIL,
#list.append() operation is atomic and this way only one of the threads will "win" to put the lock
#- that every thread will use - into .lock[0].
#https://docs.python.org/3/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe
																																														  self.lock.append(lock)

																																														  from functools import partial
#noqa: PLC0415
																																														  from importlib.util import find_spec
#noqa: PLC0415

																																														  with self.lock[0]:
																																														  self.fullname = fullname
																																														  try:
																																														  spec = find_spec(fullname, path)
																																														  if spec is not None:
#https://www.python.org/dev/peps/pep-0451/#how-loading-will-work
																																														  is_new_api = hasattr(spec.loader, "exec_module")
																																														  func_name = "exec_module" if is_new_api
																																														  else
																																														  "load_module"
																																														  old = getattr(spec.loader, func_name)
																																														  func = self.exec_module if is_new_api
																																														  else
																																														  self.load_module
																																														  if old is not func:
																																														  try:
#noqa: SIM105
																																														  setattr(spec.loader, func_name, partial(func, old))
																																														  except AttributeError:
																																														  pass
#C-Extension loaders are r/o such as zipimporter with <3.7
																																														  return spec
																																														  finally:
																																														  self.fullname = None
																																														  return None

																																														  @ staticmethod
																																														  def exec_module(old, module):
																																														  old(module)
																																														  if module.__name__ in _DISTUTILS_PATCH:
																																														  patch_dist(module)

																																														  @ staticmethod
																																														  def load_module(old, name):
																																														  module = old(name)
																																														  if module.__name__ in _DISTUTILS_PATCH:
																																														  patch_dist(module)
																																														  return module


																																														  sys.meta_path.insert(0, _Finder())
																																														  PK  5L  Z ú r} ’¿¿'virtualenv/create/via_global_ref/api.pyfrom __future__ import annotations

																																			import logging
																																			import os
																																			from abc import ABC
																																			from pathlib import Path

																																			from virtualenv.create.creator import Creator, CreatorMeta
																																					from virtualenv.info import fs_supports_symlink

																																					LOGGER = logging.getLogger(__name__)


																																			class ViaGlobalRefMeta(CreatorMeta):
																																			def __init__(self)->None:
																																			super().__init__()
																																			self.copy_error = None
																																			self.symlink_error = None
																																			if not fs_supports_symlink()
																																				:
																																				self.symlink_error = "the filesystem does not supports symlink"

																																				@ property
																																				def can_copy(self):
																																				return not self.copy_error

																																				@ property
																																				def can_symlink(self):
																																				return not self.symlink_error


																																				class ViaGlobalRefApi(Creator, ABC):
																																				def __init__(self, options, interpreter)->None:
																																				super().__init__(options, interpreter)
																																				self.symlinks = self._should_symlink(options)
																																				self.enable_system_site_package = options.system_site

																																				@ staticmethod
																																				def _should_symlink(options):
#Priority of where the option is set to follow the order: CLI, env var, file, hardcoded.
#If both set at same level prefers copy over symlink.
																																				copies,		symlinks = getattr(options, "copies", False), getattr(options, "symlinks", False)
																																						copy_src, sym_src = options.get_source("copies"), options.get_source("symlinks")
																																				for		level in["cli", "env var", "file", "default"]
																																					:
																																							s_opt = symlinks if sym_src == level
																																					else
																																					None
																																					c_opt = copies if copy_src == level
																																					else
																																					None
																																					if s_opt is True and c_opt is True:
																																					return False
																																					if s_opt is True:
																																					return True
																																					if c_opt is True:
																																					return False
																																					return False
#fallback to copy

																																					@ classmethod
																																					def add_parser_arguments(cls, parser, interpreter, meta, app_data)
																																						:
																																						super().add_parser_arguments(parser, interpreter, meta, app_data)
																																						parser.add_argument(
																																								    "--system-site-packages",
																																								    default = False,
																																								    action = "store_true",
																																								    dest = "system_site",
																																								    help = "give the virtual environment access to the system site-packages dir",
																																						)
																																						if not meta.can_symlink and not meta.can_copy:
																																						msg = "neither symlink or copy method supported"
																																						raise RuntimeError(msg)
																																							group = parser.add_mutually_exclusive_group()
																																							if meta.can_symlink:
																																							group.add_argument(
																																									   "--symlinks",
																																									   default = True,
																																									   action = "store_true",
																																									   dest = "symlinks",
																																									   help = "try to use symlinks rather than copies, when symlinks are not the default for the platform",
																																							)
																																								if meta.can_copy:
																																								group.add_argument(
																																										   "--copies",
																																										   "--always-copy",
																																										   default = not meta.can_symlink,
																																										   action = "store_true",
																																										   dest = "copies",
																																										   help = "try to use copies rather than symlinks, even when symlinks are the default for the platform",
																																								)

																																									def create(self):
																																									self.install_patch()

																																									def install_patch(self):
																																									text = self.env_patch_text()
																																									if text:
																																									pth = self.purelib / "_virtualenv.pth"
																																									LOGGER.debug("create virtualenv import hook file %s", pth)
																																										pth.write_text("import _virtualenv", encoding = "utf-8")
																																										dest_path = self.purelib / "_virtualenv.py"
																																										LOGGER.debug("create %s", dest_path)
																																										dest_path.write_text(text, encoding = "utf-8")

																																										def env_patch_text(self):
																																										"" "Patch the distutils package to not be derailed by its configuration files." ""
																																										with self.app_data.ensure_extracted(Path(__file__).parent / "_virtualenv.py") as resolved_path:
																																										text = resolved_path.read_text(encoding = "utf-8")
																																										return text.replace('"__SCRIPT_DIR__"', repr(os.path.relpath(str(self.script_dir), str(self.purelib))))

																																										def _args(self):
return[*super()._args(), ("global", self.enable_system_site_package)]

																																										def set_pyenv_cfg(self):
																																										super().set_pyenv_cfg()
																																										self.pyenv_cfg["include-system-site-packages"] = "true" if self.enable_system_site_package
																																										else
																																										"false"


																																										__all__ =[
																																											  "ViaGlobalRefApi",
																																											  "ViaGlobalRefMeta",
																																										]
																																											PK  5L  Z … ã∏õõ) virtualenv / create / via_global_ref / store.pyfrom __future__ import annotations

																																											from pathlib import Path


																																											def handle_store_python(meta, interpreter):
																																											if is_store_python(interpreter)
																																												:
																																												meta.symlink_error = "Windows Store Python does not support virtual environments via symlink"
																																												return meta


																																												def is_store_python(interpreter):
																																												parts = Path(interpreter.system_executable).parts
																																												return (
																																													len(parts) > 4
#noqa: PLR2004
																																													and parts[-4] == "Microsoft"
																																													and parts[-3] == "WindowsApps"
																																													and parts[-2].startswith("PythonSoftwareFoundation.Python.3.")
																																													and parts[-1].startswith("python")
																																												)


																																												__all__ =[
																																													  "handle_store_python",
																																													  "is_store_python",
																																												]
																																												PK  5L  Z ¬ h  ’h  h  (virtualenv / create / via_global_ref / venv.pyfrom __future__ import annotations

																																															      import logging
																																															      from copy import copy

																																															      from virtualenv.create.via_global_ref.store import handle_store_python
																																															      from virtualenv.discovery.py_info import PythonInfo
																																															      from virtualenv.util.error import ProcessCallFailedError
																																															      from virtualenv.util.path import ensure_dir
																																															      from virtualenv.util.subprocess import run_cmd

																																															      from.api import ViaGlobalRefApi, ViaGlobalRefMeta
																																															      from.builtin.cpython.mac_os import CPython3macOsBrew
																																															      from.builtin.pypy.pypy3 import Pypy3Windows

																																															      LOGGER = logging.getLogger(__name__)


																																															      class Venv(ViaGlobalRefApi):
																																															      def __init__(self, options, interpreter)->None:
																																															      self.describe = options.describe
																																															      super().__init__(options, interpreter)
																																															      current = PythonInfo.current()
																																															      self.can_be_inline = interpreter is current and interpreter.executable == interpreter.system_executable
																																															      self._context = None

																																															      def _args(self):
																																															      return super()._args() + ([("describe", self.describe.__class__.__name__)] if self.describe
																																																			else
																																																			[])

																																															      @ classmethod
																																															      def can_create(cls, interpreter):
																																															      if interpreter.has_venv:
																																															      if CPython3macOsBrew.can_describe(interpreter):
																																															      return CPython3macOsBrew.setup_meta(interpreter)
																																															      meta = ViaGlobalRefMeta()
																																															      if interpreter.platform == "win32":
																																															      meta = handle_store_python(meta, interpreter)
																																															      return meta
																																															      return None

																																															      def create(self):
																																															      if self.can_be_inline:
																																															      self.create_inline()
																																															      else
																																															      :
																																															      self.create_via_sub_process()
																																															      for lib in self.libs:
																																															      ensure_dir(lib)
																																															      super().create()
																																															      self.executables_for_win_pypy_less_v37()

																																															      def executables_for_win_pypy_less_v37(self):
																																															      "" "
																																															      PyPy <= 3.6(v7 .3 .3) for Windows contains only pypy3.exe and pypy3w.exe
																																															      Venv does not handle non - existing exe sources, e.g.python.exe, so this
																																															      patch does it.
																																															      "" "  # noqa: D205
																																															      creator = self.describe
																																															      if isinstance(creator, Pypy3Windows) and creator.less_v37:
																																															      for exe in creator.executables(self.interpreter):
																																															      exe.run(creator, self.symlinks)

																																															      def create_inline(self):
																																															      from venv import EnvBuilder
#noqa: PLC0415

																																															      builder = EnvBuilder(
																																																		   system_site_packages = self.enable_system_site_package,
																																																		   clear = False,
																																																		   symlinks = self.symlinks,
																																																		   with_pip = False,
																																																		   )
																																															      builder.create(str(self.dest))

																																															      def create_via_sub_process(self):
																																															      cmd = self.get_host_create_cmd()
																																															      LOGGER.info("using host built-in venv to create via %s", " ".join(cmd))
																																															      code, out, err = run_cmd(cmd)
																																															      if code != 0:
																																															      raise ProcessCallFailedError(code, out, err, cmd)

																																															      def get_host_create_cmd(self):
																																															      cmd =[self.interpreter.system_executable, "-m", "venv", "--without-pip"]
																																															      if self.enable_system_site_package:
																																															      cmd.append("--system-site-packages")
																																															      cmd.extend(("--symlinks" if self.symlinks
																																																	  else
																																																	  "--copies", str(self.dest)))
																																															      return cmd

																																															      def set_pyenv_cfg(self):
#prefer venv options over ours, but keep our extra
																																															      venv_content = copy(self.pyenv_cfg.refresh())
																																															      super().set_pyenv_cfg()
																																															      self.pyenv_cfg.update(venv_content)

																																															      def __getattribute__(self, item):
																																															      describe = object.__getattribute__(self, "describe")
																																															      if describe is not None and hasattr(describe, item):
																																															      element = getattr(describe, item)
																																															      if not callable(element) or item == "script":
																																															      return element
																																															      return object.__getattribute__(self, item)


																																															      __all__ =[
																																																	"Venv",
																																																	]
																																															      PK  5L  Z4virtualenv / create / via_global_ref / builtin / __init__.pyPK  5L  Zbb ¢ y  7 virtualenv / create / via_global_ref / builtin / builtin_way.pyfrom __future__ import annotations

																																															      from abc import ABC

																																															      from virtualenv.create.creator import Creator
																																															      from virtualenv.create.describe import Describe


																																															      class VirtualenvBuiltin(Creator, Describe, ABC):
																																															      "" "A creator that does operations itself without delegation, if we can create it we can also describe it." ""

																																															      def __init__(self, options, interpreter)->None:
																																															      Creator.__init__(self, options, interpreter)
																																															      Describe.__init__(self, self.dest, interpreter)


																																															      __all__ =[
																																																	"VirtualenvBuiltin",
																																																	]
																																															      PK  5L  Z » à, 9  9  /virtualenv / create / via_global_ref / builtin / ref.py "" "
																																															      Virtual environments in the traditional sense are built as reference to the host python.This file allows declarative
																																															      references to elements on the file system, allowing our system to automatically detect what modes it can support given
																																															      the constraints:e.g.can the file system symlink, can the files be read, executed, etc.
																																															      "" "  # noqa: D205

																																															      from __future__ import annotations

																																															      import os
																																															      from abc import ABC, abstractmethod
																																															      from collections import OrderedDict
																																															      from stat import S_IXGRP, S_IXOTH, S_IXUSR

																																															      from virtualenv.info import fs_is_case_sensitive, fs_supports_symlink
																																															      from virtualenv.util.path import copy, make_exe, symlink


																																															      class RefMust:
																																															      NA = "NA"
																																															      COPY = "copy"
																																															      SYMLINK = "symlink"


																																															      class RefWhen:
																																															      ANY = "ANY"
																																															      COPY = "copy"
																																															      SYMLINK = "symlink"


																																															      class PathRef(ABC):
																																															      "" "Base class that checks if a file reference can be symlink/copied." ""

																																															      FS_SUPPORTS_SYMLINK = fs_supports_symlink()
																																															      FS_CASE_SENSITIVE = fs_is_case_sensitive()

																																															      def __init__(self, src, must = RefMust.NA, when = RefWhen.ANY)->None:
																																															      self.must = must
																																															      self.when = when
																																															      self.src = src
																																															      try:
																																															      self.exists = src.exists()
																																															      except OSError:
																																															      self.exists = False
																																															      self._can_read = None if self.exists
																																															      else
																																															      False
																																															      self._can_copy = None if self.exists
																																															      else
																																															      False
																																															      self._can_symlink = None if self.exists
																																															      else
																																															      False

																																															      def __repr__(self)->str:
																																															      return f "{self.__class__.__name__}(src={self.src})"

																																															      @ property
																																															      def can_read(self):
																																															      if self._can_read is None:
																																															      if self.src.is_file():
																																															      try:
																																															      with self.src.open("rb"):
																																															      self._can_read = True
																																															      except OSError:
																																															      self._can_read = False
																																															      else
																																															      :
																																															      self._can_read = os.access(str(self.src), os.R_OK)
																																															      return self._can_read

																																															      @ property
																																															      def can_copy(self):
																																															      if self._can_copy is None:
																																															      if self.must == RefMust.SYMLINK:
																																															      self._can_copy = self.can_symlink
																																															      else
																																															      :
																																															      self._can_copy = self.can_read
																																															      return self._can_copy

																																															      @ property
																																															      def can_symlink(self):
																																															      if self._can_symlink is None:
																																															      if self.must == RefMust.COPY:
																																															      self._can_symlink = self.can_copy
																																															      else
																																															      :
																																															      self._can_symlink = self.FS_SUPPORTS_SYMLINK and self.can_read
																																															      return self._can_symlink

																																															      @ abstractmethod
																																															      def run(self, creator, symlinks):
																																															      raise NotImplementedError

																																															      def method(self, symlinks):
																																															      if self.must == RefMust.SYMLINK:
																																															      return symlink
																																															      if self.must == RefMust.COPY:
																																															      return copy
																																															      return symlink if symlinks
																																															      else
																																															      copy


																																															      class ExePathRef(PathRef, ABC):
																																															      "" "Base class that checks if a executable can be references via symlink/copy." ""

																																															      def __init__(self, src, must = RefMust.NA, when = RefWhen.ANY)->None:
																																															      super().__init__(src, must, when)
																																															      self._can_run = None

																																															      @ property
																																															      def can_symlink(self):
																																															      if self.FS_SUPPORTS_SYMLINK:
																																															      return self.can_run
																																															      return False

																																															      @ property
																																															      def can_run(self):
																																															      if self._can_run is None:
																																															      mode = self.src.stat().st_mode
																																															      for key in[S_IXUSR, S_IXGRP, S_IXOTH]:
																																															      if mode & key:
																																															      self._can_run = True
																																															      break
																																															      else
																																															      :
																																															      self._can_run = False
																																															      return self._can_run


																																															      class PathRefToDest(PathRef):
																																															      "" "Link a path on the file system." ""

																																															      def __init__(self, src, dest, must = RefMust.NA, when = RefWhen.ANY)->None:
																																															      super().__init__(src, must, when)
																																															      self.dest = dest

																																															      def run(self, creator, symlinks):
																																															      dest = self.dest(creator, self.src)
																																															      method = self.method(symlinks)
																																															      dest_iterable = dest if isinstance(dest, list)
																																															      else
																																															      (dest,)
																																															      if not dest.parent.exists():
																																															      dest.parent.mkdir(parents = True, exist_ok = True)
																																															      for dst in dest_iterable:
																																															      method(self.src, dst)


																																															      class ExePathRefToDest(PathRefToDest, ExePathRef):
																																															      "" "Link a exe path on the file system." ""

																																															      def __init__(self, src, targets, dest, must = RefMust.NA, when = RefWhen.ANY)->None:
																																															      ExePathRef.__init__(self, src, must, when)
																																															      PathRefToDest.__init__(self, src, dest, must, when)
																																															      if not self.FS_CASE_SENSITIVE:
																																															      targets = list(OrderedDict((i.lower(), None) for i in targets).keys())
																																															      self.base = targets[0]
																																															      self.aliases = targets[1:]
																																															      self.dest = dest

																																															      def run(self, creator, symlinks):
																																															      bin_dir = self.dest(creator, self.src).parent
																																															      dest = bin_dir / self.base
																																															      method = self.method(symlinks)
																																															      method(self.src, dest)
																																															      if not symlinks:
																																															      make_exe(dest)
																																															      for extra in self.aliases:
																																															      link_file = bin_dir / extra
																																															      if link_file.exists():
																																															      link_file.unlink()
																																															      if symlinks:
																																															      link_file.symlink_to(self.base)
																																															      else
																																															      :
																																															      copy(self.src, link_file)
																																															      if not symlinks:
																																															      make_exe(link_file)

																																															      def __repr__(self)->str:
																																															      return f "{self.__class__.__name__}(src={self.src}, alias={self.aliases})"


																																															      __all__ =[
																																																	"ExePathRef",
																																																	"ExePathRefToDest",
																																																	"PathRef",
																																																	"PathRefToDest",
																																																	"RefMust",
																																																	"RefWhen",
																																																	]
																																															      PK  5L  Zm = ≈N  N  >virtualenv / create / via_global_ref / builtin / via_global_self_do.pyfrom __future__ import annotations

																																															      from abc import ABC

																																															      from virtualenv.create.via_global_ref.api import ViaGlobalRefApi, ViaGlobalRefMeta
																																															      from virtualenv.create.via_global_ref.builtin.ref import(
																																																						       ExePathRefToDest,
																																																						       RefMust,
																																																						       RefWhen,
																																																						       )
																																															      from virtualenv.util.path import ensure_dir

																																															      from.builtin_way import VirtualenvBuiltin


																																															      class BuiltinViaGlobalRefMeta(ViaGlobalRefMeta):
																																															      def __init__(self)->None:
																																															      super().__init__()
																																															      self.sources =[]


																																															      class ViaGlobalRefVirtualenvBuiltin(ViaGlobalRefApi, VirtualenvBuiltin, ABC):
																																															      def __init__(self, options, interpreter)->None:
																																															      super().__init__(options, interpreter)
																																															      self._sources = getattr(options.meta, "sources", None)
#if we're created as a describer this might be missing

																																															      @ classmethod
																																															      def can_create(cls, interpreter):
																																															      "" "By default, all built-in methods assume that if we can describe it we can create it." ""
#first we must be able to describe it
																																															      if not cls.can_describe(interpreter):
																																															      return None
																																															      meta = cls.setup_meta(interpreter)
																																															      if meta is not None and meta:
																																															      cls._sources_can_be_applied(interpreter, meta)
																																															      return meta

																																															      @ classmethod
																																															      def _sources_can_be_applied(cls, interpreter, meta):
																																															      for src in cls.sources(interpreter):
																																															      if src.exists:
																																															      if meta.can_copy and not src.can_copy:
																																															      meta.copy_error = f "cannot copy {src}"
																																															      if meta.can_symlink and not src.can_symlink:
																																															      meta.symlink_error = f "cannot symlink {src}"
																																															      else
																																															      :
																																															      msg = f "missing required file {src}"
																																															      if src.when == RefMust.NA:
																																															      meta.error = msg
																																															      elif src.when == RefMust.COPY:
																																															      meta.copy_error = msg
																																															      elif src.when == RefMust.SYMLINK:
																																															      meta.symlink_error = msg
																																															      if not meta.can_copy and not meta.can_symlink:
																																															      meta.error = f "neither copy or symlink supported, copy: {meta.copy_error} symlink: {meta.symlink_error}"
																																															      if meta.error:
																																															      break
																																															      meta.sources.append(src)

																																															      @ classmethod
																																															      def setup_meta(cls, interpreter):
#noqa: ARG003
																																															      return BuiltinViaGlobalRefMeta()

																																															      @ classmethod
																																															      def sources(cls, interpreter):
																																															      for host_exe, targets, must, when in cls._executables(interpreter):
																																															      yield ExePathRefToDest(host_exe, dest = cls.to_bin, targets = targets, must = must, when = when)

																																															      def to_bin(self, src):
																																															      return self.bin_dir / src.name

																																															      @ classmethod
																																															      def _executables(cls, interpreter):
																																															      raise NotImplementedError

																																															      def create(self):
																																															      dirs = self.ensure_directories()
																																															      for directory in list(dirs):
																																															      if any(i for i in dirs if i is not directory and directory.parts == i.parts[:len(directory.parts)]):
																																															      dirs.remove(directory)
																																															      for directory in sorted(dirs):
																																															      ensure_dir(directory)

																																															      self.set_pyenv_cfg()
																																															      self.pyenv_cfg.write()
																																															      true_system_site = self.enable_system_site_package
																																															      try:
																																															      self.enable_system_site_package = False
																																															      for src in self._sources:
																																															      if (
																																																  src.when == RefWhen.ANY
																																																  or(src.when == RefWhen.SYMLINK and self.symlinks is True)
																																																  or(src.when == RefWhen.COPY and self.symlinks is False)
																																																  ):
																																															      src.run(self, self.symlinks)
																																															      finally:
																																															      if true_system_site != self.enable_system_site_package:
																																															      self.enable_system_site_package = true_system_site
																																															      super().create()

																																															      def ensure_directories(self):
																																															      return {self.dest, self.bin_dir, self.script_dir, self.stdlib} |set(self.libs)

																													def set_pyenv_cfg(self):
																													"" "
																													We directly inject the base prefix and base exec prefix to avoid site.py needing to discover these
																													from home(which usually is done within the interpreter itself).
																													"" "  # noqa: D205
																													super().set_pyenv_cfg()
																													self.pyenv_cfg["base-prefix"] = self.interpreter.system_prefix
																													self.pyenv_cfg["base-exec-prefix"] = self.interpreter.system_exec_prefix
																													self.pyenv_cfg["base-executable"] = self.interpreter.system_executable


																													__all__ =[
																														  "BuiltinViaGlobalRefMeta",
																														  "ViaGlobalRefVirtualenvBuiltin",
																													]
																													PK  5L  Z < virtualenv / create / via_global_ref / builtin / cpython / __init__.pyPK  5L  Z } ˛Î——:virtualenv / create / via_global_ref / builtin / cpython / common.pyfrom __future__ import annotations

																	import re
																	from abc import ABC
																	from collections import OrderedDict
																	from pathlib import Path

																	from virtualenv.create.describe import PosixSupports, WindowsSupports
																			from virtualenv.create.via_global_ref.builtin.ref import RefMust, RefWhen
																			from virtualenv.create.via_global_ref.builtin.via_global_self_do import ViaGlobalRefVirtualenvBuiltin


																			class CPython(ViaGlobalRefVirtualenvBuiltin, ABC):
																		       @classmethod
																			def can_describe(cls, interpreter):
																			return interpreter.implementation == "CPython" and super().can_describe(interpreter)

																	@ classmethod
																	def exe_stem(cls):
																	return "python"


																	class CPythonPosix(CPython, PosixSupports, ABC):
																	"" "Create a CPython virtual environment on POSIX platforms." ""

																	@ classmethod
																	def _executables(cls, interpreter):
																	host_exe = Path(interpreter.system_executable)
																	major,		minor = interpreter.version_info.major, interpreter.version_info.minor
																			targets = OrderedDict((i, None) for i in["python", f "python{major}", f "python{major}.{minor}", host_exe.name])
																		yield host_exe,	list(targets.keys()), RefMust.NA, RefWhen.ANY


																				class CPythonWindows(CPython, WindowsSupports, ABC):
																			       @classmethod
																				def _executables(cls, interpreter):
#symlink of the python executables does not work reliably, copy always instead
#- https://bugs.python.org/issue42013
#- venv
																				host = cls.host_python(interpreter)
																			for path in(host.parent / n for n in {"python.exe", host.name}):
																	yield host,[	path.name], RefMust.COPY, RefWhen.ANY
#for more info on pythonw.exe see https://stackoverflow.com/a/30313091
																			python_w = host.parent / "pythonw.exe"
																	yield python_w,[python_w.name], RefMust.COPY, RefWhen.ANY

																	@		classmethod
																			def host_python(cls, interpreter):
																			return Path(interpreter.system_executable)


																			def is_mac_os_framework(interpreter):
																	if		interpreter.platform == "darwin":
																	return interpreter.sysconfig_vars.get("PYTHONFRAMEWORK")
																		== "Python3"
																		return False


																		def is_macos_brew(interpreter):
																		return interpreter.platform == "darwin" and _BREW.fullmatch(interpreter.system_prefix) is not None


																		_BREW = re.compile(
																				   r "/(usr/local|opt/homebrew)/(opt/python@3\.\d{1,2}|Cellar/python@3\.\d{1,2}/3\.\d{1,2}\.\d{1,2})/Frameworks/"
																				   r "Python\.framework/Versions/3\.\d{1,2}",
																		)

																		__all__ =[
																			  "CPython",
																			  "CPythonPosix",
																			  "CPythonWindows",
																			  "is_mac_os_framework",
																			  "is_macos_brew",
																		]
																		PK  5L  ZT(K œ µµ<virtualenv / create / via_global_ref / builtin / cpython / cpython3.pyfrom __future__ import annotations

																			       import abc
																			       import fnmatch
																			       from itertools import chain
																			       from operator import methodcaller as method
																			       from pathlib import Path
																			       from textwrap import dedent

																			       from virtualenv.create.describe import Python3Supports
																			       from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest
																			       from virtualenv.create.via_global_ref.store import is_store_python

																			       from.common import CPython, CPythonPosix, CPythonWindows, is_mac_os_framework, is_macos_brew


																			       class CPython3(CPython, Python3Supports, abc.ABC):
																			       "" "CPython 3 or later." ""


																			       class CPython3Posix(CPythonPosix, CPython3):
																			       @classmethod
																			       def can_describe(cls, interpreter):
																			       return (
																				       is_mac_os_framework(interpreter) is False
																				       and is_macos_brew(interpreter) is False
																				       and super().can_describe(interpreter)
																				       )

																			       def env_patch_text(self):
																			       text = super().env_patch_text()
																			       if self.pyvenv_launch_patch_active(self.interpreter):
																			       text += dedent(
																					      "" "
#for https://github.com/python/cpython/pull/9516, see https://github.com/pypa/virtualenv/issues/1704
																					      import os
																					      if "__PYVENV_LAUNCHER__" in os.environ:
																					      del os.environ["__PYVENV_LAUNCHER__"]
																					      "" ",
																					      )
																			       return text

																			       @ classmethod
																			       def pyvenv_launch_patch_active(cls, interpreter):
																			       ver = interpreter.version_info
																			       return interpreter.platform == "darwin" and((3, 7, 8) > ver >= (3, 7) or(3, 8, 3) > ver >= (3, 8))


																			       class CPython3Windows(CPythonWindows, CPython3):
																			       "" "CPython 3 on Windows." ""

																			       @ classmethod
																			       def setup_meta(cls, interpreter):
																			       if is_store_python(interpreter):
#store python is not supported here
																			       return None
																			       return super().setup_meta(interpreter)

																			       @ classmethod
																			       def sources(cls, interpreter):
																			       if cls.has_shim(interpreter):
																			       refs = cls.executables(interpreter)
																			       else
																			       :
																			       refs = chain(
																					    cls.executables(interpreter),
																					    cls.dll_and_pyd(interpreter),
																					    cls.python_zip(interpreter),
																					    )
																			       yield from refs

																			       @ classmethod
																			       def executables(cls, interpreter):
																			       return super().sources(interpreter)

																			       @ classmethod
																			       def has_shim(cls, interpreter):
																			       return interpreter.version_info.minor >= 7 and cls.shim(interpreter) is not None
#noqa: PLR2004

																			       @ classmethod
																			       def shim(cls, interpreter):
																			       shim = Path(interpreter.system_stdlib) / "venv" / "scripts" / "nt" / "python.exe"
																			       if shim.exists():
																			       return shim
																			       return None

																			       @ classmethod
																			       def host_python(cls, interpreter):
																			       if cls.has_shim(interpreter):
#starting with CPython 3.7 Windows ships with a venvlauncher.exe that avoids the need for dll/pyd copies
#it also means the wrapper must be copied to avoid bugs such as https://bugs.python.org/issue42013
																			       return cls.shim(interpreter)
																			       return super().host_python(interpreter)

																			       @ classmethod
																			       def dll_and_pyd(cls, interpreter):
																			       folders =[Path(interpreter.system_executable).parent]

#May be missing on some Python hosts.
#See https://github.com/pypa/virtualenv/issues/2368
																			       dll_folder = Path(interpreter.system_prefix) / "DLLs"
																			       if dll_folder.is_dir():
																			       folders.append(dll_folder)

																			       for folder in folders:
																			       for file in folder.iterdir():
																			       if file.suffix in {".pyd", ".dll"}:
																	yield PathRefToDest(file, cls.to_bin)

																	@ classmethod
																	def python_zip(cls, interpreter):
																	"" "
																	"python{VERSION}.zip" contains compiled *.pyc std lib packages, where
																			"VERSION" is ` py_version_nodot ` var from the ` sysconfig ` module.
																	:		see:https://docs.python.org / 3 / using / windows.html
#the-embeddable-package
																	:		see:`discovery.py_info.PythonInfo ` class(interpreter).
																	:		see:`python - m sysconfig ` output.

																	:		note:The embeddable Python distribution for Windows includes
																			"python{VERSION}.zip" and "python{VERSION}._pth" files.User can
																			move / rename * zip * file and edit ` sys.path ` by editing * _pth * file.
																			Here the ` pattern ` is used only for the default *zip * file name !
																			"" "  # noqa: D205
																			pattern = f "*python{interpreter.version_nodot}.zip"
																	matches = fnmatch.filter(interpreter.path, pattern)
																		matched_paths = map(Path, matches)
																		existing_paths = filter(method("exists"), matched_paths)
																		path = next(existing_paths, None)
																		if path is not None:
																		yield PathRefToDest(path, cls.to_bin)


																			__all__ =[
																				  "CPython3",
																				  "CPython3Posix",
																				  "CPython3Windows",
																			]
																			PK  5L  ZfM ‚ “ï-ï-:virtualenv / create / via_global_ref / builtin / cpython / mac_os.py "" "The Apple Framework builds require their own customization." ""

																			from __future__ import annotations

																			import logging
																			import os
																			import struct
																			import subprocess
																			from abc import ABC,
																					abstractmethod
																					from pathlib import Path
																					from textwrap import dedent

																					from virtualenv.create.via_global_ref.builtin.ref import(
																												 ExePathRefToDest,
																												 PathRefToDest,
																												 RefMust,
																			)
																					from virtualenv.create.via_global_ref.builtin.via_global_self_do import BuiltinViaGlobalRefMeta

																					from.common import CPython,
																					CPythonPosix,
																					is_mac_os_framework,
																					is_macos_brew
																					from.cpython3 import CPython3

																					LOGGER = logging.getLogger(__name__)


																			class CPythonmacOsFramework(CPython, ABC):
																			@classmethod
																			def can_describe(cls, interpreter):
																			return is_mac_os_framework(interpreter) and super().can_describe(interpreter)

																			def create(self):
																			super().create()

#change the install_name of the copied python executables
																			target = self.desired_mach_o_image_path()
																			current = self.current_mach_o_image_path()
																			for src in self._sources:
																			if isinstance(src, ExePathRefToDest)
																				and(src.must == RefMust.COPY or not self.symlinks):
																				exes =[self.bin_dir / src.base]
																				if not self.symlinks:
																				exes.extend(self.bin_dir / a for a in src.aliases)
																					for exe in exes:
																					fix_mach_o(str(exe), current, target, self.interpreter.max_size)

																						@classmethod
																						def _executables(cls, interpreter):
																						for _,
																								targets,
																								must,
																								when in super()
																							.		_executables(interpreter):
#Make sure we use the embedded interpreter inside the framework, even if sys.executable points to the
#stub executable in ${sys.prefix}/bin.
#See http://groups.google.com/group/python-virtualenv/browse_thread/thread/17cab2f85da75951
																									fixed_host_exe = Path(interpreter.prefix) / "Resources" / "Python.app" / "Contents" / "MacOS" / "Python"
																							yield fixed_host_exe,
																									targets,
																									must,
																									when

																							@		abstractmethod
																									def current_mach_o_image_path(self):
																									raise NotImplementedError

																							@		abstractmethod
																									def desired_mach_o_image_path(self):
																									raise NotImplementedError


																									class CPython3macOsFramework(CPythonmacOsFramework, CPython3, CPythonPosix):
																									def current_mach_o_image_path(self):
																									return "@executable_path/../../../../Python3"

																									def desired_mach_o_image_path(self):
																									return "@executable_path/../.Python"

																							@		classmethod
																									def sources(cls, interpreter):
																									yield from super().sources(interpreter)

#add a symlink to the host python image
																									exe = Path(interpreter.prefix) / "Python3"
																							yield PathRefToDest(exe, dest = lambda self, _:self.dest / ".Python", must = RefMust.SYMLINK)

																							@ property
																							def reload_code(self):
																							result = super().reload_code
																							return dedent(
																								      f "" "
#the bundled site.py always adds the global site package if we're on python framework build, escape this
																								      import sys
																								      before = sys._framework
																								      try:
																								      sys._framework = None
																								      {result}
																	finally:
																	sys._framework = before
																	"" ",
																	)


																	def fix_mach_o(exe, current, new, max_size):
																	"" "
																	https://en.wikipedia.org / wiki / Mach - O.

																	Mach - O, short for Mach object file format,
																			is a file format for executables,
																			object code,
																			shared libraries, dynamically - loaded code,
																			and core dumps.A replacement for the a.out format,
																			Mach - O offers more extensibility and
																			faster access to information in the symbol table.

																			Each Mach - O file is made up of one Mach - O header,
																			followed by a series of load commands,
																			followed by one or more
																			segments,
																			each of which contains between 0 and 255 sections.Mach - O uses the REL relocation format to handle
																			references to symbols.When looking up symbols Mach - O uses a two - level namespace that encodes each symbol into an
																			'object/symbol name' pair that is then linearly searched for by first the object and then the symbol name.

																			The basic structure ‚ 959îa list of variable - length "load commands" that reference pages of data elsewhere in the file ‚ 959îwas
																			also used in the executable file format for Accent.The Accent file format was in turn,
																			based on an idea from Spice
																			Lisp.

																			With the introduction of Mac OS X 10.6 platform the Mach - O file underwent a significant modification that causes
																			binaries compiled on a computer running 10.6 or later to be(by default)
																				executable only on computers running Mac
																				OS X 10.6 or later.The difference stems from load commands that the dynamic linker,
																				in previous Mac OS X versions, does not understand.Another significant change to the Mach - O format is the change in how the Link Edit tables
																				(found in the __LINKEDIT section) function.In 10.6 these new Link Edit tables are compressed by removing unused and
																				unneeded bits of information,
																				however Mac OS X 10.5 and earlier cannot read this new Link Edit table format.
																				"" "
																				try:
																				LOGGER.debug("change Mach-O for %s from %s to %s", exe, current, new)
																				_builtin_change_mach_o(max_size) (exe, current, new)
																				except Exception as e:
#noqa: BLE001
																				LOGGER.warning("Could not call _builtin_change_mac_o: %s. Trying to call install_name_tool instead.", e)
																				try:
																				cmd =["install_name_tool", "-change", current, new, exe]
																		subprocess.check_call(cmd)
																		except Exception:
																		logging.fatal("Could not call install_name_tool -- you must have Apple's development tools installed")
																		raise


																		def _builtin_change_mach_o(maxint):
#noqa: C901
																		MH_MAGIC = 0xFEEDFACE
#noqa: N806
																		MH_CIGAM = 0xCEFAEDFE
#noqa: N806
																		MH_MAGIC_64 = 0xFEEDFACF
#noqa: N806
																		MH_CIGAM_64 = 0xCFFAEDFE
#noqa: N806
																		FAT_MAGIC = 0xCAFEBABE
#noqa: N806
																		BIG_ENDIAN = ">"
#noqa: N806
																		LITTLE_ENDIAN = "<"
#noqa: N806
																		LC_LOAD_DYLIB = 0xC
#noqa: N806

																		class FileView:
																		"" "A proxy for file-like objects that exposes a given view of a file. Modified from macholib." ""

																		def __init__(self, file_obj, start = 0, size = maxint)->None:
																		if isinstance(file_obj, FileView)
																			:
																			self._file_obj = file_obj._file_obj
#noqa: SLF001
																			else
																			:
																			self._file_obj = file_obj
																			self._start = start
																			self._end = start + size
																			self._pos = 0

																			def __repr__(self)->str:
																			return f "<fileview [{self._start:d}, {self._end:d}] {self._file_obj!r}>"

																			def tell(self):
																			return self._pos

																			def _checkwindow(self, seek_to, op):
																			if not(self._start <= seek_to <= self._end)
																				:
																				msg = f "{op} to offset {seek_to:d} is outside window [{self._start:d}, {self._end:d}]"
																				raise OSError(msg)

																				def seek(self, offset, whence = 0):
																				seek_to = offset
																				if whence == os.SEEK_SET:
																				seek_to += self._start
																				elif whence == os.SEEK_CUR:
																				seek_to += self._start + self._pos
																				elif whence == os.SEEK_END:
																				seek_to += self._end
																				else
																				:
																				msg = f "Invalid whence argument to seek: {whence!r}"
																				raise OSError(msg)
																					self._checkwindow(seek_to, "seek")
																					self._file_obj.seek(seek_to)
																					self._pos = seek_to - self._start

																					def write(self, content):
																					here = self._start + self._pos
																					self._checkwindow(here, "write")
																					self._checkwindow(here + len(content), "write")
																					self._file_obj.seek(here, os.SEEK_SET)
																					self._file_obj.write(content)
																					self._pos += len(content)

																					def read(self, size = maxint):
																					assert size >= 0
#noqa: S101
																					here = self._start + self._pos
																					self._checkwindow(here, "read")
																					size = min(size, self._end - here)
																					self._file_obj.seek(here, os.SEEK_SET)
																					read_bytes = self._file_obj.read(size)
																					self._pos += len(read_bytes)
																					return read_bytes

																					def read_data(file, endian, num = 1):
																					"" "Read a given number of 32-bits unsigned integers from the given file with the given endianness." ""
																					res = struct.unpack(endian + "L" * num, file.read(num * 4))
																					if len(res)
																						== 1:
																						return res[0]
																						return res

																						def mach_o_change(at_path, what, value):
#noqa: C901
																						"" "
																						Replace a given name(what) in any LC_LOAD_DYLIB command found in the given binary with a new name(value), provided it 's shorter.
																								"" "  # noqa: D205

																								def do_macho(file, bits, endian):
#Read Mach-O header (the magic number is assumed read by the caller)
																								_cpu_type,
																								_cpu_sub_type,
																								_file_type,
																								n_commands,
																								_size_of_commands,
																								_flags = read_data(file, endian, 6)
#64-bits header has one more field.
																						if bits == 64:
#noqa: PLR2004
																						read_data(file, endian)
#The header is followed by n commands
																							for _ in range(n_commands)
																								:
																								where = file.tell()
#Read command header
																								cmd,
																										cmd_size = read_data(file, endian, 2)
																								if cmd == LC_LOAD_DYLIB:
#The first data field in LC_LOAD_DYLIB commands is the offset of the name, starting from the
#beginning of the  command.
																								name_offset = read_data(file, endian)
																									file.seek(where + name_offset, os.SEEK_SET)
#Read the NUL terminated string
																									load = file.read(cmd_size - name_offset).decode()
																									load = load[:load.index("\0")]
#If the string is what is being replaced, overwrite it.
																									if load == what:
																									file.seek(where + name_offset, os.SEEK_SET)
																										file.write(value.encode() + b "\0")
#Seek to the next command
																										file.seek(where + cmd_size, os.SEEK_SET)

																										def do_file(file, offset = 0, size = maxint):
																										file = FileView(file, offset, size)
#Read magic number
																										magic = read_data(file, BIG_ENDIAN)
																										if magic == FAT_MAGIC:
#Fat binaries contain nfat_arch Mach-O binaries
																										n_fat_arch = read_data(file, BIG_ENDIAN)
																											for _ in range(n_fat_arch)
																												:
#Read arch header
																												_cpu_type,
																														_cpu_sub_type,
																														offset,
																														size,
																														_align = read_data(file, BIG_ENDIAN, 5)
																												do_file(file, offset, size)
																												elif magic == MH_MAGIC:
																												do_macho(file, 32, BIG_ENDIAN)
																												elif magic == MH_CIGAM:
																												do_macho(file, 32, LITTLE_ENDIAN)
																												elif magic == MH_MAGIC_64:
																												do_macho(file, 64, BIG_ENDIAN)
																												elif magic == MH_CIGAM_64:
																												do_macho(file, 64, LITTLE_ENDIAN)

																												assert len(what) >= len(value)
#noqa: S101

																												with open(at_path, "r+b") as f:
																												do_file(f)

																												return mach_o_change


																												class CPython3macOsBrew(CPython3, CPythonPosix):
																												@classmethod
																												def can_describe(cls, interpreter):
																												return is_macos_brew(interpreter) and super().can_describe(interpreter)

																												@ classmethod
																												def setup_meta(cls, interpreter):
#noqa: ARG003
																												meta = BuiltinViaGlobalRefMeta()
																												meta.copy_error = "Brew disables copy creation: https://github.com/Homebrew/homebrew-core/issues/138159"
																												return meta


																												__all__ =[
																													  "CPython3macOsBrew",
																													  "CPython3macOsFramework",
																													  "CPythonmacOsFramework",
																												]
																												PK  5L  Z  q ò ª™™<virtualenv / create / via_global_ref / builtin / graalpy / __init__.pyfrom __future__ import annotations

																												from abc import ABC
																												from pathlib import Path

																												from virtualenv.create.describe import PosixSupports,
																														WindowsSupports
																														from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest,
																														RefMust,
																														RefWhen
																														from virtualenv.create.via_global_ref.builtin.via_global_self_do import ViaGlobalRefVirtualenvBuiltin


																														class GraalPy(ViaGlobalRefVirtualenvBuiltin, ABC):
																													       @classmethod
																														def can_describe(cls, interpreter):
																														return interpreter.implementation == "GraalVM" and super().can_describe(interpreter)

																												@ classmethod
																												def exe_stem(cls):
																												return "graalpy"

																												@ classmethod
																												def exe_names(cls, interpreter):
																												return {
																												cls.exe_stem(),
																												"python",
																												f "python{interpreter.version_info.major}",
																												f "python{interpreter.version_info.major}.{interpreter.version_info.minor}",
																												}

																	@classmethod
																	def _executables(cls, interpreter):
																	host = Path(interpreter.system_executable)
																	targets = sorted(f "{name}{cls.suffix}" for name in cls.exe_names(interpreter))
																		yield host,	targets, RefMust.NA, RefWhen.ANY

																		@		classmethod
																				def sources(cls, interpreter):
																				yield from super().sources(interpreter)
																				python_dir = Path(interpreter.system_executable).resolve().parent
																		if python_dir.name in {"bin", "Scripts"}:
																	python_dir = python_dir.parent

																	native_lib = cls._native_lib(python_dir / "lib", interpreter.platform)
																		if native_lib.exists()
																			:
																			yield PathRefToDest(native_lib, dest = lambda self, s:self.bin_dir.parent / "lib" / s.name)

																			for jvm_dir_name in("jvm", "jvmlibs", "modules")
																				:
																				jvm_dir = python_dir / jvm_dir_name
																				if jvm_dir.exists()
																					:
																					yield PathRefToDest(jvm_dir, dest = lambda self, s:self.bin_dir.parent / s.name)

																					@ classmethod
																					def _shared_libs(cls, python_dir):
																					raise NotImplementedError

																					def set_pyenv_cfg(self):
																					super().set_pyenv_cfg()
#GraalPy 24.0 and older had home without the bin
																					version = self.interpreter.version_info
																					if version.major == 3 and version.minor <= 10:
#noqa: PLR2004
																					home = Path(self.pyenv_cfg["home"])
																						if home.name == "bin":
																						self.pyenv_cfg["home"]
																							= str(home.parent)


																							class GraalPyPosix(GraalPy, PosixSupports):
																							@classmethod
																							def _native_lib(cls, lib_dir, platform):
																							if platform == "darwin":
																							return lib_dir / "libpythonvm.dylib"
																							return lib_dir / "libpythonvm.so"


																							class GraalPyWindows(GraalPy, WindowsSupports)
																								:
																								@classmethod
																								def _native_lib(cls, lib_dir, _platform):
																								return lib_dir / "pythonvm.dll"

																								def set_pyenv_cfg(self):
#GraalPy needs an additional entry in pyvenv.cfg on Windows
																								super().set_pyenv_cfg()
																								self.pyenv_cfg["venvlauncher_command"] = self.interpreter.system_executable


																								__all__ =[
																									  "GraalPyPosix",
																									  "GraalPyWindows",
																								]
																								PK  5L  Z9virtualenv / create / via_global_ref / builtin / pypy / __init__.pyPK  5L  Zc ¡ è¥¥7 virtualenv / create / via_global_ref / builtin / pypy / common.pyfrom __future__ import annotations

																								import abc
																								from pathlib import Path

																								from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest, RefMust, RefWhen
																										from virtualenv.create.via_global_ref.builtin.via_global_self_do import ViaGlobalRefVirtualenvBuiltin


																										class PyPy(ViaGlobalRefVirtualenvBuiltin, abc.ABC):
																									       @classmethod
																										def can_describe(cls, interpreter):
																										return interpreter.implementation == "PyPy" and super().can_describe(interpreter)

																								@ classmethod
																								def _executables(cls, interpreter):
																								host = Path(interpreter.system_executable)
																								targets = sorted(f "{name}{PyPy.suffix}" for name in cls.exe_names(interpreter))
																									yield host,	targets, RefMust.NA, RefWhen.ANY

																									@		classmethod
																											def executables(cls, interpreter):
																											yield from super().sources(interpreter)

																									@		classmethod
																											def exe_names(cls, interpreter):
																											return {
																									cls.exe_stem(),
																									"python",
																									f "python{interpreter.version_info.major}",
																									f "python{interpreter.version_info.major}.{interpreter.version_info.minor}",
																									}

																		       @classmethod
																			def sources(cls, interpreter):
																			yield from cls.executables(interpreter)
																	for		host in cls._add_shared_libs(interpreter)
																		:
																				yield PathRefToDest(host, dest = lambda self, s:self.bin_dir / s.name)

																		@ classmethod
																		def _add_shared_libs(cls, interpreter):
#https://bitbucket.org/pypy/pypy/issue/1922/future-proofing-virtualenv
																		python_dir = Path(interpreter.system_executable).resolve().parent
																		yield from cls._shared_libs(python_dir)

																		@ classmethod
																		def _shared_libs(cls, python_dir):
																		raise NotImplementedError


																		__all__ =[
																			  "PyPy",
																		]
																		PK  5L  Zsz Ê P æ æ6 virtualenv / create / via_global_ref / builtin / pypy / pypy3.pyfrom __future__ import annotations

																		import abc
																		from pathlib import Path

																		from virtualenv.create.describe import PosixSupports, Python3Supports, WindowsSupports
																				from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest

																				from.common import PyPy


																				class PyPy3(PyPy, Python3Supports, abc.ABC):
																			       @classmethod
																				def exe_stem(cls):
																				return "pypy3"

																		@		classmethod
																				def exe_names(cls, interpreter):
																				return super().exe_names(interpreter) | {
																		"pypy"
																		}


																	class		PyPy3Posix(PyPy3, PosixSupports):
																			"" "PyPy 3 on POSIX." ""

																	@		classmethod
																			def _shared_libs(cls, python_dir):
#glob for libpypy3-c.so, libpypy3-c.dylib, libpypy3.9-c.so ...
																			return python_dir.glob("libpypy3*.*")

																			def to_lib(self, src):
																			return self.dest / "lib" / src.name

																	@		classmethod
																			def sources(cls, interpreter):
																			yield from super().sources(interpreter)
#PyPy >= 3.8 supports a standard prefix installation, where older
#versions always used a portable/development style installation.
#If this is a standard prefix installation, skip the below:
																	if		interpreter.system_prefix == "/usr":
																	return
#Also copy/symlink anything under prefix/lib, which, for "portable"
#PyPy builds, includes the tk,tcl runtime and a number of shared
#objects. In distro-specific builds or on conda this should be empty
#(on PyPy3.8+ it will, like on CPython, hold the stdlib).
																	host_lib = Path(interpreter.system_prefix)
																		/"lib"
																		stdlib = Path(interpreter.system_stdlib)
																		if host_lib.exists()
																			and host_lib.is_dir():
																			for path in host_lib.iterdir()
																				:
																				if stdlib == path:
#For PyPy3.8+ the stdlib lives in lib/pypy3.8
#We need to avoid creating a symlink to it since that
#will defeat the purpose of a virtualenv
																				continue
																				yield PathRefToDest(path, dest = cls.to_lib)


																					class Pypy3Windows(PyPy3, WindowsSupports):
																					"" "PyPy 3 on Windows." ""

																					@ property
																					def less_v37(self):
																					return self.interpreter.version_info.minor < 7
#noqa: PLR2004

																					@ classmethod
																					def _shared_libs(cls, python_dir):
#glob for libpypy*.dll and libffi*.dll
																					for pattern in["libpypy*.dll", "libffi*.dll"]
																						:
																						srcs = python_dir.glob(pattern)
																						yield from srcs


																						__all__ =[
																							  "PyPy3",
																							  "PyPy3Posix",
																							  "Pypy3Windows",
																						]
																						PK  5L  Z virtualenv / discovery / __init__.pyPK  5L  ZW í L  virtualenv / discovery / builtin.pyfrom __future__ import annotations

																						import logging
																						import os
																						import sys
																						from contextlib import suppress
																						from pathlib import Path
																						from typing import TYPE_CHECKING

																						from virtualenv.info import IS_WIN,
																								fs_path_id

																								from.discover import Discover
																								from.py_info import PythonInfo
																								from.py_spec import PythonSpec

																						if		TYPE_CHECKING:
																								from argparse import ArgumentParser
																								from collections.abc import Callable,
																								Generator,
																								Iterable,
																								Mapping,
																								Sequence

																								from virtualenv.app_data.base import AppData
																								LOGGER = logging.getLogger(__name__)


																							class Builtin(Discover):
																							python_spec:Sequence[str]
																							app_data:AppData
																							try_first_with:Sequence[str]

																							def __init__(self, options)->None:
																							super().__init__(options)
																							self.python_spec = options.python or[sys.executable]
																							if self._env.get("VIRTUALENV_PYTHON")
																								:
																								self.python_spec = self.python_spec[1:] + self.python_spec[:1]
#Rotate the list
																								self.app_data = options.app_data
																								self.try_first_with = options.try_first_with

																								@ classmethod
																								def add_parser_arguments(cls, parser:ArgumentParser)->None:
																								parser.add_argument(
																										    "-p",
																										    "--python",
																										    dest = "python",
																										    metavar = "py",
																										    type = str,
																										    action = "append",
																										    default =[],
																										    help = "interpreter based on what to create environment (path/identifier) "
																										    "- by default use the interpreter where the tool is installed - first found wins",
																								)
																								parser.add_argument(
																										    "--try-first-with",
																										    dest = "try_first_with",
																										    metavar = "py_exe",
																										    type = str,
																										    action = "append",
																										    default =[],
																										    help = "try first these interpreters before starting the discovery",
																								)

																								def run(self)->PythonInfo | None:
																								for python_spec in self.python_spec:
																								result = get_interpreter(python_spec, self.try_first_with, self.app_data, self._env)
																									if result is not None:
																									return result
																									return None

																									def __repr__(self)
																										->str:
																										spec = self.python_spec[0] if len(self.python_spec)
																											== 1
																											else
																											self.python_spec
																											return f "{self.__class__.__name__} discover of python_spec={spec!r}"


																											def get_interpreter(
																													    key, try_first_with:Iterable[str], app_data:AppData | None = None, env:Mapping[str, str] | None = None
																											)->PythonInfo | None:
																											spec = PythonSpec.from_string_spec(key)
																											LOGGER.info("find interpreter for spec %r", spec)
																											proposed_paths = set()
																											env = os.environ if env is None
																											else
																											env
																											for interpreter,
																													impl_must_match in propose_interpreters(spec, try_first_with, app_data, env)
																												:
																														key = interpreter.system_executable,
																														impl_must_match
																												if		key in proposed_paths:
																														continue
																														LOGGER.info("proposed %s", interpreter)
																													if		interpreter.satisfies(spec, impl_must_match)
																														:
																																LOGGER.debug("accepted %s", interpreter)
																																return interpreter
																																proposed_paths.add(key)
																																return None


																																def propose_interpreters(
#noqa: C901, PLR0912, PLR0915
																																			 spec:PythonSpec,
																																			 try_first_with:Iterable[str],
																																			 app_data:AppData | None = None,
																																			 env:Mapping[str, str] | None = None,
																														)->Generator[tuple[PythonInfo, bool], None, None]:
#0. try with first
																														env = os.environ if env is None
																														else
																														env
																														tested_exes:set[str]
																															= set()
																															for py_exe in try_first_with:
																															path = os.path.abspath(py_exe)
																																try:
																																os.lstat(path)
#Windows Store Python does not work with os.path.exists, but does for os.lstat
																																except OSError:
																																pass
																																else
																																:
																																exe_raw = os.path.abspath(path)
																																exe_id = fs_path_id(exe_raw)
																																if exe_id in tested_exes:
																																continue
																																tested_exes.add(exe_id)
																																	yield PythonInfo.from_exe(exe_raw, app_data, env = env),
																																			True

#1. if it's a path and exists
																																	if		spec.path is not None:
																																			try:
																																			os.lstat(spec.path)
#Windows Store Python does not work with os.path.exists, but does for os.lstat
																																				except OSError:
																																		if		spec.is_abs:
																																				raise
																																		else
																																		:
																																				exe_raw = os.path.abspath(spec.path)
																																			exe_id = fs_path_id(exe_raw)
																																			if exe_id not in tested_exes:
																																			tested_exes.add(exe_id)
																																				yield PythonInfo.from_exe(exe_raw, app_data, env = env),
																																						True
																																				if		spec.is_abs:
																																						return
																																				else
																																				:
#2. otherwise try with the current
																																						current_python = PythonInfo.current_system(app_data)
																																					exe_raw = str(current_python.executable)
																																					exe_id = fs_path_id(exe_raw)
																																					if exe_id not in tested_exes:
																																					tested_exes.add(exe_id)
																																						yield current_python,
																																								True

#3. otherwise fallback to platform default logic
																																						if		IS_WIN:
																																								from.windows import propose_interpreters
#noqa: PLC0415

																																						for		interpreter in propose_interpreters(spec, app_data, env)
																																							:
																																									exe_raw = str(interpreter.executable)
																																							exe_id = fs_path_id(exe_raw)
																																							if exe_id in tested_exes:
																																							continue
																																							tested_exes.add(exe_id)
																																								yield interpreter,
																																										True
#finally just find on path, the path order matters (as the candidates are less easy to control by end user)
																																										find_candidates = path_exe_finder(spec)
																																								for pos,
																																										path in enumerate(get_paths(env))
																																									:
																																											LOGGER.debug(LazyPathDump(pos, path, env))
																																									for		exe,
																																											impl_must_match in find_candidates(path)
																																										:
																																												exe_raw = str(exe)
																																										exe_id = fs_path_id(exe_raw)
																																										if exe_id in tested_exes:
																																										continue
																																										tested_exes.add(exe_id)
																																											interpreter = PathPythonInfo.from_exe(exe_raw, app_data, raise_on_error = False, env = env)
																																											if interpreter is not None:
																																											yield interpreter,
																																													impl_must_match


																																													def get_paths(env:Mapping[str, str])
																																													      ->Generator[Path, None, None]:
																																														path = env.get("PATH", None)
																																												if path is None:
																																												try:
																																												path = os.confstr("CS_PATH")
																																													except(AttributeError, ValueError):
																																													path = os.defpath
																																													if path:
																																													for p in map(Path, path.split(os.pathsep))
																																														:
																																														with suppress(OSError):
																																														if next(p.iterdir(), None)
																																															:
																																															yield p


																																															class LazyPathDump:
																																															def __init__(self, pos:int, path:Path, env:Mapping[str, str])->None:
																																															self.pos = pos
																																															self.path = path
																																															self.env = env

																																															def __repr__(self)->str:
																																															content = f "discover PATH[{self.pos}]={self.path}"
																																															if self.env.get("_VIRTUALENV_DEBUG")
																																																:
#this is the over the board debug
																																																content += " with =>"
																																																for file_path in self.path.iterdir()
																																																	:
																																																	try:
																																																	if file_path.is_dir()
																																																		or not(file_path.stat().st_mode & os.X_OK):
																																																		continue
																																																		except OSError:
																																																		pass
																																																		content += " "
																																																		content += file_path.name
																																																		return content


																																																		def path_exe_finder(spec:PythonSpec)->Callable[[Path], Generator[tuple[Path, bool], None, None]]:
																																																		"" "Given a spec, return a function that can be called on a path to find all matching files in it." ""
																																																		pat = spec.generate_re(windows = sys.platform == "win32")
																																																		direct = spec.str_spec
																																																		if sys.platform == "win32":
																																																		direct = f "{direct}.exe"

																																																		def path_exes(path:Path)
																																																			->Generator[tuple[Path, bool], None, None]:
#4. then maybe it's something exact on PATH - if it was direct lookup implementation no longer counts
																																																			direct_path = path / direct
																																																			if direct_path.exists()
																																																				:
																																																				yield direct_path,
																																																						False

#5. or from the spec we can deduce if a name on path matches
																																																				for		exe in path.iterdir()
																																																					:
																																																							match = pat.fullmatch(exe.name)
																																																					if match:
#the implementation must match when we find ‚Äúpython[ver]‚Äù
																																																					yield exe.absolute()
																																																						,
																																																								match["impl"] == "python"

																																																						return path_exes


																																																						class PathPythonInfo(PythonInfo):
																																																						"" "python info from path." ""


																																																						__all__ =[
																																																							  "Builtin",
																																																							  "PathPythonInfo",
																																																							  "get_interpreter",
																																																						]
																																																						PK  5L  Z — t ˘ ±‘‘&virtualenv / discovery / cached_py_info.py "" "

																																																						We acquire the python information by running an interrogation script via subprocess trigger.This operation is not
																																																						cheap,
																																																								especially not on Windows.To not have to pay this hefty cost every time we apply multiple levels of
																																																								caching.
																																																								"" "  # noqa: D205

																																																								from __future__ import annotations

																																																								import logging
																																																								import os
																																																								import random
																																																								import sys
																																																								from collections import OrderedDict
																																																								from pathlib import Path
																																																								from shlex import quote
																																																								from string import ascii_lowercase,
																																																								ascii_uppercase,
																																																								digits
																																																								from subprocess import Popen

																																																								from virtualenv.app_data import AppDataDisabled
																																																								from virtualenv.discovery.py_info import PythonInfo
																																																								from virtualenv.util.subprocess import subprocess

																																																								_CACHE = OrderedDict()
																																																						_CACHE[Path(sys.executable)] = PythonInfo()
																																																						LOGGER = logging.getLogger(__name__)


																																																						def from_exe(cls, app_data, exe, env = None, raise_on_error = True, ignore_cache = False):
#noqa: FBT002, PLR0913
																																																						env = os.environ if env is None
																																																						else
																																																						env
																																																						result = _get_from_cache(cls, app_data, exe, env, ignore_cache = ignore_cache)
																																																							if isinstance(result, Exception)
																																																								:
																																																								if raise_on_error:
																																																								raise result
																																																								LOGGER.info("%s", result)
																																																									result = None
																																																									return result


																																																									def _get_from_cache(cls, app_data, exe, env, ignore_cache = True):
#noqa: FBT002
#note here we cannot resolve symlinks, as the symlink may trigger different prefix information if there's a
#pyenv.cfg somewhere alongside on python3.5+
																																																									exe_path = Path(exe)
																																																									if not ignore_cache and exe_path in _CACHE:
#check in the in-memory cache
																																																									result = _CACHE[exe_path]
																																																										else
																																																										:
#otherwise go through the app data cache
																																																										py_info = _get_via_file_cache(cls, app_data, exe_path, exe, env)
																																																										result = _CACHE[exe_path] = py_info
#independent if it was from the file or in-memory cache fix the original executable location
																																																										if isinstance(result, PythonInfo)
																																																											:
																																																											result.executable = exe
																																																											return result


																																																											def _get_via_file_cache(cls, app_data, path, exe, env):
																																																											path_text = str(path)
																																																											try:
																																																											path_modified = path.stat().st_mtime
																																																											except OSError:
																																																											path_modified = -1
																																																											if app_data is None:
																																																											app_data = AppDataDisabled()
																																																												py_info,
																																																														py_info_store = None,
																																																														app_data.py_info(path)
																																																														with py_info_store.locked():
																																																												if		py_info_store.exists()
																																																													:
#if exists and matches load
																																																															data = py_info_store.read()
																																																													of_path,
																																																															of_st_mtime,
																																																															of_content = data["path"],
																																																															data["st_mtime"],
																																																															data["content"]
																																																													if		of_path == path_text and of_st_mtime == path_modified:
																																																													py_info = cls._from_dict(of_content.copy())
																																																														sys_exe = py_info.system_executable
																																																														if sys_exe is not None and not os.path.exists(sys_exe)
																																																															:
																																																															py_info_store.remove()
																																																															py_info = None
																																																															else
																																																															:
																																																															py_info_store.remove()
																																																															if py_info is None:
#if not loaded run and save
																																																															failure,
																																																																	py_info = _run_subprocess(cls, exe, app_data, env)
																																																																if failure is None:
																																																																data = {
																																																																"st_mtime":path_modified,
																																																																"path":path_text,
																																																																"content":py_info._to_dict()
																																																																	,
#noqa: SLF001
																																																																	}
																																																																	py_info_store.write(data)
																																																																	else
																																																																	:
																																																																	py_info = failure
																																																																	return py_info


																																																																	COOKIE_LENGTH:int = 32


																																																																	def gen_cookie():
																																																																	return "".join(
																																																																		       random.choice(f "{ascii_lowercase}{ascii_uppercase}{digits}")
#noqa: S311
																																																																		       for _ in range(COOKIE_LENGTH)
																																																																	)


																																																																		def _run_subprocess(cls, exe, app_data, env):
																																																																		py_info_script = Path(os.path.abspath(__file__)).parent / "py_info.py"
#Cookies allow to split the serialized stdout output generated by the script collecting the info from the output
#generated by something else. The right way to deal with it is to create an anonymous pipe and pass its descriptor
#to the child and output to it. But AFAIK all of them are either not cross-platform or too big to implement and are
#not in the stdlib. So the easiest and the shortest way I could mind is just using the cookies.
#We generate pseudorandom cookies because it easy to implement and avoids breakage from outputting modules source
#code, i.e. by debug output libraries. We reverse the cookies to avoid breakages resulting from variable values
#appearing in debug output.

																																																																		start_cookie = gen_cookie()
																																																																		end_cookie = gen_cookie()
																																																																		with app_data.ensure_extracted(py_info_script) as py_info_script:
																																																																		cmd =[exe, str(py_info_script), start_cookie, end_cookie]
#prevent sys.prefix from leaking into the child process - see https://bugs.python.org/issue22490
																																																																		env = env.copy()
																																																																		env.pop("__PYVENV_LAUNCHER__", None)
																																																																		LOGGER.debug("get interpreter info via cmd: %s", LogCmd(cmd))
																																																																		try:
																																																																		process = Popen(
																																																																				cmd,
																																																																				universal_newlines = True,
																																																																				stdin = subprocess.PIPE,
																																																																				stderr = subprocess.PIPE,
																																																																				stdout = subprocess.PIPE,
																																																																				env = env,
																																																																				encoding = "utf-8",
																																																																		)
																																																																		out,
																																																																				err = process.communicate()
																																																																		code = process.returncode
																																																																		except OSError as os_error:
																																																																		out,
																																																																				err,
																																																																				code = "",
																																																																				os_error.strerror,
																																																																				os_error.errno
																																																																				result,
																																																																				failure = None,
																																																																				None
																																																																		if		code == 0:
																																																																		out_starts = out.find(start_cookie[::-1])

																																																																			if out_starts > -1:
																																																																			pre_cookie = out[:out_starts]

																																																																				if pre_cookie:
																																																																				sys.stdout.write(pre_cookie)

																																																																					out = out[out_starts + COOKIE_LENGTH:]

																																																																					out_ends = out.find(end_cookie[::-1])

																																																																					if out_ends > -1:
																																																																					post_cookie = out[out_ends + COOKIE_LENGTH:]

																																																																						if post_cookie:
																																																																						sys.stdout.write(post_cookie)

																																																																							out = out[:out_ends]

																																																																							result = cls._from_json(out)
																																																																							result.executable = exe
#keep original executable as this may contain initialization code
																																																																							else
																																																																							:
																																																																							msg = f "{exe} with code {code}{f' out: {out!r}' if out else ''}{f' err: {err!r}' if err else ''}"
																																																																							failure = RuntimeError(f "failed to query {msg}")
																																																																							return failure,
																																																																									result


																																																																									class LogCmd:
																																																																									def __init__(self, cmd, env = None)->None:
																																																																							self.cmd = cmd
																																																																							self.env = env

																																																																							def __repr__(self)->str:
																																																																							cmd_repr = " ".join(quote(str(c)) for c in self.cmd)
																																																																								if self.env is not None:
																																																																								cmd_repr = f "{cmd_repr} env of {self.env!r}"
																																																																								return cmd_repr


																																																																								def clear(app_data)
																																																																									:
																																																																									app_data.py_info_clear()
																																																																									_CACHE.clear()


																																																																									___all___ =[
																																																																										    "from_exe",
																																																																										    "clear",
																																																																										    "LogCmd",
																																																																									]
																																																																									PK  5L  Z ˚ {£ïïvirtualenv / discovery / discover.pyfrom __future__ import annotations

																																																																									from abc import ABC, abstractmethod


																																																																									class Discover(ABC):
																																																																									"" "Discover and provide the requested Python interpreter." ""

																																																																									@ classmethod
																																																																									def add_parser_arguments(cls, parser):
																																																																									"" "
																																																																									Add CLI arguments for this discovery mechanisms.

																																																																									:param parser:the CLI parser
																																																																									"" "
																																																																									raise NotImplementedError

																																																																									def __init__(self, options)
																																																																										->None:
																																																																										"" "
																																																																										Create a new discovery mechanism.

																																																																										:param options:the parsed options as defined within:meth:`add_parser_arguments `
																																																																										"" "
																																																																										self._has_run = False
																																																																										self._interpreter = None
																																																																										self._env = options.env

																																																																										@ abstractmethod
																																																																										def run(self):
																																																																										"" "
																																																																										Discovers an interpreter.

																																																																										:return:the interpreter ready to use for virtual environment creation
																																																																										"" "
																																																																										raise NotImplementedError

																																																																										@ property
																																																																										def interpreter(self)
																																																																											:
																																																																											"" ":return: the interpreter as returned by :meth:`run`, cached" ""
																																																																											if self._has_run is False:
																																																																											self._interpreter = self.run()
																																																																												self._has_run = True
																																																																												return self._interpreter


																																																																												__all__ =[
																																																																													  "Discover",
																																																																												]
																																																																												PK  5L  ZN_ ≈ ¬HfHf  virtualenv / discovery / py_info.py "" "
																																																																												The PythonInfo contains information about a concrete instance of a Python interpreter.

																																																																												Note:this file is also used to query target interpreters, so can only use standard library methods
																																																																												"" "

																																																																												from __future__ import annotations

																																																																												import json
																																																																												import logging
																																																																												import os
																																																																												import platform
																																																																												import re
																																																																												import struct
																																																																												import sys
																																																																												import sysconfig
																																																																												import warnings
																																																																												from collections import OrderedDict,
																																																																												namedtuple
																																																																												from string import digits

																																																																												VersionInfo = namedtuple("VersionInfo",["major", "minor", "micro", "releaselevel", "serial"])
#noqa: PYI024
																																																																												LOGGER = logging.getLogger(__name__)


																																																																												def _get_path_extensions():
																																																																												return list(OrderedDict.fromkeys(["", *os.environ.get("PATHEXT", "").lower().split(os.pathsep)]))


																																																																												EXTENSIONS = _get_path_extensions()
																																																																												_CONF_VAR_RE = re.compile(r "\{\w+\}")


																																																																												class PythonInfo:
#noqa: PLR0904
																																																																												"" "Contains information for a Python interpreter." ""

																																																																												def __init__(self)->None:
#noqa: PLR0915
																																																																												def abs_path(v):
																																																																												return None if v is None
																																																																												else
																																																																												os.path.abspath(v)
#unroll relative elements from path (e.g. ..)

#qualifies the python
																																																																													self.platform = sys.platform
																																																																													self.implementation = platform.python_implementation()
																																																																													if self.implementation == "PyPy":
																																																																													self.pypy_version_info = tuple(sys.pypy_version_info)

#this is a tuple in earlier, struct later, unify to our own named tuple
																																																																														self.version_info = VersionInfo(*sys.version_info)
#Use the same implementation as found in stdlib platform.architecture
#to account for platforms where the maximum integer is not equal the
#pointer size.
																																																																														self.architecture = 32 if struct.calcsize("P")
																																																																															== 4
																																																																															else
																																																																															64
#noqa: PLR2004

#Used to determine some file names.
#See `CPython3Windows.python_zip()`.
																																																																															self.version_nodot = sysconfig.get_config_var("py_version_nodot")

																																																																															self.version = sys.version
																																																																															self.os = os.name
																																																																															self.free_threaded = sysconfig.get_config_var("Py_GIL_DISABLED") == 1

#information about the prefix - determines python home
																																																																															self.prefix = abs_path(getattr(sys, "prefix", None))
#prefix we think
																																																																															self.base_prefix = abs_path(getattr(sys, "base_prefix", None))
#venv
																																																																															self.real_prefix = abs_path(getattr(sys, "real_prefix", None))
#old virtualenv

#information about the exec prefix - dynamic stdlib modules
																																																																															self.base_exec_prefix = abs_path(getattr(sys, "base_exec_prefix", None))
																																																																															self.exec_prefix = abs_path(getattr(sys, "exec_prefix", None))

																																																																															self.executable = abs_path(sys.executable)
#the executable we were invoked via
																																																																															self.original_executable = abs_path(self.executable)
#the executable as known by the interpreter
																																																																															self.system_executable = self._fast_get_system_executable()
#the executable we are based of (if available)

																																																																															try:
																																																																															__import__("venv")
																																																																															has = True
																																																																															except ImportError:
																																																																															has = False
																																																																															self.has_venv = has
																																																																															self.path = sys.path
																																																																															self.file_system_encoding = sys.getfilesystemencoding()
																																																																															self.stdout_encoding = getattr(sys.stdout, "encoding", None)

																																																																															scheme_names = sysconfig.get_scheme_names()

																																																																															if "venv" in scheme_names:
																																																																															self.sysconfig_scheme = "venv"
																																																																															self.sysconfig_paths = {
																																																																															i:sysconfig.get_path(i, expand = False, scheme = self.sysconfig_scheme)
																																																																																for i in sysconfig.get_path_names()
																																																																																	}
#we cannot use distutils at all if "venv" exists, distutils don't know it
																																																																																	self.distutils_install = {}
#debian / ubuntu python 3.10 without `python3-distutils` will report
#mangled `local/bin` / etc. names for the default prefix
#intentionally select `posix_prefix` which is the unaltered posix-like paths
																																																																															elif sys.version_info[:2] == (3, 10) and "deb_system" in scheme_names:
																																																																															self.sysconfig_scheme = "posix_prefix"
																																																																															self.sysconfig_paths = {
																																																																																i:sysconfig.get_path(i, expand = False, scheme = self.sysconfig_scheme) for i in sysconfig.get_path_names()
																																																																																	}
#we cannot use distutils at all if "venv" exists, distutils don't know it
																																																																																	self.distutils_install = {}
																																																																																else
																																																																																:
																																																																																self.sysconfig_scheme = None
																																																																																	self.sysconfig_paths = {i:sysconfig.get_path(i, expand = False) for i in sysconfig.get_path_names()
																																																																																		}
																																																																																		self.distutils_install = self._distutils_install().copy()

#https://bugs.python.org/issue22199
																																																																																		makefile = getattr(sysconfig, "get_makefile_filename", getattr(sysconfig, "_get_makefile_filename", None))
																																																																																		self.sysconfig = {
																																																																																		k:v
																																																																																		for k, v in[
#a list of content to store from sysconfig
																																																																																			    ("makefile_filename", makefile()),
																																																																																		]
																																																																																			if k is not None
																																																																																			}

																																																																																			config_var_keys = set()
																																																																																				for element in self.sysconfig_paths.values()
																																																																																					:
																																																																																					config_var_keys.update(k[1:-1] for k in _CONF_VAR_RE.findall(element))
																																																																																						config_var_keys.add("PYTHONFRAMEWORK")

																																																																																						self.sysconfig_vars = {i:sysconfig.get_config_var(i or "") for i in config_var_keys}

																																																																																		confs = {
																																																																																			k:(self.system_prefix if v is not None and v.startswith(self.prefix)
																																																																																			   else
																																																																																			   v)
																																																																																				for k, v in self.sysconfig_vars.items()
																																																																																					}
																																																																																					self.system_stdlib = self.sysconfig_path("stdlib", confs)
																																																																																					self.system_stdlib_platform = self.sysconfig_path("platstdlib", confs)
																																																																																					self.max_size = getattr(sys, "maxsize", getattr(sys, "maxint", None))
																																																																																					self._creators = None

																																																																																					def _fast_get_system_executable(self):
																																																																																					"" "Try to get the system executable by just looking at properties." ""
																																																																																					if self.real_prefix or(
#noqa: PLR1702
																																																																																							       self.base_prefix is not None and self.base_prefix != self.prefix
																																																																																					)
																																																																																						:
#if this is a virtual environment
																																																																																						if self.real_prefix is None:
																																																																																						base_executable = getattr(sys, "_base_executable", None)
#some platforms may set this to help us
																																																																																							if base_executable is not None:
#noqa: SIM102 # use the saved system executable if present
																																																																																							if sys.executable != base_executable:
#we know we're in a virtual environment, cannot be us
																																																																																							if os.path.exists(base_executable)
																																																																																								:
																																																																																								return base_executable
#Python may return "python" because it was invoked from the POSIX virtual environment
#however some installs/distributions do not provide a version-less "python" binary in
#the system install location (see PEP 394) so try to fallback to a versioned binary.
#
#Gate this to Python 3.11 as `sys._base_executable` path resolution is now relative to
#the 'home' key from pyvenv.cfg which often points to the system install location.
																																																																																								major, minor = self.version_info.major, self.version_info.minor
																																																																																								if self.os == "posix" and(major, minor)
																																																																																									>=(3, 11):
#search relative to the directory of sys._base_executable
																																																																																									base_dir = os.path.dirname(base_executable)
																																																																																									for base_executable in[
																																																																																											       os.path.join(base_dir, exe) for exe in(f "python{major}", f "python{major}.{minor}")
																																																																																									]
																																																																																										:
																																																																																										if os.path.exists(base_executable)
																																																																																											:
																																																																																											return base_executable
																																																																																											return None
#in this case we just can't tell easily without poking around FS and calling them, bail
#if we're not in a virtual environment, this is already a system python, so return the original executable
#note we must choose the original and not the pure executable as shim scripts might throw us off
																																																																																											return self.original_executable

																																																																																											def install_path(self, key):
																																																																																											result = self.distutils_install.get(key)
																																																																																											if result is None:
#use sysconfig if sysconfig_scheme is set or distutils is unavailable
#set prefixes to empty => result is relative from cwd
																																																																																											prefixes = self.prefix, self.exec_prefix, self.base_prefix, self.base_exec_prefix
																																																																																											config_var = {k:"" if v in prefixes
																																																																																											else
																																																																																											v for k, v in self.sysconfig_vars.items()
																																																																																												}
																																																																																												result = self.sysconfig_path(key, config_var = config_var).lstrip(os.sep)
																																																																																												return result

																																																																																												@ staticmethod
																																																																																												def _distutils_install():
#use distutils primarily because that's what pip does
#https://github.com/pypa/pip/blob/main/src/pip/_internal/locations.py#L95
#note here we don't import Distribution directly to allow setuptools to patch it
																																																																																												with warnings.catch_warnings():
#disable warning for PEP-632
																																																																																												warnings.simplefilter("ignore")
																																																																																												try:
																																																																																												from distutils import dist
#noqa: PLC0415
																																																																																												from distutils.command.install import SCHEME_KEYS
#noqa: PLC0415
																																																																																												except ImportError:
#if removed or not installed ignore
																																																																																												return {}

																																																																																											d = dist.Distribution({"script_args":"--no-user-cfg"})
#conf files not parsed so they do not hijack paths
																																																																																											if hasattr(sys, "_framework")
																																																																																												:
																																																																																												sys._framework = None
#disable macOS static paths for framework  # noqa: SLF001

																																																																																												with warnings.catch_warnings():
#disable warning for PEP-632
																																																																																												warnings.simplefilter("ignore")
																																																																																												i = d.get_command_obj("install", create = True)

																																																																																												i.prefix = os.sep
#paths generated are relative to prefix that contains the path sep, this makes it relative
																																																																																												i.finalize_options()
																																																																																												return {key:(getattr(i, f "install_{key}")[1:]).lstrip(os.sep) for key in SCHEME_KEYS}

																																																																																											@property
																																																																																											def version_str(self)
																																																																																												:
																																																																																												return ".".join(str(i) for i in self.version_info[0:3])

																																																																																													@property
																																																																																													def version_release_str(self):
																																																																																													return ".".join(str(i) for i in self.version_info[0:2])

																																																																																														@property
																																																																																														def python_name(self):
																																																																																														version_info = self.version_info
																																																																																														return f "python{version_info.major}.{version_info.minor}"

																																																																																														@ property
																																																																																														def is_old_virtualenv(self):
																																																																																														return self.real_prefix is not None

																																																																																														@ property
																																																																																														def is_venv(self):
																																																																																														return self.base_prefix is not None

																																																																																														def sysconfig_path(self, key, config_var = None, sep = os.sep):
																																																																																														pattern = self.sysconfig_paths[key]
																																																																																														if config_var is None:
																																																																																														config_var = self.sysconfig_vars
																																																																																														else
																																																																																														:
																																																																																														base = self.sysconfig_vars.copy()
																																																																																															base.update(config_var)
																																																																																															config_var = base
																																																																																															return pattern.format(**config_var).replace("/", sep)

																																																																																															def creators(self, refresh = False):
#noqa: FBT002
																																																																																															if self._creators is None or refresh is True:
																																																																																															from virtualenv.run.plugin.creators import CreatorSelector
#noqa: PLC0415

																																																																																															self._creators = CreatorSelector.for_interpreter(self)
																																																																																																return self._creators

																																																																																																@ property
																																																																																																def system_include(self):
																																																																																																path = self.sysconfig_path(
																																																																																																			   "include",
																																																																																																			   {
																																																																																																k:(self.system_prefix if v is not None and v.startswith(self.prefix)
																																																																																																   else
																																																																																																   v)
																																																																																																	for k, v in self.sysconfig_vars.items()
																																																																																																		},
																																																																																																		)
																																																																																																		if not os.path.exists(path)
																																																																																																			:
#some broken packaging don't respect the sysconfig, fallback to distutils path
#the pattern include the distribution name too at the end, remove that via the parent call
																																																																																																			fallback = os.path.join(self.prefix, os.path.dirname(self.install_path("headers")))
																																																																																																			if os.path.exists(fallback)
																																																																																																				:
																																																																																																				path = fallback
																																																																																																				return path

																																																																																																				@ property
																																																																																																				def system_prefix(self):
																																																																																																				return self.real_prefix or self.base_prefix or self.prefix

																																																																																																				@ property
																																																																																																				def system_exec_prefix(self):
																																																																																																				return self.real_prefix or self.base_exec_prefix or self.exec_prefix

																																																																																																				def __repr__(self)->str:
																																																																																																				return "{}({!r})".format(
																																																																																																							 self.__class__.__name__,
																																																																																																							 {k:v for k, v in self.__dict__.items()
																																																																																																					if not k.startswith("_")
																																																																																																						},
																																																																																																						)

																																																																																																						def __str__(self)->str:
																																																																																																						return "{}({})".format(
																																																																																																								       self.__class__.__name__,
																																																																																																								       ", ".join(
																																																																																																										 f "{k}={v}"
																																																																																																										 for k, v in(
																																																																																																											     ("spec", self.spec),
																																																																																																											     (
																																																																																																											      "system"
																																																																																																											      if self.system_executable is not None and self.system_executable != self.executable
																																																																																																											      else
																																																																																																											      None,
																																																																																																											      self.system_executable,
																																																																																																											      ),
																																																																																																											     (
																																																																																																											      "original"
																																																																																																											      if self.original_executable not in {self.system_executable, self.executable}
																																																																																																						else
																																																																																																							None,
																																																																																																							self.original_executable,
																																																																																																							),
																																																																																																							("exe", self.executable),
																																																																																																							("platform", self.platform),
																																																																																																							("version", repr(self.version)),
																																																																																																							("encoding_fs_io", f "{self.file_system_encoding}-{self.stdout_encoding}"),
																																																																																																							)
																																																																																																							if k is not None
																																																																																																						)
																																																																																																							,
																																																																																																							)

																																																																																																							@ property
																																																																																																							def spec(self):
																																																																																																							return "{}{}{}-{}".format(
																																																																																																										  self.implementation,
																																																																																																										  ".".join(str(i) for i in self.version_info),
																																																																																																										  "t" if self.free_threaded
																																																																																																										  else
																																																																																																										  "",
																																																																																																										  self.architecture,
																																																																																																							)

																																																																																																								@classmethod
																																																																																																								def clear_cache(cls, app_data):
#this method is not used by itself, so here and called functions can import stuff locally
																																																																																																								from virtualenv.discovery.cached_py_info import clear
#noqa: PLC0415

																																																																																																								clear(app_data)
																																																																																																								cls._cache_exe_discovery.clear()

																																																																																																								def satisfies(self, spec, impl_must_match):
#noqa: C901, PLR0911
																																																																																																								"" "Check if a given specification can be satisfied by the this python interpreter instance." ""
																																																																																																								if spec.path:
																																																																																																								if self.executable == os.path.abspath(spec.path)
																																																																																																									:
																																																																																																									return True
#if the path is a our own executable path we're done
																																																																																																									if not spec.is_abs:
#if path set, and is not our original executable name, this does not match
																																																																																																									basename = os.path.basename(self.original_executable)
																																																																																																										spec_path = spec.path
																																																																																																										if sys.platform == "win32":
																																																																																																										basename, suffix = os.path.splitext(basename)
																																																																																																											if spec_path.endswith(suffix)
																																																																																																												:
																																																																																																												spec_path = spec_path[:-len(suffix)]
																																																																																																												if basename != spec_path:
																																																																																																												return False

																																																																																																												if (
																																																																																																												    impl_must_match
																																																																																																												    and spec.implementation is not None
																																																																																																												    and spec.implementation.lower() != self.implementation.lower()
																																																																																																												)
																																																																																																													:
																																																																																																													return False

																																																																																																													if spec.architecture is not None and spec.architecture != self.architecture:
																																																																																																													return False

																																																																																																													if spec.free_threaded is not None and spec.free_threaded != self.free_threaded:
																																																																																																													return False

																																																																																																													for our, req in zip(self.version_info[0:3], (spec.major, spec.minor, spec.micro))
																																																																																																														:
																																																																																																														if req is not None and our is not None and our != req:
																																																																																																														return False
																																																																																																														return True

																																																																																																														_current_system = None
																																																																																																														_current = None

																																																																																																														@ classmethod
																																																																																																														def current(cls, app_data = None)
																																																																																																															:
																																																																																																															"" "
																																																																																																															This locates the current host interpreter information.This might be different than what we run into in case
																																																																																																															the host python has been upgraded from underneath us.
																																																																																																															"" "  # noqa: D205
																																																																																																															if cls._current is None:
																																																																																																															cls._current = cls.from_exe(sys.executable, app_data, raise_on_error = True, resolve_to_host = False)
																																																																																																																return cls._current

																																																																																																																@ classmethod
																																																																																																																def current_system(cls, app_data = None)->PythonInfo:
																																																																																																																"" "
																																																																																																																This locates the current host interpreter information.This might be different than what we run into in case
																																																																																																																the host python has been upgraded from underneath us.
																																																																																																																"" "  # noqa: D205
																																																																																																																if cls._current_system is None:
																																																																																																																cls._current_system = cls.from_exe(sys.executable, app_data, raise_on_error = True, resolve_to_host = True)
																																																																																																																	return cls._current_system

																																																																																																																	def _to_json(self):
#don't save calculated paths, as these are non primitive types
																																																																																																																	return json.dumps(self._to_dict(), indent = 2)

																																																																																																																	def _to_dict(self):
																																																																																																																	data = {var:(getattr(self, var) if var != "_creators"
																																																																																																																		     else
																																																																																																																		     None)
																																																																																																																		for var in vars(self)
																																																																																																																			}

																																																																																																																			data["version_info"] = data["version_info"]._asdict()
#namedtuple to dictionary
																																																																																																																			return data

																																																																																																																			@ classmethod
																																																																																																																			def from_exe(
#noqa: PLR0913
																																																																																																																				     cls,
																																																																																																																				     exe,
																																																																																																																				     app_data = None,
																																																																																																																				     raise_on_error = True,
#noqa: FBT002
																																																																																																																				     ignore_cache = False,
#noqa: FBT002
																																																																																																																				     resolve_to_host = True,
#noqa: FBT002
																																																																																																																				     env = None,
																																																																																																																			):
																																																																																																																			"" "Given a path to an executable get the python information." ""
#this method is not used by itself, so here and called functions can import stuff locally
																																																																																																																			from virtualenv.discovery.cached_py_info import from_exe
#noqa: PLC0415

																																																																																																																			env = os.environ if env is None
																																																																																																																			else
																																																																																																																			env
																																																																																																																			proposed = from_exe(cls, app_data, exe, env = env, raise_on_error = raise_on_error, ignore_cache = ignore_cache)

																																																																																																																				if isinstance(proposed, PythonInfo)
																																																																																																																					and resolve_to_host:
																																																																																																																					try:
																																																																																																																					proposed = proposed._resolve_to_system(app_data, proposed)
#noqa: SLF001
																																																																																																																					except Exception as exception:
																																																																																																																					if raise_on_error:
																																																																																																																					raise
																																																																																																																					LOGGER.info("ignore %s due cannot resolve system due to %r", proposed.original_executable, exception)
																																																																																																																						proposed = None
																																																																																																																						return proposed

																																																																																																																						@ classmethod
																																																																																																																						def _from_json(cls, payload):
#the dictionary unroll here is to protect against pypy bug of interpreter crashing
																																																																																																																						raw = json.loads(payload)
																																																																																																																						return cls._from_dict(raw.copy())

																																																																																																																						@ classmethod
																																																																																																																						def _from_dict(cls, data):
																																																																																																																						data["version_info"] = VersionInfo(**data["version_info"])
#restore this to a named tuple structure
																																																																																																																						result = cls()
																																																																																																																						result.__dict__ = data.copy()
																																																																																																																						return result

																																																																																																																						@ classmethod
																																																																																																																						def _resolve_to_system(cls, app_data, target):
																																																																																																																						start_executable = target.executable
																																																																																																																						prefixes = OrderedDict()
																																																																																																																						while target.system_executable is None:
																																																																																																																						prefix = target.real_prefix or target.base_prefix or target.prefix
																																																																																																																						if prefix in prefixes:
																																																																																																																						if len(prefixes)
																																																																																																																							== 1:
#if we're linking back to ourselves accept ourselves with a WARNING
																																																																																																																							LOGGER.info("%r links back to itself via prefixes", target)
																																																																																																																							target.system_executable = target.executable
																																																																																																																							break
																																																																																																																							for at, (p, t)
																																																																																																																								in enumerate(prefixes.items(), start = 1):
																																																																																																																								LOGGER.error("%d: prefix=%s, info=%r", at, p, t)
																																																																																																																								LOGGER.error("%d: prefix=%s, info=%r", len(prefixes) + 1, prefix, target)
																																																																																																																								msg = "prefixes are causing a circle {}".format("|".join(prefixes.keys()))
																																																																																																																								raise RuntimeError(msg)
																																																																																																																								prefixes[prefix] = target
																																																																																																																								target = target.discover_exe(app_data, prefix = prefix, exact = False)
																																																																																																																								if target.executable != target.system_executable:
																																																																																																																								target = cls.from_exe(target.system_executable, app_data)
																																																																																																																									target.executable = start_executable
																																																																																																																									return target

																																																																																																																									_cache_exe_discovery = {}
#noqa: RUF012

																																																																																																																	def discover_exe(self, app_data, prefix, exact = True, env = None):
#noqa: FBT002
																																																																																																																	key = prefix, exact
																																																																																																																	if key in self._cache_exe_discovery and prefix:
																																																																																																																	LOGGER.debug("discover exe from cache %s - exact %s: %r", prefix, exact, self._cache_exe_discovery[key])
																																																																																																																		return self._cache_exe_discovery[key]
																																																																																																																		LOGGER.debug("discover exe for %s in %s", self, prefix)
#we don't know explicitly here, do some guess work - our executable name should tell
																																																																																																																		possible_names = self._find_possible_exe_names()
																																																																																																																		possible_folders = self._find_possible_folders(prefix)
																																																																																																																		discovered =[]
																																																																																																																		env = os.environ if env is None
																																																																																																																		else
																																																																																																																		env
																																																																																																																		for folder in possible_folders:
																																																																																																																		for name in possible_names:
																																																																																																																		info = self._check_exe(app_data, folder, name, exact, discovered, env)
																																																																																																																			if info is not None:
																																																																																																																			self._cache_exe_discovery[key]
																																																																																																																				= info
																																																																																																																				return info
																																																																																																																				if exact is False and discovered:
																																																																																																																				info = self._select_most_likely(discovered, self)
																																																																																																																					folders = os.pathsep.join(possible_folders)
																																																																																																																					self._cache_exe_discovery[key] = info
																																																																																																																					LOGGER.debug("no exact match found, chosen most similar of %s within base folders %s", info, folders)
																																																																																																																					return info
																																																																																																																					msg = "failed to detect {} in {}".format("|".join(possible_names), os.pathsep.join(possible_folders))
																																																																																																																					raise RuntimeError(msg)

																																																																																																																					def _check_exe(self, app_data, folder, name, exact, discovered, env):
#noqa: PLR0913
																																																																																																																					exe_path = os.path.join(folder, name)
																																																																																																																					if not os.path.exists(exe_path)
																																																																																																																						:
																																																																																																																						return None
																																																																																																																						info = self.from_exe(exe_path, app_data, resolve_to_host = False, raise_on_error = False, env = env)
																																																																																																																						if info is None:
#ignore if for some reason we can't query
																																																																																																																						return None
																																																																																																																						for item in["implementation", "architecture", "version_info"]
																																																																																																																							:
																																																																																																																							found = getattr(info, item)
																																																																																																																							searched = getattr(self, item)
																																																																																																																							if found != searched:
																																																																																																																							if item == "version_info":
																																																																																																																							found, searched = ".".join(str(i) for i in found)
																																																																																																																								,".".join(str(i) for i in searched)
																																																																																																																									executable = info.executable
																																																																																																																									LOGGER.debug("refused interpreter %s because %s differs %s != %s", executable, item, found, searched)
																																																																																																																									if exact is False:
																																																																																																																									discovered.append(info)
																																																																																																																										break
																																																																																																																										else
																																																																																																																										:
																																																																																																																										return info
																																																																																																																										return None

																																																																																																																										@ staticmethod
																																																																																																																										def _select_most_likely(discovered, target):
#no exact match found, start relaxing our requirements then to facilitate system package upgrades that
#could cause this (when using copy strategy of the host python)
																																																																																																																										def sort_by(info):
#we need to setup some priority of traits, this is as follows:
#implementation, major, minor, micro, architecture, tag, serial
																																																																																																																										matches =[
																																																																																																																											  info.implementation == target.implementation,
																																																																																																																											  info.version_info.major == target.version_info.major,
																																																																																																																											  info.version_info.minor == target.version_info.minor,
																																																																																																																											  info.architecture == target.architecture,
																																																																																																																											  info.version_info.micro == target.version_info.micro,
																																																																																																																											  info.version_info.releaselevel == target.version_info.releaselevel,
																																																																																																																											  info.version_info.serial == target.version_info.serial,
																																																																																																																										]
																																																																																																																										return sum((1 << pos if match
																																																																																																																											    else
																																																																																																																											    0) for pos, match in enumerate(reversed(matches)))

																																																																																																																											sorted_discovered = sorted(discovered, key = sort_by, reverse = True)
#sort by priority in decreasing order
																																																																																																																											return sorted_discovered[0]

																																																																																																																											def _find_possible_folders(self, inside_folder):
																																																																																																																											candidate_folder = OrderedDict()
																																																																																																																											executables = OrderedDict()
																																																																																																																											executables[os.path.realpath(self.executable)] = None
																																																																																																																											executables[self.executable] = None
																																																																																																																											executables[os.path.realpath(self.original_executable)] = None
																																																																																																																											executables[self.original_executable] = None
																																																																																																																											for exe in executables:
																																																																																																																											base = os.path.dirname(exe)
#following path pattern of the current
																																																																																																																												if base.startswith(self.prefix)
																																																																																																																													:
																																																																																																																													relative = base[len(self.prefix):]
																																																																																																																													candidate_folder[f "{inside_folder}{relative}"] = None

#or at root level
																																																																																																																													candidate_folder[inside_folder] = None
																																																																																																																													return[i for i in candidate_folder if os.path.exists(i)]

																																																																																																																														def _find_possible_exe_names(self):
																																																																																																																														name_candidate = OrderedDict()
																																																																																																																														for name in self._possible_base()
																																																																																																																															:
																																																																																																																															for at in(3, 2, 1, 0)
																																																																																																																																:
																																																																																																																																version = ".".join(str(i) for i in self.version_info[:at])
																																																																																																																																	mods =[""]
																																																																																																																																	if self.free_threaded:
																																																																																																																																	mods.append("t")
																																																																																																																																		for mod in mods:
																																																																																																																																		for arch in[f "-{self.architecture}", ""]
																																																																																																																																			:
																																																																																																																																			for ext in EXTENSIONS:
																																																																																																																																			candidate = f "{name}{version}{mod}{arch}{ext}"
																																																																																																																																			name_candidate[candidate]
																																																																																																																																				= None
																																																																																																																																				return list(name_candidate.keys())

																																																																																																																																				def _possible_base(self):
																																																																																																																																				possible_base = OrderedDict()
																																																																																																																																				basename = os.path.splitext(os.path.basename(self.executable))[0].rstrip(digits)
																																																																																																																																				possible_base[basename] = None
																																																																																																																																				possible_base[self.implementation] = None
#python is always the final option as in practice is used by multiple implementation as exe name
																																																																																																																																				if "python" in possible_base:
																																																																																																																																				del possible_base["python"]
																																																																																																																																					possible_base["python"] = None
																																																																																																																																					for base in possible_base:
																																																																																																																																					lower = base.lower()
																																																																																																																																						yield lower
																																																																																																																																						from virtualenv.info import fs_is_case_sensitive
#noqa: PLC0415

																																																																																																																																						if fs_is_case_sensitive()
																																																																																																																																							:
																																																																																																																																							if base != lower:
																																																																																																																																							yield base
																																																																																																																																							upper = base.upper()
																																																																																																																																								if upper != base:
																																																																																																																																								yield upper


																																																																																																																																								if __name__ == "__main__":
#dump a JSON representation of the current python

																																																																																																																																								argv = sys.argv[1:]

																																																																																																																																									if len(argv)
																																																																																																																																										>=1:
																																																																																																																																										start_cookie = argv[0]
																																																																																																																																										argv = argv[1:]
																																																																																																																																										else
																																																																																																																																										:
																																																																																																																																										start_cookie = ""

																																																																																																																																										if len(argv)
																																																																																																																																											>=1:
																																																																																																																																											end_cookie = argv[0]
																																																																																																																																											argv = argv[1:]
																																																																																																																																											else
																																																																																																																																											:
																																																																																																																																											end_cookie = ""

																																																																																																																																											sys.argv = sys.argv[:1] + argv

																																																																																																																																											info = PythonInfo()._to_json()
#noqa: SLF001
																																																																																																																																											sys.stdout.write("".join((start_cookie[::-1], info, end_cookie[::-1])))
																																																																																																																																											PK  5L  Z ì %4} ™™virtualenv / discovery / py_spec.py "" "A Python specification is an abstract requirement definition of an interpreter." ""

																																																																																																																																											from __future__ import annotations

																																																																																																																																											import os
																																																																																																																																											import re

																																																																																																																																											PATTERN = re.compile(r "^(?P<impl>[a-zA-Z]+)?(?P<version>[0-9.]+)?(?P<threaded>t)?(?:-(?P<arch>32|64))?$")


																																																																																																																																											class PythonSpec:
																																																																																																																																											"" "Contains specification about a Python Interpreter." ""

																																																																																																																																											def __init__(
#noqa: PLR0913
																																																																																																																																												     self,
																																																																																																																																												     str_spec:str,
																																																																																																																																												     implementation:str | None,
																																																																																																																																												     major:int |None,
																																																																																																																																												     minor:int |None,
																																																																																																																																												     micro:int |None,
																																																																																																																																												     architecture:int |None,
																																																																																																																																												     path:str | None,
																																																																																																																																												     *,
																																																																																																																																												     free_threaded:bool |None = None,
																																																																																																																																											)->None:
																																																																																																																																											self.str_spec = str_spec
																																																																																																																																											self.implementation = implementation
																																																																																																																																											self.major = major
																																																																																																																																											self.minor = minor
																																																																																																																																											self.micro = micro
																																																																																																																																											self.free_threaded = free_threaded
																																																																																																																																											self.architecture = architecture
																																																																																																																																											self.path = path

																																																																																																																																											@ classmethod
																																																																																																																																											def from_string_spec(cls, string_spec:str):
#noqa: C901, PLR0912
																																																																																																																																											impl,		major, minor, micro, threaded, arch, path = None, None, None, None, None, None, None
																																																																																																																																											if		os.path.isabs(string_spec)
																																																																																																																																												:
#noqa: PLR1702
																																																																																																																																														path = string_spec
																																																																																																																																												else
																																																																																																																																												:
																																																																																																																																												ok = False
																																																																																																																																												match = re.match(PATTERN, string_spec)
																																																																																																																																												if match:

																																																																																																																																												def _int_or_none(val)
																																																																																																																																													:
																																																																																																																																													return None if val is None
																																																																																																																																													else
																																																																																																																																													int (val)

																																																																																																																																														try:
																																																																																																																																														groups = match.groupdict()
																																																																																																																																														version = groups["version"]
																																																																																																																																														if version is not None:
																																																																																																																																														versions = tuple(int (i) for i in version.split(".") if i)
																																																																																																																																															if len(versions)
																																																																																																																																																>3:
#noqa: PLR2004
																																																																																																																																																raise ValueError
#noqa: TRY301
																																																																																																																																																if len(versions)
																																																																																																																																																	== 3:
#noqa: PLR2004
																																																																																																																																																	major,
																																																																																																																																																			minor,
																																																																																																																																																			micro = versions
																																																																																																																																																	elif len(versions) == 2:
#noqa: PLR2004
																																																																																																																																																	major,
																																																																																																																																																			minor = versions
																																																																																																																																																	elif len(versions) == 1:
																																																																																																																																																	version_data = versions[0]
																																																																																																																																																	major = int (str(version_data)[0])
#first digit major
																																																																																																																																																	if version_data > 9:
#noqa: PLR2004
																																																																																																																																																	minor = int (str(version_data)[1:])
																																																																																																																																																		threaded = bool (groups["threaded"])
																																																																																																																																																		ok = True
																																																																																																																																																		except ValueError:
																																																																																																																																																		pass
																																																																																																																																																		else
																																																																																																																																																		:
																																																																																																																																																		impl = groups["impl"]
																																																																																																																																																		if impl in {"py", "python"}:
																																																																																																																	impl = None
																																																																																																																	arch = _int_or_none(groups["arch"])

																																																																																																																		if not ok:
																																																																																																																		path = string_spec

																																																																																																																		return cls(string_spec, impl, major, minor, micro, arch, path, free_threaded = threaded)

																																																																																																																			def generate_re(self, *, windows:bool)->re.Pattern:
																																																																																																																			"" "Generate a regular expression for matching against a filename." ""
																																																																																																																			version = r "{}(\.{}(\.{})?)?".format(
						      *(r "\d+" if v is None
							else
							v for v in(self.major, self.minor, self.micro))
																																																																																																																			)
																																																																																																																				impl = "python" if self.implementation is None
																																																																																																																				else
																																																																																																																				f "python|{re.escape(self.implementation)}"
																																																																																																																				mod = "t?" if self.free_threaded
																																																																																																																				else
																																																																																																																				""
																																																																																																																				suffix = r "\.exe" if windows
																																																																																																																				else
																																																																																																																				""
																																																																																																																				version_conditional = (
																																																																																																																						       "?"
#Windows Python executables are almost always unversioned
																																																																																																																						       if windows
#Spec is an empty string
																																																																																																																						       or self.major is None
																																																																																																																						       else
																																																																																																																						       ""
																																																																																																																				)
#Try matching `direct` first, so the `direct` group is filled when possible.
																																																																																																																					return re.compile(
																																																																																																																							  rf "(?P<impl>{impl})(?P<v>{version}{mod}){version_conditional}{suffix}$",
																																																																																																																							  flags = re.IGNORECASE,
																																																																																																																					)

																																																																																																																					@ property
																																																																																																																					def is_abs(self):
																																																																																																																					return self.path is not None and os.path.isabs(self.path)

																																																																																																																					def satisfies(self, spec):
																																																																																																																					"" "Called when there's a candidate metadata spec to see if compatible - e.g. PEP-514 on Windows." ""
																																																																																																																					if spec.is_abs and self.is_abs and self.path != spec.path:
																																																																																																																					return False
																																																																																																																					if spec.implementation is not None and spec.implementation.lower()
																																																																																																																						!=self.implementation.lower():
																																																																																																																						return False
																																																																																																																						if spec.architecture is not None and spec.architecture != self.architecture:
																																																																																																																						return False
																																																																																																																						if spec.free_threaded is not None and spec.free_threaded != self.free_threaded:
																																																																																																																						return False

																																																																																																																						for our,	req in zip((self.major, self.minor, self.micro), (spec.major, spec.minor, spec.micro))
																																																																																																																							:
																																																																																																																							if		req is not None and our is not None and our != req:
																																																																																																																									return False
																																																																																																																									return True

																																																																																																																									def __repr__(self)
																																																																																																																									      ->str:
																																																																																																																										name = type(self).__name__
																																																																																																																								params = "implementation", "major", "minor", "micro", "architecture", "path", "free_threaded"
																																																																																																																										return f "{name}({', '.join(f'{k}={getattr(self, k)}' for k in params if getattr(self, k) is not None)})"


																																																																																																																										__all__ =[
																																																																																																																											  "PythonSpec",
																																																																																																																								]
																																																																																																																								PK  5L  Z √]  9 a  a  (virtualenv / discovery / windows / __init__.pyfrom __future__ import annotations

																																																																																																																											      from virtualenv.discovery.py_info import PythonInfo
																																																																																																																											      from virtualenv.discovery.py_spec import PythonSpec

																																																																																																																											      from.pep514 import discover_pythons

#Map of well-known organizations (as per PEP 514 Company Windows Registry key part) versus Python implementation
																																																																																																																											      _IMPLEMENTATION_BY_ORG = {
																																																																																																																								"ContinuumAnalytics":"CPython",
																																																																																																																								"PythonCore":"CPython",
																																																																																																																								}


																																																																																																																	class Pep514PythonInfo(PythonInfo):
																																																																																																																	"" "A Python information acquired from PEP-514." ""


																																																																																																																	def propose_interpreters(spec, cache_dir, env):
#see if PEP-514 entries are good

#start with higher python versions in an effort to use the latest version available
#and prefer PythonCore over conda pythons (as virtualenv is mostly used by non conda tools)
																																																																																																																	existing = list(discover_pythons())
																																																																																																																	existing.sort(
				      key = lambda i:(*tuple(-1 if j is None
							     else
							     j for j in i[1:4]), 1 if i[0] == "PythonCore"
						      else
						      0),
																																																																																																																		      reverse = True,
																																																																																																																							)

																																																																																																																								for name,	major, minor, arch, threaded, exe, _ in existing:
#Map well-known/most common organizations to a Python implementation, use the org name as a fallback for
#backwards compatibility.
																																																																																																																										implementation = _IMPLEMENTATION_BY_ORG.get(name, name)

#Pre-filtering based on Windows Registry metadata, for CPython only
																																																																																																																									skip_pre_filter = implementation.lower() != "cpython"
																																																																																																																									registry_spec = PythonSpec(None, implementation, major, minor, None, arch, exe, free_threaded = threaded)
																																																																																																																									if skip_pre_filter or registry_spec.satisfies(spec)
																																																																																																																										:
																																																																																																																										interpreter = Pep514PythonInfo.from_exe(exe, cache_dir, env = env, raise_on_error = False)
																																																																																																																										if interpreter is not None and interpreter.satisfies(spec, impl_must_match = True)
																																																																																																																											:
																																																																																																																											yield interpreter
#Final filtering/matching using interpreter metadata


																																																																																																																											__all__ =[
																																																																																																																												  "Pep514PythonInfo",
																																																																																																																												  "propose_interpreters",
																																																																																																																											]
																																																																																																																											PK  5L  Z  *ˆi																																																																																																																																																																																																																																																						&virtualenv / discovery / windows / pep514.py "" "Implement https://www.python.org/dev/peps/pep-0514/ to discover interpreters - Windows only." ""

																																																																																																																											from __future__ import annotations

																																																																																																																											import os
																																																																																																																											import re
																																																																																																																											import winreg
																																																																																																																											from logging import basicConfig, getLogger

																																																																																																																													LOGGER = getLogger(__name__)


																																																																																																																											def enum_keys(key):
																																																																																																																											at = 0
																																																																																																																											while True:
																																																																																																																											try:
																																																																																																																											yield winreg.EnumKey(key, at)
																																																																																																																												except OSError:
																																																																																																																												break
																																																																																																																												at += 1


																																																																																																																												def get_value(key, value_name):
																																																																																																																												try:
																																																																																																																												return winreg.QueryValueEx(key, value_name)[0]
																																																																																																																												except OSError:
																																																																																																																												return None


																																																																																																																												def discover_pythons():
																																																																																																																												for hive,	hive_name, key, flags, default_arch in[
																																																																																																																																		       (winreg.HKEY_CURRENT_USER, "HKEY_CURRENT_USER", r "Software\Python", 0, 64),
																																																																																																																																		       (winreg.HKEY_LOCAL_MACHINE, "HKEY_LOCAL_MACHINE", r "Software\Python", winreg.KEY_WOW64_64KEY, 64),
																																																																																																																																		       (winreg.HKEY_LOCAL_MACHINE, "HKEY_LOCAL_MACHINE", r "Software\Python", winreg.KEY_WOW64_32KEY, 32),
																																																																																																																												]
																																																																																																																													:
																																																																																																																															yield from process_set(hive, hive_name, key, flags, default_arch)


																																																																																																																															def process_set(hive, hive_name, key, flags, default_arch):
																																																																																																																															try:
																																																																																																																															with winreg.OpenKeyEx(hive, key, 0, winreg.KEY_READ | flags) as root_key:
																																																																																																																													for		company in enum_keys(root_key)
																																																																																																																														:
																																																																																																																														if		company == "PyLauncher":
#reserved
																																																																																																																														continue
																																																																																																																														yield from process_company(hive_name, company, root_key, default_arch)
																																																																																																																															except OSError:
																																																																																																																															pass


																																																																																																																															def process_company(hive_name, company, root_key, default_arch):
																																																																																																																															with winreg.OpenKeyEx(root_key, company) as company_key:
																																																																																																																															for tag in enum_keys(company_key)
																																																																																																																																:
																																																																																																																																spec = process_tag(hive_name, company, company_key, tag, default_arch)
																																																																																																																																if spec is not None:
																																																																																																																																yield spec


																																																																																																																																def process_tag(hive_name, company, company_key, tag, default_arch)
																																																																																																																																	:
																																																																																																																																	with winreg.OpenKeyEx(company_key, tag) as tag_key:
																																																																																																																																	version = load_version_data(hive_name, company, tag, tag_key)
																																																																																																																																	if version is not None:
#if failed to get version bail
																																																																																																																																	major,		minor, _ = version
																																																																																																																																	arch = load_arch_data(hive_name, company, tag, tag_key, default_arch)
																																																																																																																																		if arch is not None:
																																																																																																																																		exe_data = load_exe(hive_name, company, company_key, tag)
																																																																																																																																			if exe_data is not None:
																																																																																																																																			exe,		args = exe_data
																																																																																																																																			threaded = load_threaded(hive_name, company, tag, tag_key)
																																																																																																																																				return company,	major, minor, arch, threaded, exe, args
																																																																																																																																						return None
																																																																																																																																						return None
																																																																																																																																						return None


																																																																																																																																						def load_exe(hive_name, company, company_key, tag):
																																																																																																																																						key_path = f "{hive_name}/{company}/{tag}"
																																																																																																																																				try:
																																																																																																																																				with winreg.OpenKeyEx(company_key, rf "{tag}\InstallPath") as ip_key, ip_key:
																																																																																																																																						exe = get_value(ip_key, "ExecutablePath")
																																																																																																																																				if exe is None:
																																																																																																																																				ip = get_value(ip_key, None)
																																																																																																																																					if ip is None:
																																																																																																																																					msg(key_path, "no ExecutablePath or default for it")

																																																																																																																																						else
																																																																																																																																						:
																																																																																																																																						exe = os.path.join(ip, "python.exe")
																																																																																																																																						if exe is not None and os.path.exists(exe)
																																																																																																																																							:
																																																																																																																																							args = get_value(ip_key, "ExecutableArguments")
																																																																																																																																							return exe,	args
																																																																																																																																									msg(key_path, f "could not load exe with value {exe}")
																																																																																																																																									except OSError:
																																																																																																																																									msg(f "{key_path}/InstallPath", "missing")
																																																																																																																																									return None


																																																																																																																																									def load_arch_data(hive_name, company, tag, tag_key, default_arch):
																																																																																																																																									arch_str = get_value(tag_key, "SysArchitecture")
																																																																																																																																							if arch_str is not None:
																																																																																																																																							key_path = f "{hive_name}/{company}/{tag}/SysArchitecture"
																																																																																																																																							try:
																																																																																																																																							return parse_arch(arch_str)
																																																																																																																																								except ValueError as sys_arch:
																																																																																																																																								msg(key_path, sys_arch)
																																																																																																																																								return default_arch


																																																																																																																																								def parse_arch(arch_str):
																																																																																																																																								if isinstance(arch_str, str)
																																																																																																																																									:
																																																																																																																																									match = re.match(r "^(\d+)bit$", arch_str)
																																																																																																																																									if match:
																																																																																																																																									return int (next(iter(match.groups())))
																																																																																																																																										error = f "invalid format {arch_str}"
																																																																																																																																										else
																																																																																																																																										:
																																																																																																																																										error = f "arch is not string: {arch_str!r}"
																																																																																																																																										raise ValueError(error)


																																																																																																																																										def load_version_data(hive_name, company, tag, tag_key):
																																																																																																																																										for candidate,
																																																																																																																																												key_path in[
																																																																																																																																													    (get_value(tag_key, "SysVersion"), f "{hive_name}/{company}/{tag}/SysVersion"),
																																																																																																																																													    (tag, f "{hive_name}/{company}/{tag}"),
																																																																																																																																										]
																																																																																																																																											:
																																																																																																																																											if		candidate is not None:
																																																																																																																																													try:
																																																																																																																																													return parse_version(candidate)
																																																																																																																																														except ValueError as sys_version:
																																																																																																																																														msg(key_path, sys_version)
																																																																																																																																														return None


																																																																																																																																														def parse_version(version_str):
																																																																																																																																												if		isinstance(version_str, str)
																																																																																																																																													:
																																																																																																																																															match = re.match(r "^(\d+)(?:\.(\d+))?(?:\.(\d+))?$", version_str)
																																																																																																																																													if match:
																																																																																																																																													return tuple(int (i) if i is not None
																																																																																																																																														     else
																																																																																																																																														     None for i in match.groups())
																																																																																																																																														error = f "invalid format {version_str}"
																																																																																																																																														else
																																																																																																																																														:
																																																																																																																																														error = f "version is not string: {version_str!r}"
																																																																																																																																														raise ValueError(error)


																																																																																																																																														def load_threaded(hive_name, company, tag, tag_key):
																																																																																																																																														display_name = get_value(tag_key, "DisplayName")
																																																																																																																																														if display_name is not None:
																																																																																																																																														if isinstance(display_name, str)
																																																																																																																																															:
																																																																																																																																															if "freethreaded" in display_name.lower()
																																																																																																																																																:
																																																																																																																																																return True
																																																																																																																																																else
																																																																																																																																																:
																																																																																																																																																key_path = f "{hive_name}/{company}/{tag}/DisplayName"
																																																																																																																																																msg(key_path, f "display name is not string: {display_name!r}")
																																																																																																																																																return bool (re.match(r "^\d+(\.\d+){0,2}t$", tag, flags = re.IGNORECASE))


																																																																																																																																																def msg(path, what):
																																																																																																																																																LOGGER.warning("PEP-514 violation in Windows Registry at %s error: %s", path, what)


																																																																																																																																																def _run():
																																																																																																																																																basicConfig()
																																																																																																																																																interpreters =[repr(spec) for spec in discover_pythons()]
																																																																																																																																																	print("\n".join(sorted(interpreters)))
#noqa: T201


																																																																																																																																																	if __name__ == "__main__":
																																																																																																																																																	_run()
																																																																																																																																																		PK  5L  Z ì M  Md  d  virtualenv / run / __init__.pyfrom __future__ import annotations

																																																																																																																																																		import logging
																																																																																																																																																		import os
																																																																																																																																																		from functools import partial

																																																																																																																																																		from virtualenv.app_data import make_app_data
																																																																																																																																																		from virtualenv.config.cli.parser import VirtualEnvConfigParser
																																																																																																																																																		from virtualenv.report import LEVELS,
																																																																																																																																																				setup_report
																																																																																																																																																				from virtualenv.run.session import Session
																																																																																																																																																				from virtualenv.seed.wheels.periodic_update import manual_upgrade
																																																																																																																																																				from virtualenv.version import __version__

																																																																																																																																																				from.plugin.activators import ActivationSelector
																																																																																																																																																				from.plugin.creators import CreatorSelector
																																																																																																																																																				from.plugin.discovery import get_discover
																																																																																																																																																				from.plugin.seeders import SeederSelector


																																																																																																																																																				def cli_run(args, options = None, setup_logging = True, env = None):
#noqa: FBT002
																																																																																																																																																		"" "
																																																																																																																																																		Create a virtual environment given some command line interface arguments.

																																																																																																																																																		:param args:the command line arguments
																																																																																																																																																		:param options:passing in a `` VirtualEnvOptions `` object allows return of the parsed options
																																																																																																																																																		:param setup_logging:``True `` if setup logging handlers,
																																																																																																																																																			      ``False `` to use handlers already registered
																																																																																																																																																		:		param env:environment variables to use
																																																																																																																																																		:		return:the session object of the creation(its structure for now is experimental and might change on short notice)
																																																																																																																																																					"" "
																																																																																																																																																					env = os.environ if env is None
																																																																																																																																																			else
																																																																																																																																																			env
																																																																																																																																																			of_session = session_via_cli(args, options, setup_logging, env)
																																																																																																																																																				with of_session:
																																																																																																																																																				of_session.run()
																																																																																																																																																				return of_session


																																																																																																																																																				def session_via_cli(args, options = None, setup_logging = True, env = None):
#noqa: FBT002
																																																																																																																																																				"" "
																																																																																																																																																				Create a virtualenv session(same as cli_run, but this does not perform the creation).Use this if you just want to
																																																																																																																																																				query what the virtual environment would look like,
																																																																																																																																																						but not actually create it.

																																																																																																																																																				:		param args:the command line arguments
																																																																																																																																																				:		param options:passing in a `` VirtualEnvOptions `` object allows return of the parsed options
																																																																																																																																																				:		param setup_logging:``True `` if setup logging handlers,
																																																																																																																																																					      ``False `` to use handlers already registered
																																																																																																																																																				:		param env:environment variables to use
																																																																																																																																																				:		return:the session object of the creation(its structure for now is experimental and might change on short notice)
																																																																																																																																																							"" "  # noqa: D205
																																																																																																																																																							env = os.environ if env is None
																																																																																																																																																					else
																																																																																																																																																					env
																																																																																																																																																					parser,
																																																																																																																																																							elements = build_parser(args, options, setup_logging, env)
																																																																																																																																																						options = parser.parse_args(args)
																																																																																																																																																						creator,
																																																																																																																																																								seeder,
																																																																																																																																																								activators = tuple(e.create(options) for e in elements)
#create types
																																																																																																																																																							return Session(
																																																																																																																																																								       options.verbosity,
																																																																																																																																																								       options.app_data,
																																																																																																																																																								       parser._interpreter,
#noqa: SLF001
																																																																																																																																																								       creator,
																																																																																																																																																								       seeder,
																																																																																																																																																								       activators,
																																																																																																																																																							)


																																																																																																																																																							def build_parser(args = None, options = None, setup_logging = True, env = None):
#noqa: FBT002
																																																																																																																																																							parser = VirtualEnvConfigParser(options, os.environ if env is None
																																																																																																																																																											else
																																																																																																																																																											env)
																																																																																																																																																								add_version_flag(parser)
																																																																																																																																																								parser.add_argument(
																																																																																																																																																										    "--with-traceback",
																																																																																																																																																										    dest = "with_traceback",
																																																																																																																																																										    action = "store_true",
																																																																																																																																																										    default = False,
																																																																																																																																																										    help = "on failure also display the stacktrace internals of virtualenv",
																																																																																																																																																								)
																																																																																																																																																								_do_report_setup(parser, args, setup_logging)
																																																																																																																																																								options = load_app_data(args, parser, options)
																																																																																																																																																								handle_extra_commands(options)

																																																																																																																																																								discover = get_discover(parser, args)
																																																																																																																																																								parser._interpreter = interpreter = discover.interpreter
#noqa: SLF001
																																																																																																																																																								if interpreter is None:
																																																																																																																																																								msg = f "failed to find interpreter for {discover}"
																																																																																																																																																								raise RuntimeError(msg)
																																																																																																																																																									elements =[
																																																																																																																																																										   CreatorSelector(interpreter, parser),
																																																																																																																																																										   SeederSelector(interpreter, parser),
																																																																																																																																																										   ActivationSelector(interpreter, parser),
																																																																																																																																																									]
																																																																																																																																																									options,
																																																																																																																																																											_ = parser.parse_known_args(args)
																																																																																																																																																									for element in elements:
																																																																																																																																																									element.handle_selected_arg_parse(options)
																																																																																																																																																										parser.enable_help()
																																																																																																																																																										return parser,
																																																																																																																																																												elements


																																																																																																																																																												def build_parser_only(args = None):
																																																																																																																																																										"" "Used to provide a parser for the doc generation." ""
																																																																																																																																																										return build_parser(args)[0]


																																																																																																																																																										def handle_extra_commands(options):
																																																																																																																																																										if options.upgrade_embed_wheels:
																																																																																																																																																										result = manual_upgrade(options.app_data, options.env)
																																																																																																																																																											raise SystemExit(result)


																																																																																																																																																											def load_app_data(args, parser, options):
																																																																																																																																																											parser.add_argument(
																																																																																																																																																													    "--read-only-app-data",
																																																																																																																																																													    action = "store_true",
																																																																																																																																																													    help = "use app data folder in read-only mode (write operations will fail with error)",
																																																																																																																																																											)
																																																																																																																																																											options,
																																																																																																																																																													_ = parser.parse_known_args(args, namespace = options)

#here we need a write-able application data (e.g. the zipapp might need this for discovery cache)
																																																																																																																																																											parser.add_argument(
																																																																																																																																																													    "--app-data",
																																																																																																																																																													    help = "a data folder used as cache by the virtualenv",
																																																																																																																																																													    type = partial(make_app_data, read_only = options.read_only_app_data, env = options.env),
																																																																																																																																																													    default = make_app_data(None, read_only = options.read_only_app_data, env = options.env),
																																																																																																																																																											)
																																																																																																																																																											parser.add_argument(
																																																																																																																																																													    "--reset-app-data",
																																																																																																																																																													    action = "store_true",
																																																																																																																																																													    help = "start with empty app data folder",
																																																																																																																																																											)
																																																																																																																																																											parser.add_argument(
																																																																																																																																																													    "--upgrade-embed-wheels",
																																																																																																																																																													    action = "store_true",
																																																																																																																																																													    help = "trigger a manual update of the embedded wheels",
																																																																																																																																																											)
																																																																																																																																																											options,
																																																																																																																																																													_ = parser.parse_known_args(args, namespace = options)
																																																																																																																																																											if options.reset_app_data:
																																																																																																																																																											options.app_data.reset()
																																																																																																																																																												return options


																																																																																																																																																												def add_version_flag(parser):
																																																																																																																																																												import virtualenv
#noqa: PLC0415

																																																																																																																																																												parser.add_argument(
																																																																																																																																																														    "--version",
																																																																																																																																																														    action = "version",
																																																																																																																																																														    version = f "%(prog)s {__version__} from {virtualenv.__file__}",
																																																																																																																																																														    help = "display the version of the virtualenv package and its location, then exit",
																																																																																																																																																												)


																																																																																																																																																												def _do_report_setup(parser, args, setup_logging):
																																																																																																																																																												level_map = ", ".join(f "{logging.getLevelName(line)}={c}" for c, line in sorted(LEVELS.items()))
																																																																																																																																																													msg = "verbosity = verbose - quiet, default {}, mapping => {}"
																																																																																																																																																													verbosity_group = parser.add_argument_group(
																																																																																																																																																																		    title = "verbosity",
																																																																																																																																																																		    description = msg.format(logging.getLevelName(LEVELS[3]), level_map),
																																																																																																																																																													)
																																																																																																																																																													verbosity = verbosity_group.add_mutually_exclusive_group()
																																																																																																																																																													verbosity.add_argument("-v", "--verbose", action = "count", dest = "verbose", help = "increase verbosity", default = 2)
																																																																																																																																																													verbosity.add_argument("-q", "--quiet", action = "count", dest = "quiet", help = "decrease verbosity", default = 0)
																																																																																																																																																													option,
																																																																																																																																																															_ = parser.parse_known_args(args)
																																																																																																																																																													if setup_logging:
																																																																																																																																																													setup_report(option.verbosity)


																																																																																																																																																														__all__ =[
																																																																																																																																																															  "cli_run",
																																																																																																																																																															  "session_via_cli",
																																																																																																																																																														]
																																																																																																																																																														PK  5L  Z8 Ÿ ‡∑∑virtualenv / run / session.pyfrom __future__ import annotations

																																																																																																																																																														import json
																																																																																																																																																														import logging

																																																																																																																																																														LOGGER = logging.getLogger(__name__)


																																																																																																																																																														class Session:
																																																																																																																																																														"" "Represents a virtual environment creation session." ""

																																																																																																																																																														def __init__(self, verbosity, app_data, interpreter, creator, seeder, activators)->None:
#noqa: PLR0913
																																																																																																																																																														self._verbosity = verbosity
																																																																																																																																																														self._app_data = app_data
																																																																																																																																																														self._interpreter = interpreter
																																																																																																																																																														self._creator = creator
																																																																																																																																																														self._seeder = seeder
																																																																																																																																																														self._activators = activators

																																																																																																																																																														@ property
																																																																																																																																																														def verbosity(self):
																																																																																																																																																														"" "The verbosity of the run." ""
																																																																																																																																																														return self._verbosity

																																																																																																																																																														@ property
																																																																																																																																																														def interpreter(self):
																																																																																																																																																														"" "Create a virtual environment based on this reference interpreter." ""
																																																																																																																																																														return self._interpreter

																																																																																																																																																														@ property
																																																																																																																																																														def creator(self):
																																																																																																																																																														"" "The creator used to build the virtual environment (must be compatible with the interpreter)." ""
																																																																																																																																																														return self._creator

																																																																																																																																																														@ property
																																																																																																																																																														def seeder(self):
																																																																																																																																																														"" "The mechanism used to provide the seed packages (pip, setuptools, wheel)." ""
																																																																																																																																																														return self._seeder

																																																																																																																																																														@ property
																																																																																																																																																														def activators(self):
																																																																																																																																																														"" "Activators used to generate activations scripts." ""
																																																																																																																																																														return self._activators

																																																																																																																																																														def run(self):
																																																																																																																																																														self._create()
																																																																																																																																																														self._seed()
																																																																																																																																																														self._activate()
																																																																																																																																																														self.creator.pyenv_cfg.write()

																																																																																																																																																														def _create(self):
																																																																																																																																																														LOGGER.info("create virtual environment via %s", self.creator)
																																																																																																																																																														self.creator.run()
																																																																																																																																																														LOGGER.debug(_DEBUG_MARKER)
																																																																																																																																																														LOGGER.debug("%s", _Debug(self.creator))

																																																																																																																																																														def _seed(self):
																																																																																																																																																														if self.seeder is not None and self.seeder.enabled:
																																																																																																																																																														LOGGER.info("add seed packages via %s", self.seeder)
																																																																																																																																																															self.seeder.run(self.creator)

																																																																																																																																																															def _activate(self):
																																																																																																																																																															if self.activators:
																																																																																																																																																															active = ", ".join(type(i).__name__.replace("Activator", "") for i in self.activators)
																																																																																																																																																																LOGGER.info("add activators for %s", active)
																																																																																																																																																																for activator in self.activators:
																																																																																																																																																																activator.generate(self.creator)

																																																																																																																																																																	def __enter__(self):
																																																																																																																																																																	return self

																																																																																																																																																																	def __exit__(self, exc_type, exc_val, exc_tb):
																																																																																																																																																																	self._app_data.close()


																																																																																																																																																																	_DEBUG_MARKER = "=" * 30 + " target debug " + "=" * 30


																																																																																																																																																																	class _Debug:
																																																																																																																																																																	"" "lazily populate debug." ""

																																																																																																																																																																	def __init__(self, creator)->None:
																																																																																																																																																																	self.creator = creator

																																																																																																																																																																	def __repr__(self)->str:
																																																																																																																																																																	return json.dumps(self.creator.debug, indent = 2)


																																																																																																																																																																	__all__ =[
																																																																																																																																																																		  "Session",
																																																																																																																																																																	]
																																																																																																																																																																	PK  5L  Z ! virtualenv / run / plugin / __init__.pyPK  5L  Z % ¬∂πªª
#virtualenv/run/plugin/activators.pyfrom __future__ import annotations

																																																																																																																																																																	from argparse import ArgumentTypeError
																																																																																																																																																																	from collections import OrderedDict

																																																																																																																																																																	from.base import ComponentBuilder


																																																																																																																																																																	class ActivationSelector(ComponentBuilder):
																																																																																																																																																																	def __init__(self, interpreter, parser)->None:
																																																																																																																																																																	self.default = None
																																																																																																																																																																	possible = OrderedDict(
																																																																																																																																																																			       (k, v) for k, v in self.options("virtualenv.activate").items() if v.supports(interpreter)
																																																																																																																																																																	)
																																																																																																																																																																		super().__init__(interpreter, parser, "activators", possible)
																																																																																																																																																																		self.parser.description = "options for activation scripts"
																																																																																																																																																																		self.active = None

																																																																																																																																																																		def add_selector_arg_parse(self, name, choices):
																																																																																																																																																																		self.default = ",".join(choices)
																																																																																																																																																																		self.parser.add_argument(
																																																																																																																																																																					 f "--{name}",
																																																																																																																																																																					 default = self.default,
																																																																																																																																																																					 metavar = "comma_sep_list",
																																																																																																																																																																					 required = False,
																																																																																																																																																																					 help = "activators to generate - default is all supported",
																																																																																																																																																																					 type = self._extract_activators,
																																																																																																																																																																		)

																																																																																																																																																																		def _extract_activators(self, entered_str):
																																																																																																																																																																		elements =[e.strip() for e in entered_str.split(",") if e.strip()]
																																																																																																																																																																			missing =[e for e in elements if e not in self.possible]
																																																																																																																																																																				if missing:
																																																																																																																																																																				msg = f "the following activators are not available {','.join(missing)}"
																																																																																																																																																																				raise ArgumentTypeError(msg)
																																																																																																																																																																					return elements

																																																																																																																																																																					def handle_selected_arg_parse(self, options):
																																																																																																																																																																					selected_activators = (
																																																																																																																																																																							       self._extract_activators(self.default) if options.activators is self.default
																																																																																																																																																																							       else
																																																																																																																																																																							       options.activators
																																																																																																																																																																					)
																																																																																																																																																																						self.active = {k:v for k, v in self.possible.items()
																																																																																																																																																																							if k in selected_activators}
																																																																																																																																																																							self.parser.add_argument(
																																																																																																																																																																										 "--prompt",
																																																																																																																																																																										 dest = "prompt",
																																																																																																																																																																										 metavar = "prompt",
																																																																																																																																																																										 help = (
																																																																																																																																																																											 "provides an alternative prompt prefix for this environment "
																																																																																																																																																																											 "(value of . means name of the current working directory)"
																																																																																																																																																																											 ),
																																																																																																																																																																										 default = None,
																																																																																																																																																																							)
																																																																																																																																																																								for activator in self.active.values()
																																																																																																																																																																									:
																																																																																																																																																																									activator.add_parser_arguments(self.parser, self.interpreter)

																																																																																																																																																																									def create(self, options):
																																																																																																																																																																									return[activator_class(options) for activator_class in self.active.values()]


																																																																																																																																																																										__all__ =[
																																																																																																																																																																											  "ActivationSelector",
																																																																																																																																																																										]
																																																																																																																																																																										PK  5L  Z ≈ @Ã˛0  0  virtualenv / run / plugin / base.pyfrom __future__ import annotations

																																																																																																																																																																										import sys
																																																																																																																																																																										from collections import OrderedDict
																																																																																																																																																																										from importlib.metadata import entry_points

																																																																																																																																																																										importlib_metadata_version = ()


																																																																																																																																																																										class PluginLoader:
																																																																																																																																																																										_OPTIONS = None
																																																																																																																																																																										_ENTRY_POINTS = None

																																																																																																																																																																										@ classmethod
																																																																																																																																																																										def entry_points_for(cls, key):
																																																																																																																																																																										if sys.version_info >= (3, 10)
																																																																																																																																																																											or importlib_metadata_version >= (3, 6):
																																																																																																																																																																											return OrderedDict((e.name, e.load()) for e in cls.entry_points().select(group = key))
																																																																																																																																																																													return OrderedDict((e.name, e.load()) for e in cls.entry_points().get(key, {}))

																																																																																																																																																																						@ staticmethod
																																																																																																																																																																						def entry_points():
																																																																																																																																																																						if PluginLoader._ENTRY_POINTS is None:
																																																																																																																																																																						PluginLoader._ENTRY_POINTS = entry_points()
																																																																																																																																																																							return PluginLoader._ENTRY_POINTS


																																																																																																																																																																							class ComponentBuilder(PluginLoader):
																																																																																																																																																																							def __init__(self, interpreter, parser, name, possible)->None:
																																																																																																																																																																							self.interpreter = interpreter
																																																																																																																																																																							self.name = name
																																																																																																																																																																							self._impl_class = None
																																																																																																																																																																							self.possible = possible
																																																																																																																																																																							self.parser = parser.add_argument_group(title = name)
																																																																																																																																																																							self.add_selector_arg_parse(name, list(self.possible))

																																																																																																																																																																							@ classmethod
																																																																																																																																																																							def options(cls, key):
																																																																																																																																																																							if cls._OPTIONS is None:
																																																																																																																																																																							cls._OPTIONS = cls.entry_points_for(key)
																																																																																																																																																																								return cls._OPTIONS

																																																																																																																																																																								def add_selector_arg_parse(self, name, choices):
																																																																																																																																																																								raise NotImplementedError

																																																																																																																																																																								def handle_selected_arg_parse(self, options):
																																																																																																																																																																								selected = getattr(options, self.name)
																																																																																																																																																																								if selected not in self.possible:
																																																																																																																																																																								msg = f "No implementation for {self.interpreter}"
																																																																																																																																																																								raise RuntimeError(msg)
																																																																																																																																																																									self._impl_class = self.possible[selected]
																																																																																																																																																																									self.populate_selected_argparse(selected, options.app_data)
																																																																																																																																																																									return selected

																																																																																																																																																																									def populate_selected_argparse(self, selected, app_data):
																																																																																																																																																																									self.parser.description = f "options for {self.name} {selected}"
																																																																																																																																																																									self._impl_class.add_parser_arguments(self.parser, self.interpreter, app_data)

																																																																																																																																																																									def create(self, options):
																																																																																																																																																																									return self._impl_class(options, self.interpreter)


																																																																																																																																																																									__all__ =[
																																																																																																																																																																										  "ComponentBuilder",
																																																																																																																																																																										  "PluginLoader",
																																																																																																																																																																									]
																																																																																																																																																																									PK  5L  Z Ë ‚/v * *!virtualenv / run / plugin / creators.pyfrom __future__ import annotations

																																																																																																																																																																									from collections import OrderedDict, defaultdict
																																																																																																																																																																											from typing import TYPE_CHECKING, NamedTuple

																																																																																																																																																																											from virtualenv.create.describe import Describe
																																																																																																																																																																											from virtualenv.create.via_global_ref.builtin.builtin_way import VirtualenvBuiltin

																																																																																																																																																																											from.base import ComponentBuilder

																																																																																																																																																																									if		TYPE_CHECKING:
																																																																																																																																																																											from virtualenv.create.creator import Creator, CreatorMeta


																																																																																																																																																																											class CreatorInfo(NamedTuple)
																																																																																																																																																																										:
																																																																																																																																																																												key_to_class:dict[str, type[Creator]]
																																																																																																																																																																												key_to_meta:dict[str, CreatorMeta]
																																																																																																																																																																												describe:type[Describe] | None
																																																																																																																																																																												builtin_key:str


																																																																																																																																																																												class CreatorSelector(ComponentBuilder):
																																																																																																																																																																												def __init__(self, interpreter, parser)->None:
																																																																																																																																																																												creators, self.key_to_meta, self.describe, self.builtin_key = self.for_interpreter(interpreter)
																																																																																																																																																																										super().__init__(interpreter, parser, "creator", creators)

																																																																																																																																																																										@ classmethod
																																																																																																																																																																										def for_interpreter(cls, interpreter):
																																																																																																																																																																										key_to_class,	key_to_meta, builtin_key, describe = OrderedDict(), {
																																																																																																																																																																										}	       , None, None
																																																																																																																																																																								errors = defaultdict(list)
																																																																																																																																																																						for key,	creator_class in cls.options("virtualenv.create")
																																																																																																																																																																							.		items():
																																																																																																																																																																							if		key == "builtin":
																																																																																																																																																																							msg = "builtin creator is a reserved name"
																																																																																																																																																																							raise RuntimeError(msg)
																																																																																																																																																																								meta = creator_class.can_create(interpreter)
																																																																																																																																																																								if meta:
																																																																																																																																																																								if meta.error:
																																																																																																																																																																								errors[meta.error]
																																																																																																																																																																									.append(creator_class)
																																																																																																																																																																									else
																																																																																																																																																																									:
																																																																																																																																																																									if "builtin" not in key_to_class and issubclass(creator_class, VirtualenvBuiltin)
																																																																																																																																																																										:
																																																																																																																																																																										builtin_key = key
																																																																																																																																																																										key_to_class["builtin"] = creator_class
																																																																																																																																																																										key_to_meta["builtin"] = meta
																																																																																																																																																																										key_to_class[key] = creator_class
																																																																																																																																																																										key_to_meta[key] = meta
																																																																																																																																																																										if describe is None and issubclass(creator_class, Describe)
																																																																																																																																																																											and creator_class.can_describe(interpreter):
																																																																																																																																																																											describe = creator_class
																																																																																																																																																																											if not key_to_meta:
																																																																																																																																																																											if errors:
																																																																																																																																																																											rows =[f "{k} for creators {', '.join(i.__name__ for i in v)}" for k, v in errors.items()]
																																																																																																																																																																												raise RuntimeError("\n".join(rows))
																																																																																																																																																																												msg = f "No virtualenv implementation for {interpreter}"
																																																																																																																																																																												raise RuntimeError(msg)
																																																																																																																																																																												return CreatorInfo(
																																																																																																																																																																														   key_to_class = key_to_class,
																																																																																																																																																																														   key_to_meta = key_to_meta,
																																																																																																																																																																														   describe = describe,
																																																																																																																																																																														   builtin_key = builtin_key,
																																																																																																																																																																												)

																																																																																																																																																																												def add_selector_arg_parse(self, name, choices):
#prefer the built-in venv if present, otherwise fallback to first defined type
																																																																																																																																																																												choices = sorted(choices, key = lambda a:0 if a == "builtin"
																																																																																																																																																																														 else
																																																																																																																																																																														 1)
																																																																																																																																																																													default_value = self._get_default(choices)
																																																																																																																																																																													self.parser.add_argument(
																																																																																																																																																																																 f "--{name}",
																																																																																																																																																																																 choices = choices,
																																																																																																																																																																																 default = default_value,
																																																																																																																																																																																 required = False,
																																																																																																																																																																																 help = f "create environment via{'' if self.builtin_key is None else f' (builtin = {self.builtin_key})'}",
																																																																																																																																																																													)

																																																																																																																																																																													@ staticmethod
																																																																																																																																																																													def _get_default(choices):
																																																																																																																																																																													return next(iter(choices))

																																																																																																																																																																													def populate_selected_argparse(self, selected, app_data):
																																																																																																																																																																													self.parser.description = f "options for {self.name} {selected}"
																																																																																																																																																																													self._impl_class.add_parser_arguments(self.parser, self.interpreter, self.key_to_meta[selected], app_data)

																																																																																																																																																																													def create(self, options):
																																																																																																																																																																													options.meta = self.key_to_meta[getattr(options, self.name)]
																																																																																																																																																																													if not issubclass(self._impl_class, Describe)
																																																																																																																																																																														:
																																																																																																																																																																														options.describe = self.describe(options, self.interpreter)
																																																																																																																																																																														return super().create(options)


																																																																																																																																																																														__all__ =[
																																																																																																																																																																															  "CreatorInfo",
																																																																																																																																																																															  "CreatorSelector",
																																																																																																																																																																														]
																																																																																																																																																																														PK  5L  Z ¨ ÉÚúú"virtualenv/run/plugin/discovery.pyfrom __future__ import annotations

																																																																																																																																																																														from.base import PluginLoader


																																																																																																																																																																														class Discovery(PluginLoader):
																																																																																																																																																																														"" "Discovery plugins." ""


																																																																																																																																																																														def get_discover(parser, args):
																																																																																																																																																																														discover_types = Discovery.entry_points_for("virtualenv.discovery")
																																																																																																																																																																														discovery_parser = parser.add_argument_group(
																																																																																																																																																																																			     title = "discovery",
																																																																																																																																																																																			     description = "discover and provide a target interpreter",
																																																																																																																																																																														)
																																																																																																																																																																														choices = _get_default_discovery(discover_types)
#prefer the builtin if present, otherwise fallback to first defined type
																																																																																																																																																																														choices = sorted(choices, key = lambda a:0 if a == "builtin"
																																																																																																																																																																																 else
																																																																																																																																																																																 1)
																																																																																																																																																																															discovery_parser.add_argument(
																																																																																																																																																																																		      "--discovery",
																																																																																																																																																																																		      choices = choices,
																																																																																																																																																																																		      default = next(iter(choices)),
																																																																																																																																																																																		      required = False,
																																																																																																																																																																																		      help = "interpreter discovery method",
																																																																																																																																																																															)
																																																																																																																																																																															options,	_ = parser.parse_known_args(args)
																																																																																																																																																																															discover_class = discover_types[options.discovery]
																																																																																																																																																																															discover_class.add_parser_arguments(discovery_parser)
																																																																																																																																																																															options,	_ = parser.parse_known_args(args, namespace = options)
																																																																																																																																																																															return discover_class(options)


																																																																																																																																																																															def _get_default_discovery(discover_types):
																																																																																																																																																																															return list(discover_types.keys())


																																																																																																																																																																															__all__ =[
																																																																																																																																																																																  "Discovery",
																																																																																																																																																																																  "get_discover",
																																																																																																																																																																															]
																																																																																																																																																																															PK  5L  Ze  ∏3  virtualenv / run / plugin / seeders.pyfrom __future__ import annotations

																																																																																																																																																																															from.base import ComponentBuilder


																																																																																																																																																																															class SeederSelector(ComponentBuilder):
																																																																																																																																																																															def __init__(self, interpreter, parser)->None:
																																																																																																																																																																															possible = self.options("virtualenv.seed")
																																																																																																																																																																															super().__init__(interpreter, parser, "seeder", possible)

																																																																																																																																																																															def add_selector_arg_parse(self, name, choices):
																																																																																																																																																																															self.parser.add_argument(
																																																																																																																																																																																		 f "--{name}",
																																																																																																																																																																																		 choices = choices,
																																																																																																																																																																																		 default = self._get_default(),
																																																																																																																																																																																		 required = False,
																																																																																																																																																																																		 help = "seed packages install method",
																																																																																																																																																																															)
																																																																																																																																																																															self.parser.add_argument(
																																																																																																																																																																																		 "--no-seed",
																																																																																																																																																																																		 "--without-pip",
																																																																																																																																																																																		 help = "do not install seed packages",
																																																																																																																																																																																		 action = "store_true",
																																																																																																																																																																																		 dest = "no_seed",
																																																																																																																																																																															)

																																																																																																																																																																															@ staticmethod
																																																																																																																																																																															def _get_default():
																																																																																																																																																																															return "app-data"

																																																																																																																																																																															def handle_selected_arg_parse(self, options):
																																																																																																																																																																															return super().handle_selected_arg_parse(options)

																																																																																																																																																																															def create(self, options):
																																																																																																																																																																															return self._impl_class(options)


																																																																																																																																																																															__all__ =[
																																																																																																																																																																																  "SeederSelector",
																																																																																																																																																																															]
																																																																																																																																																																															PK  5L  Z  virtualenv / seed / __init__.pyPK  5L  Z ó Ù˜
#ÉÉvirtualenv/seed/seeder.pyfrom __future__ import annotations

																																																																																																																																																																															from abc import ABC, abstractmethod


																																																																																																																																																																																	class Seeder(ABC):
																																																																																																																																																																																	"" "A seeder will install some seed packages into a virtual environment." ""

																																																																																																																																																																																	def __init__(self, options, enabled)->None:
																																																																																																																																																																																	"" "
																																																																																																																																																																																	Create.

																																																																																																																																																																															:		param options:the parsed options as defined within:meth:`add_parser_arguments `
																																																																																																																																																																															:		param enabled:a flag weather the seeder is enabled or not
																																																																																																																																																																																	"" "
																																																																																																																																																																																	self.enabled = enabled
																																																																																																																																																																															self.env = options.env

																																																																																																																																																																															@ classmethod
																																																																																																																																																																															def add_parser_arguments(cls, parser, interpreter, app_data):
																																																																																																																																																																															"" "
																																																																																																																																																																															Add CLI arguments for this seed mechanisms.

																																																																																																																																																																															:param parser:the CLI parser
																																																																																																																																																																															:param app_data:the CLI parser
																																																																																																																																																																															:param interpreter:the interpreter this virtual environment is based of
																																																																																																																																																																															"" "
																																																																																																																																																																															raise NotImplementedError

																																																																																																																																																																															@ abstractmethod
																																																																																																																																																																															def run(self, creator)
																																																																																																																																																																																:
																																																																																																																																																																																"" "
																																																																																																																																																																																Perform the seed operation.

																																																																																																																																																																																:param creator:the creator(based of:class:`virtualenv.create.creator.Creator `) we used to create this \
																																																																																																																																																																																virtual environment
																																																																																																																																																																																"" "
																																																																																																																																																																																raise NotImplementedError


																																																																																																																																																																																__all__ =[
																																																																																																																																																																																	  "Seeder",
																																																																																																																																																																																]
																																																																																																																																																																																PK  5L  Z ! virtualenv / seed / embed / __init__.pyPK  5L  Z \ 5 9863 ú{{
#virtualenv/seed/embed/base_embed.pyfrom __future__ import annotations

																																																																																																																																																																																	from abc import ABC
																																																																																																																																																																																	from pathlib import Path

																																																																																																																																																																																	from virtualenv.seed.seeder import Seeder
																																																																																																																																																																																	from virtualenv.seed.wheels import Version

																																																																																																																																																																																	PERIODIC_UPDATE_ON_BY_DEFAULT = True


																																																																																																																																																																																	class BaseEmbed(Seeder, ABC):
																																																																																																																																																																																	def __init__(self, options)->None:
																																																																																																																																																																																	super().__init__(options, enabled = options.no_seed is False)

																																																																																																																																																																																	self.download = options.download
																																																																																																																																																																																	self.extra_search_dir =[i.resolve() for i in options.extra_search_dir if i.exists()]

																																																																																																																																																																																		self.pip_version = options.pip
																																																																																																																																																																																		self.setuptools_version = options.setuptools
																																																																																																																																																																																		self.wheel_version = options.wheel

																																																																																																																																																																																		self.no_pip = options.no_pip
																																																																																																																																																																																		self.no_setuptools = options.no_setuptools
																																																																																																																																																																																		self.no_wheel = options.no_wheel
																																																																																																																																																																																		self.app_data = options.app_data
																																																																																																																																																																																		self.periodic_update = not options.no_periodic_update

																																																																																																																																																																																		if not self.distribution_to_versions()
																																																																																																																																																																																			:
																																																																																																																																																																																			self.enabled = False

																																																																																																																																																																																			@ classmethod
																																																																																																																																																																																			def distributions(cls)->dict[str, Version]:
																																																																																																																																																																																			return {
																																																																																																																																																																																			"pip":Version.bundle,
																																																																																																																																																																																			"setuptools":Version.bundle,
																																																																																																																																																																																			"wheel":Version.bundle,
																																																																																																																																																																																			}

																																																																																																																																																																																	def distribution_to_versions(self)->dict[str, str]:
																																																																																																																																																																																	return {
																																																																																																																																																																																		distribution:getattr(self, f "{distribution}_version")
																																																																																																																																																																																		for distribution in self.distributions()
																																																																																																																																																																																			if getattr(self, f "no_{distribution}")
																																																																																																																																																																																				is False and getattr(self, f "{distribution}_version") != "none"
																																																																																																																																																																																				}

																																																																																																																																																																																				@classmethod
																																																																																																																																																																																				def add_parser_arguments(cls, parser, interpreter, app_data):
#noqa: ARG003
																																																																																																																																																																																				group = parser.add_mutually_exclusive_group()
																																																																																																																																																																																				group.add_argument(
																																																																																																																																																																																						   "--no-download",
																																																																																																																																																																																						   "--never-download",
																																																																																																																																																																																						   dest = "download",
																																																																																																																																																																																						   action = "store_false",
																																																																																																																																																																																						   help = f "pass to disable download of the latest {'/'.join(cls.distributions())} from PyPI",
																																																																																																																																																																																						   default = True,
																																																																																																																																																																																				)
																																																																																																																																																																																				group.add_argument(
																																																																																																																																																																																						   "--download",
																																																																																																																																																																																						   dest = "download",
																																																																																																																																																																																						   action = "store_true",
																																																																																																																																																																																						   help = f "pass to enable download of the latest {'/'.join(cls.distributions())} from PyPI",
																																																																																																																																																																																						   default = False,
																																																																																																																																																																																				)
																																																																																																																																																																																				parser.add_argument(
																																																																																																																																																																																						    "--extra-search-dir",
																																																																																																																																																																																						    metavar = "d",
																																																																																																																																																																																						    type = Path,
																																																																																																																																																																																						    nargs = "+",
																																																																																																																																																																																						    help = "a path containing wheels to extend the internal wheel list (can be set 1+ times)",
																																																																																																																																																																																						    default =[],
																																																																																																																																																																																				)
																																																																																																																																																																																				for distribution, default in cls.distributions()
																																																																																																																																																																																					.items():
																																																																																																																																																																																					if interpreter.version_info[:2]
																																																																																																																																																																																						>=(3, 12) and distribution in {"wheel", "setuptools"}:
																																																																																																																																																																																		default = "none"
#noqa: PLW2901
																																																																																																																																																																																		parser.add_argument(
																																																																																																																																																																																				    f "--{distribution}",
																																																																																																																																																																																				    dest = distribution,
																																																																																																																																																																																				    metavar = "version",
																																																																																																																																																																																				    help = f "version of {distribution} to install as seed: embed, bundle, none or exact version",
																																																																																																																																																																																				    default = default,
																																																																																																																																																																																		)
																																																																																																																																																																																		for distribution in cls.distributions()
																																																																																																																																																																																			:
																																																																																																																																																																																			parser.add_argument(
																																																																																																																																																																																					    f "--no-{distribution}",
																																																																																																																																																																																					    dest = f "no_{distribution}",
																																																																																																																																																																																					    action = "store_true",
																																																																																																																																																																																					    help = f "do not install {distribution}",
																																																																																																																																																																																					    default = False,
																																																																																																																																																																																			)
																																																																																																																																																																																			parser.add_argument(
																																																																																																																																																																																					    "--no-periodic-update",
																																																																																																																																																																																					    dest = "no_periodic_update",
																																																																																																																																																																																					    action = "store_true",
																																																																																																																																																																																					    help = "disable the periodic (once every 14 days) update of the embedded wheels",
																																																																																																																																																																																					    default = not PERIODIC_UPDATE_ON_BY_DEFAULT,
																																																																																																																																																																																			)

																																																																																																																																																																																			def __repr__(self)->str:
																																																																																																																																																																																			result = self.__class__.__name__
																																																																																																																																																																																			result += "("
																																																																																																																																																																																			if self.extra_search_dir:
																																																																																																																																																																																			result += f "extra_search_dir={', '.join(str(i) for i in self.extra_search_dir)},"
																																																																																																																																																																																			result += f "download={self.download},"
																																																																																																																																																																																			for distribution in self.distributions()
																																																																																																																																																																																				:
																																																																																																																																																																																				if getattr(self, f "no_{distribution}")
																																																																																																																																																																																					:
																																																																																																																																																																																					continue
																																																																																																																																																																																					version = getattr(self, f "{distribution}_version", None)
																																																																																																																																																																																					if version == "none":
																																																																																																																																																																																					continue
																																																																																																																																																																																					ver = f "={version or 'latest'}"
																																																																																																																																																																																					result += f " {distribution}{ver},"
																																																																																																																																																																																					return result[:-1]
																																																																																																																																																																																						+")"


																																																																																																																																																																																						__all__ =[
																																																																																																																																																																																							  "BaseEmbed",
																																																																																																																																																																																						]
																																																																																																																																																																																						PK  5L  Z ⁄ èîœΩΩ
#virtualenv/seed/embed/pip_invoke.pyfrom __future__ import annotations

																																																																																																																																																																																						import logging
																																																																																																																																																																																						from contextlib import contextmanager
																																																																																																																																																																																						from subprocess import Popen

																																																																																																																																																																																						from virtualenv.discovery.cached_py_info import LogCmd
																																																																																																																																																																																						from virtualenv.seed.embed.base_embed import BaseEmbed
																																																																																																																																																																																						from virtualenv.seed.wheels import Version, get_wheel, pip_wheel_env_run

																																																																																																																																																																																						LOGGER = logging.getLogger(__name__)


																																																																																																																																																																																						class PipInvoke(BaseEmbed):
																																																																																																																																																																																						def __init__(self, options)->None:
																																																																																																																																																																																						super().__init__(options)

																																																																																																																																																																																						def run(self, creator):
																																																																																																																																																																																						if not self.enabled:
																																																																																																																																																																																						return
																																																																																																																																																																																						for_py_version = creator.interpreter.version_release_str
																																																																																																																																																																																						with self.get_pip_install_cmd(creator.exe, for_py_version)
																																																																																																																																																																																							as cmd:
																																																																																																																																																																																							env = pip_wheel_env_run(self.extra_search_dir, self.app_data, self.env)
																																																																																																																																																																																							self._execute(cmd, env)

																																																																																																																																																																																							@ staticmethod
																																																																																																																																																																																							def _execute(cmd, env):
																																																																																																																																																																																							LOGGER.debug("pip seed by running: %s", LogCmd(cmd, env))
																																																																																																																																																																																							process = Popen(cmd, env = env)
																																																																																																																																																																																							process.communicate()
																																																																																																																																																																																							if process.returncode != 0:
																																																																																																																																																																																							msg = f "failed seed with code {process.returncode}"
																																																																																																																																																																																							raise RuntimeError(msg)
																																																																																																																																																																																								return process

																																																																																																																																																																																								@ contextmanager
																																																																																																																																																																																								def get_pip_install_cmd(self, exe, for_py_version):
																																																																																																																																																																																								cmd =[str(exe), "-m", "pip", "-q", "install", "--only-binary", ":all:", "--disable-pip-version-check"]
																																																																																																																																																																																								if not self.download:
																																																																																																																																																																																								cmd.append("--no-index")
																																																																																																																																																																																									folders = set()
																																																																																																																																																																																									for dist, version in self.distribution_to_versions()
																																																																																																																																																																																										.items():
																																																																																																																																																																																										wheel = get_wheel(
																																																																																																																																																																																												  distribution = dist,
																																																																																																																																																																																												  version = version,
																																																																																																																																																																																												  for_py_version = for_py_version,
																																																																																																																																																																																												  search_dirs = self.extra_search_dir,
																																																																																																																																																																																												  download = False,
																																																																																																																																																																																												  app_data = self.app_data,
																																																																																																																																																																																												  do_periodic_update = self.periodic_update,
																																																																																																																																																																																												  env = self.env,
																																																																																																																																																																																										)
																																																																																																																																																																																										if wheel is None:
																																																																																																																																																																																										msg = f "could not get wheel for distribution {dist}"
																																																																																																																																																																																										raise RuntimeError(msg)
																																																																																																																																																																																											folders.add(str(wheel.path.parent))
																																																																																																																																																																																											cmd.append(Version.as_pip_req(dist, wheel.version))
																																																																																																																																																																																											for folder in sorted(folders)
																																																																																																																																																																																												:
																																																																																																																																																																																												cmd.extend(["--find-links", str(folder)])
																																																																																																																																																																																												yield cmd


																																																																																																																																																																																												__all__ =[
																																																																																																																																																																																													  "PipInvoke",
																																																																																																																																																																																												]
																																																																																																																																																																																												PK  5L  Z.virtualenv / seed / embed / via_app_data / __init__.pyPK  5L  Z  º…œ2 virtualenv / seed / embed / via_app_data / via_app_data.py "" "Bootstrap." ""

																																																																																																																																																																																												from __future__ import annotations

																																																																																																																																																																																												import logging
																																																																																																																																																																																												import sys
																																																																																																																																																																																												import traceback
																																																																																																																																																																																												from contextlib import contextmanager
																																																																																																																																																																																												from pathlib import Path
																																																																																																																																																																																												from subprocess import CalledProcessError
																																																																																																																																																																																												from threading import Lock, Thread

																																																																																																																																																																																												from virtualenv.info import fs_supports_symlink
																																																																																																																																																																																												from virtualenv.seed.embed.base_embed import BaseEmbed
																																																																																																																																																																																												from virtualenv.seed.wheels import get_wheel

																																																																																																																																																																																												from.pip_install.copy import CopyPipInstall
																																																																																																																																																																																												from.pip_install.symlink import SymlinkPipInstall

																																																																																																																																																																																												LOGGER = logging.getLogger(__name__)


																																																																																																																																																																																												class FromAppData(BaseEmbed):
																																																																																																																																																																																												def __init__(self, options)->None:
																																																																																																																																																																																												super().__init__(options)
																																																																																																																																																																																												self.symlinks = options.symlink_app_data

																																																																																																																																																																																												@ classmethod
																																																																																																																																																																																												def add_parser_arguments(cls, parser, interpreter, app_data):
																																																																																																																																																																																												super().add_parser_arguments(parser, interpreter, app_data)
																																																																																																																																																																																												can_symlink = app_data.transient is False and fs_supports_symlink()
																																																																																																																																																																																												sym = "" if can_symlink
																																																																																																																																																																																												else
																																																																																																																																																																																												"not supported - "
																																																																																																																																																																																												parser.add_argument(
																																																																																																																																																																																														    "--symlink-app-data",
																																																																																																																																																																																														    dest = "symlink_app_data",
																																																																																																																																																																																														    action = "store_true" if can_symlink
																																																																																																																																																																																														    else
																																																																																																																																																																																														    "store_false",
																																																																																																																																																																																														    help = f "{sym} symlink the python packages from the app-data folder (requires seed pip>=19.3)",
																																																																																																																																																																																														    default = False,
																																																																																																																																																																																												)

																																																																																																																																																																																													def run(self, creator):
																																																																																																																																																																																													if not self.enabled:
																																																																																																																																																																																													return
																																																																																																																																																																																													with self._get_seed_wheels(creator)
																																																																																																																																																																																														as name_to_whl:
																																																																																																																																																																																														pip_version = name_to_whl["pip"].version_tuple if "pip" in name_to_whl
																																																																																																																																																																																														else
																																																																																																																																																																																														None
																																																																																																																																																																																														installer_class = self.installer_class(pip_version)
																																																																																																																																																																																															exceptions = {}

																																																																																																																																																																																		def _install(name, wheel):
																																																																																																																																																																																		try:
																																																																																																																																																																																		LOGGER.debug("install %s from wheel %s via %s", name, wheel, installer_class.__name__)
																																																																																																																																																																																		key = Path(installer_class.__name__) / wheel.path.stem
																																																																																																																																																																																		wheel_img = self.app_data.wheel_image(creator.interpreter.version_release_str, key)
																																																																																																																																																																																		installer = installer_class(wheel.path, creator, wheel_img)
																																																																																																																																																																																		parent = self.app_data.lock / wheel_img.parent
																																																																																																																																																																																		with parent.non_reentrant_lock_for_key(wheel_img.name):
																																																																																																																																																																																		if not installer.has_image()
																																																																																																																																																																																			:
																																																																																																																																																																																			installer.build_image()
																																																																																																																																																																																			installer.install(creator.interpreter.version_info)
																																																																																																																																																																																			except Exception:
#noqa: BLE001
																																																																																																																																																																																			exceptions[name] = sys.exc_info()

																																																																																																																																																																																			threads =[Thread(target = _install, args = (n, w)) for n, w in name_to_whl.items()]
																																																																																																																																																																																				for thread in threads:
																																																																																																																																																																																				thread.start()
																																																																																																																																																																																					for thread in threads:
																																																																																																																																																																																					thread.join()
																																																																																																																																																																																						if exceptions:
																																																																																																																																																																																						messages =[f "failed to build image {', '.join(exceptions.keys())} because:"]
																																																																																																																																																																																							for value in exceptions.values()
																																																																																																																																																																																								:
																																																																																																																																																																																								exc_type, exc_value, exc_traceback = value
																																																																																																																																																																																								messages.append("".join(traceback.format_exception(exc_type, exc_value, exc_traceback)))
																																																																																																																																																																																								raise RuntimeError("\n".join(messages))

																																																																																																																																																																																								@ contextmanager
																																																																																																																																																																																								def _get_seed_wheels(self, creator):
#noqa: C901
																																																																																																																																																																																								name_to_whl, lock, fail = {}, Lock(), {}

																																																																																																																																																																																								def _get(distribution, version):
																																																																																																																																																																																								for_py_version = creator.interpreter.version_release_str
																																																																																																																																																																																								failure, result = None, None
#fallback to download in case the exact version is not available
																																																																																																																																																																																								for download in[True]
																																																																																																																																																																																									if self.download
																																																																																																																																																																																									else
																																																																																																																																																																																									[False, True]
																																																																																																																																																																																										:
																																																																																																																																																																																										failure = None
																																																																																																																																																																																										try:
																																																																																																																																																																																										result = get_wheel(
																																																																																																																																																																																												   distribution = distribution,
																																																																																																																																																																																												   version = version,
																																																																																																																																																																																												   for_py_version = for_py_version,
																																																																																																																																																																																												   search_dirs = self.extra_search_dir,
																																																																																																																																																																																												   download = download,
																																																																																																																																																																																												   app_data = self.app_data,
																																																																																																																																																																																												   do_periodic_update = self.periodic_update,
																																																																																																																																																																																												   env = self.env,
																																																																																																																																																																																										)
																																																																																																																																																																																										if result is not None:
																																																																																																																																																																																										break
																																																																																																																																																																																										except Exception as exception:
																																																																																																																																																																																										LOGGER.exception("fail")
																																																																																																																																																																																											failure = exception
																																																																																																																																																																																											if failure:
																																																																																																																																																																																											if isinstance(failure, CalledProcessError)
																																																																																																																																																																																												:
																																																																																																																																																																																												msg = f "failed to download {distribution}"
																																																																																																																																																																																												if version is not None:
																																																																																																																																																																																												msg += f " version {version}"
																																																																																																																																																																																												msg += f ", pip download exit code {failure.returncode}"
																																																																																																																																																																																												output = failure.output + failure.stderr
																																																																																																																																																																																												if output:
																																																																																																																																																																																												msg += "\n"
																																																																																																																																																																																												msg += output
																																																																																																																																																																																												else
																																																																																																																																																																																												:
																																																																																																																																																																																												msg = repr(failure)
																																																																																																																																																																																													LOGGER.error(msg)
																																																																																																																																																																																													with lock:
																																																																																																																																																																																													fail[distribution] = version
																																																																																																																																																																																													else
																																																																																																																																																																																													:
																																																																																																																																																																																													with lock:
																																																																																																																																																																																													name_to_whl[distribution] = result

																																																																																																																																																																																													threads =[
																																																																																																																																																																																														  Thread(target = _get, args = (distribution, version))
																																																																																																																																																																																														  for distribution, version in self.distribution_to_versions().items()
																																																																																																																																																																																													]
																																																																																																																																																																																														for thread in threads:
																																																																																																																																																																																														thread.start()
																																																																																																																																																																																															for thread in threads:
																																																																																																																																																																																															thread.join()
																																																																																																																																																																																																if fail:
																																																																																																																																																																																																msg = f "seed failed due to failing to download wheels {', '.join(fail.keys())}"
																																																																																																																																																																																																raise RuntimeError(msg)
																																																																																																																																																																																																	yield name_to_whl

																																																																																																																																																																																																	def installer_class(self, pip_version_tuple):
																																																																																																																																																																																																	if self.symlinks and pip_version_tuple and pip_version_tuple >= (19, 3)
																																																																																																																																																																																																		:
#symlink support requires pip 19.3+
																																																																																																																																																																																																		return SymlinkPipInstall
																																																																																																																																																																																																		return CopyPipInstall

																																																																																																																																																																																																		def __repr__(self)->str:
																																																																																																																																																																																																		msg = f ", via={'symlink' if self.symlinks else 'copy'}, app_data_dir={self.app_data}"
																																																																																																																																																																																																		base = super().__repr__()
																																																																																																																																																																																																		return f "{base[:-1]}{msg}{base[-1]}"


																																																																																																																																																																																																		__all__ =[
																																																																																																																																																																																																			  "FromAppData",
																																																																																																																																																																																																		]
																																																																																																																																																																																																		PK  5L  Z:virtualenv / seed / embed / via_app_data / pip_install / __init__.pyPK  5L  Z Ã ˇÑÚêê6 virtualenv / seed / embed / via_app_data / pip_install / base.pyfrom __future__ import annotations

																																																																																																																																																																																																		import logging
																																																																																																																																																																																																		import os
																																																																																																																																																																																																		import re
																																																																																																																																																																																																		import zipfile
																																																																																																																																																																																																		from abc import ABC, abstractmethod
																																																																																																																																																																																																		from configparser import ConfigParser
																																																																																																																																																																																																		from itertools import chain
																																																																																																																																																																																																		from pathlib import Path
																																																																																																																																																																																																		from tempfile import mkdtemp

																																																																																																																																																																																																		from distlib.scripts import ScriptMaker, enquote_executable

																																																																																																																																																																																																		from virtualenv.util.path import safe_delete

																																																																																																																																																																																																		LOGGER = logging.getLogger(__name__)


																																																																																																																																																																																																		class PipInstall(ABC):
																																																																																																																																																																																																		def __init__(self, wheel, creator, image_folder)->None:
																																																																																																																																																																																																		self._wheel = wheel
																																																																																																																																																																																																		self._creator = creator
																																																																																																																																																																																																		self._image_dir = image_folder
																																																																																																																																																																																																		self._extracted = False
																																																																																																																																																																																																		self.__dist_info = None
																																																																																																																																																																																																		self._console_entry_points = None

																																																																																																																																																																																																		@ abstractmethod
																																																																																																																																																																																																		def _sync(self, src, dst):
																																																																																																																																																																																																		raise NotImplementedError

																																																																																																																																																																																																		def install(self, version_info):
																																																																																																																																																																																																		self._extracted = True
																																																																																																																																																																																																		self._uninstall_previous_version()
#sync image
																																																																																																																																																																																																		for filename in self._image_dir.iterdir()
																																																																																																																																																																																																			:
																																																																																																																																																																																																			into = self._creator.purelib / filename.name
																																																																																																																																																																																																			self._sync(filename, into)
#generate console executables
																																																																																																																																																																																																			consoles = set()
																																																																																																																																																																																																			script_dir = self._creator.script_dir
																																																																																																																																																																																																			for name, module in self._console_scripts.items()
																																																																																																																																																																																																				:
																																																																																																																																																																																																				consoles.update(self._create_console_entry_point(name, module, script_dir, version_info))
																																																																																																																																																																																																				LOGGER.debug("generated console scripts %s", " ".join(i.name for i in consoles))

																																																																																																																																																																																																					def build_image(self):
#1. first extract the wheel
																																																																																																																																																																																																					LOGGER.debug("build install image for %s to %s", self._wheel.name, self._image_dir)
																																																																																																																																																																																																					with zipfile.ZipFile(str(self._wheel)) as zip_ref:
																																																																																																																																																																																																					self._shorten_path_if_needed(zip_ref)
																																																																																																																																																																																																					zip_ref.extractall(str(self._image_dir))
																																																																																																																																																																																																					self._extracted = True
#2. now add additional files not present in the distribution
																																																																																																																																																																																																					new_files = self._generate_new_files()
#3. finally fix the records file
																																																																																																																																																																																																					self._fix_records(new_files)

																																																																																																																																																																																																					def _shorten_path_if_needed(self, zip_ref):
																																																																																																																																																																																																					if os.name == "nt":
																																																																																																																																																																																																					to_folder = str(self._image_dir)
#https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation
																																																																																																																																																																																																						zip_max_len = max(len(i) for i in zip_ref.namelist())
																																																																																																																																																																																																							path_len = zip_max_len + len(to_folder)
																																																																																																																																																																																																							if path_len > 260:
#noqa: PLR2004
																																																																																																																																																																																																							self._image_dir.mkdir(exist_ok = True)
#to get a short path must exist

																																																																																																																																																																																																								from virtualenv.util.path import get_short_path_name
#noqa: PLC0415

																																																																																																																																																																																																								to_folder = get_short_path_name(to_folder)
																																																																																																																																																																																																								self._image_dir = Path(to_folder)

																																																																																																																																																																																																								def _records_text(self, files):
																																																																																																																																																																																																								return "\n".join(f "{os.path.relpath(str(rec), str(self._image_dir))},," for rec in files)

																																																																																																																																																																																																									def _generate_new_files(self):
																																																																																																																																																																																																									new_files = set()
																																																																																																																																																																																																									installer = self._dist_info / "INSTALLER"
																																																																																																																																																																																																									installer.write_text("pip\n", encoding = "utf-8")
																																																																																																																																																																																																									new_files.add(installer)
#inject a no-op root element, as workaround for bug in https://github.com/pypa/pip/issues/7226
																																																																																																																																																																																																									marker = self._image_dir / f "{self._dist_info.stem}.virtualenv"
																																																																																																																																																																																																									marker.write_text("", encoding = "utf-8")
																																																																																																																																																																																																									new_files.add(marker)
																																																																																																																																																																																																									folder = mkdtemp()
																																																																																																																																																																																																									try:
																																																																																																																																																																																																									to_folder = Path(folder)
																																																																																																																																																																																																									rel = os.path.relpath(str(self._creator.script_dir), str(self._creator.purelib))
																																																																																																																																																																																																									version_info = self._creator.interpreter.version_info
																																																																																																																																																																																																									for name, module in self._console_scripts.items()
																																																																																																																																																																																																										:
																																																																																																																																																																																																										new_files.update(
																																																																																																																																																																																																												 Path(os.path.normpath(str(self._image_dir / rel / i.name)))
																																																																																																																																																																																																												 for i in self._create_console_entry_point(name, module, to_folder, version_info)
																																																																																																																																																																																																										)
																																																																																																																																																																																																											finally:
																																																																																																																																																																																																											safe_delete(folder)
																																																																																																																																																																																																											return new_files

																																																																																																																																																																																																											@ property
																																																																																																																																																																																																											def _dist_info(self):
																																																																																																																																																																																																											if self._extracted is False:
																																																																																																																																																																																																											return None
#pragma: no cover
																																																																																																																																																																																																											if self.__dist_info is None:
																																																																																																																																																																																																											files =[]
																																																																																																																																																																																																												for filename in self._image_dir.iterdir()
																																																																																																																																																																																																													:
																																																																																																																																																																																																													files.append(filename.name)
																																																																																																																																																																																																													if filename.suffix == ".dist-info":
																																																																																																																																																																																																													self.__dist_info = filename
																																																																																																																																																																																																													break
																																																																																																																																																																																																													else
																																																																																																																																																																																																													:
																																																																																																																																																																																																													msg = f "no .dist-info at {self._image_dir}, has {', '.join(files)}"
																																																																																																																																																																																																													raise RuntimeError(msg)
#pragma: no cover
																																																																																																																																																																																																														return self.__dist_info

																																																																																																																																																																																																														@ abstractmethod
																																																																																																																																																																																																														def _fix_records(self, extra_record_data):
																																																																																																																																																																																																														raise NotImplementedError

																																																																																																																																																																																																														@ property
																																																																																																																																																																																																														def _console_scripts(self):
																																																																																																																																																																																																														if self._extracted is False:
																																																																																																																																																																																																														return None
#pragma: no cover
																																																																																																																																																																																																														if self._console_entry_points is None:
																																																																																																																																																																																																														self._console_entry_points = {}
																																																																																																																																																																																		entry_points = self._dist_info / "entry_points.txt"
																																																																																																																																																																																								if entry_points.exists()
																																																																																																																																																																																									:
																																																																																																																																																																																									parser = ConfigParser()
																																																																																																																																																																																									with entry_points.open(encoding = "utf-8") as file_handler:
																																																																																																																																																																																									parser.read_file(file_handler)
																																																																																																																																																																																									if "console_scripts" in parser.sections()
																																																																																																																																																																																										:
																																																																																																																																																																																										for name, value in parser.items("console_scripts")
																																																																																																																																																																																											:
																																																																																																																																																																																											match = re.match(r "(.*?)-?\d\.?\d*", name)
																																																																																																																																																																																											our_name = match.groups(1)[0] if match
																																																																																																																																																																																											else
																																																																																																																																																																																											name
																																																																																																																																																																																											self._console_entry_points[our_name]
																																																																																																																																																																																												= value
																																																																																																																																																																																												return self._console_entry_points

																																																																																																																																																																																												def _create_console_entry_point(self, name, value, to_folder, version_info):
																																																																																																																																																																																												result =[]
																																																																																																																																																																																												maker = ScriptMakerCustom(to_folder, version_info, self._creator.exe, name)
																																																																																																																																																																																												specification = f "{name} = {value}"
																																																																																																																																																																																												new_files = maker.make(specification)
																																																																																																																																																																																												result.extend(Path(i) for i in new_files)
																																																																																																																																																																																													return result

																																																																																																																																																																																													def _uninstall_previous_version(self):
																																																																																																																																																																																													dist_name = self._dist_info.stem.split("-")[0]
																																																																																																																																																																																													in_folders = chain.from_iterable([i.iterdir() for i in(self._creator.purelib, self._creator.platlib)])
																																																																																																																																																																																														paths = (p for p in in_folders if p.stem.split("-")[0] == dist_name and p.suffix == ".dist-info" and p.is_dir())
																																																																																																																																																																																															existing_dist = next(paths, None)
																																																																																																																																																																																															if existing_dist is not None:
																																																																																																																																																																																															self._uninstall_dist(existing_dist)

																																																																																																																																																																																																@staticmethod
																																																																																																																																																																																																def _uninstall_dist(dist):
																																																																																																																																																																																																dist_base = dist.parent
																																																																																																																																																																																																LOGGER.debug("uninstall existing distribution %s from %s", dist.stem, dist_base)

																																																																																																																																																																																																top_txt = dist / "top_level.txt"
#add top level packages at folder level
																																																																																																																																																																																																paths = (
																																																																																																																																																																																																	 {dist.parent / i.strip() for i in top_txt.read_text(encoding = "utf-8")
																																																																																																																																																																																																	.splitlines()}
																																																																																																																																																																																																	if top_txt.exists()
																																																																																																																																																																																																		else
																																																																																																																																																																																																		set()
																																																																																																																																																																																																		)
																																																																																																																																																																																																		paths.add(dist)
#add the dist-info folder itself

																																																																																																																																																																																																		base_dirs, record = paths.copy(), dist / "RECORD"
#collect entries in record that we did not register yet
																																																																																																																																																																																																		for name in(
																																																																																																																																																																																																			    (i.split(",")[0] for i in record.read_text(encoding = "utf-8").splitlines()) if record.exists()
																																																																																																																																																																																																			    else
																																																																																																																																																																																																			    ()
																																																																																																																																																																																																		)
																																																																																																																																																																																																			:
																																																																																																																																																																																																			path = dist_base / name
																																																																																																																																																																																																			if not any(p in base_dirs for p in path.parents)
																																																																																																																																																																																																				:
#only add if not already added as a base dir
																																																																																																																																																																																																				paths.add(path)

																																																																																																																																																																																																				for path in sorted(paths)
																																																																																																																																																																																																					:
#actually remove stuff in a stable order
																																																																																																																																																																																																					if path.exists()
																																																																																																																																																																																																						:
																																																																																																																																																																																																						if path.is_dir()
																																																																																																																																																																																																							and not path.is_symlink():
																																																																																																																																																																																																							safe_delete(path)
																																																																																																																																																																																																							else
																																																																																																																																																																																																							:
																																																																																																																																																																																																							path.unlink()

																																																																																																																																																																																																							def clear(self):
																																																																																																																																																																																																							if self._image_dir.exists()
																																																																																																																																																																																																								:
																																																																																																																																																																																																								safe_delete(self._image_dir)

																																																																																																																																																																																																								def has_image(self):
																																																																																																																																																																																																								return self._image_dir.exists() and next(self._image_dir.iterdir()) is not None


																																																																																																																																																																																																								class ScriptMakerCustom(ScriptMaker):
																																																																																																																																																																																																								def __init__(self, target_dir, version_info, executable, name)->None:
																																																																																																																																																																																																								super().__init__(None, str(target_dir))
																																																																																																																																																																																																								self.clobber = True
#overwrite
																																																																																																																																																																																																								self.set_mode = True
#ensure they are executable
																																																																																																																																																																																																								self.executable = enquote_executable(str(executable))
																																																																																																																																																																																																								self.version_info = version_info.major, version_info.minor
																																																																																																																																																																																																								self.variants = {"", "X", "X.Y"}
																																																																																																																																																																																																self._name = name

																																																																																																																																																																																																def _write_script(self, names, shebang, script_bytes, filenames, ext):
																																																																																																																																																																																																names.add(f "{self._name}{self.version_info[0]}.{self.version_info[1]}")
																																																																																																																																																																																																super()._write_script(names, shebang, script_bytes, filenames, ext)


																																																																																																																																																																																																__all__ =[
																																																																																																																																																																																																	  "PipInstall",
																																																																																																																																																																																																]
																																																																																																																																																																																																PK  5L  Z < ‘/  6 virtualenv / seed / embed / via_app_data / pip_install / copy.pyfrom __future__ import annotations

																																																																																																																																																																																																import os
																																																																																																																																																																																																from pathlib import Path

																																																																																																																																																																																																from virtualenv.util.path import copy

																																																																																																																																																																																																from.base import PipInstall


																																																																																																																																																																																																class CopyPipInstall(PipInstall):
																																																																																																																																																																																																def _sync(self, src, dst):
																																																																																																																																																																																																copy(src, dst)

																																																																																																																																																																																																def _generate_new_files(self):
#create the pyc files
																																																																																																																																																																																																new_files = super()._generate_new_files()
																																																																																																																																																																																																new_files.update(self._cache_files())
																																																																																																																																																																																																return new_files

																																																																																																																																																																																																def _cache_files(self):
																																																																																																																																																																																																version = self._creator.interpreter.version_info
																																																																																																																																																																																																py_c_ext = f ".{self._creator.interpreter.implementation.lower()}-{version.major}{version.minor}.pyc"
																																																																																																																																																																																																for root, dirs, files in os.walk(str(self._image_dir), topdown = True)
																																																																																																																																																																																																	:
																																																																																																																																																																																																	root_path = Path(root)
																																																																																																																																																																																																	for name in files:
																																																																																																																																																																																																	if name.endswith(".py")
																																																																																																																																																																																																		:
																																																																																																																																																																																																		yield root_path / f "{name[:-3]}{py_c_ext}"
																																																																																																																																																																																																		for name in dirs:
																																																																																																																																																																																																		yield root_path / name / "__pycache__"

																																																																																																																																																																																																		def _fix_records(self, new_files)
																																																																																																																																																																																																			:
																																																																																																																																																																																																			extra_record_data_str = self._records_text(new_files)
																																																																																																																																																																																																			with(self._dist_info / "RECORD").open("ab") as file_handler:
																																																																																																																																																																																																			file_handler.write(extra_record_data_str.encode("utf-8"))


																																																																																																																																																																																																			__all__ =[
																																																																																																																																																																																																				  "CopyPipInstall",
																																																																																																																																																																																																			]
																																																																																																																																																																																																			PK  5L  ZN  ¶ˆﬂﬂ9 virtualenv / seed / embed / via_app_data / pip_install / symlink.pyfrom __future__ import annotations

																																																																																																																																																																																																			import os
																																																																																																																																																																																																			from stat import S_IREAD, S_IRGRP, S_IROTH
																																																																																																																																																																																																			from subprocess import PIPE, Popen

																																																																																																																																																																																																			from virtualenv.util.path import safe_delete, set_tree

																																																																																																																																																																																																			from.base import PipInstall


																																																																																																																																																																																																			class SymlinkPipInstall(PipInstall):
																																																																																																																																																																																																			def _sync(self, src, dst):
																																																																																																																																																																																																			os.symlink(str(src), str(dst))

																																																																																																																																																																																																			def _generate_new_files(self):
#create the pyc files, as the build image will be R/O
																																																																																																																																																																																																			cmd =[str(self._creator.exe), "-m", "compileall", str(self._image_dir)]
																																																																																																																																																																																																			process = Popen(cmd, stdout = PIPE, stderr = PIPE)
																																																																																																																																																																																																			process.communicate()
#the root pyc is shared, so we'll not symlink that - but still add the pyc files to the RECORD for close
																																																																																																																																																																																																			root_py_cache = self._image_dir / "__pycache__"
																																																																																																																																																																																																			new_files = set()
																																																																																																																																																																																																			if root_py_cache.exists()
																																																																																																																																																																																																				:
																																																																																																																																																																																																				new_files.update(root_py_cache.iterdir())
																																																																																																																																																																																																				new_files.add(root_py_cache)
																																																																																																																																																																																																				safe_delete(root_py_cache)
																																																																																																																																																																																																				core_new_files = super()._generate_new_files()
#remove files that are within the image folder deeper than one level (as these will be not linked directly)
																																																																																																																																																																																																				for file in core_new_files:
																																																																																																																																																																																																				try:
																																																																																																																																																																																																				rel = file.relative_to(self._image_dir)
																																																																																																																																																																																																					if len(rel.parts)
																																																																																																																																																																																																						>1:
																																																																																																																																																																																																						continue
																																																																																																																																																																																																						except ValueError:
																																																																																																																																																																																																						pass
																																																																																																																																																																																																						new_files.add(file)
																																																																																																																																																																																																						return new_files

																																																																																																																																																																																																						def _fix_records(self, new_files):
																																																																																																																																																																																																						new_files.update(i for i in self._image_dir.iterdir())
																																																																																																																																																																																																							extra_record_data_str = self._records_text(sorted(new_files, key = str))
																																																																																																																																																																																																							(self._dist_info / "RECORD").write_text(extra_record_data_str, encoding = "utf-8")

																																																																																																																																																																																																							def build_image(self):
																																																																																																																																																																																																							super().build_image()
#protect the image by making it read only
																																																																																																																																																																																																							set_tree(self._image_dir, S_IREAD | S_IRGRP | S_IROTH)

																																																																																																																																																																																																							def clear(self):
																																																																																																																																																																																																							if self._image_dir.exists()
																																																																																																																																																																																																								:
																																																																																																																																																																																																								safe_delete(self._image_dir)
																																																																																																																																																																																																								super().clear()


																																																																																																																																																																																																								__all__ =[
																																																																																																																																																																																																									  "SymlinkPipInstall",
																																																																																																																																																																																																								]
																																																																																																																																																																																																								PK  5L  Zx í Æx ÃÃ "virtualenv/seed/wheels/__init__.pyfrom __future__ import annotations

																																																																																																																																																																																																								from.acquire import get_wheel, pip_wheel_env_run
																																																																																																																																																																																																								from.util import Version, Wheel

																																																																																																																																																																																																								__all__ =[
																																																																																																																																																																																																									  "Version",
																																																																																																																																																																																																									  "Wheel",
																																																																																																																																																																																																									  "get_wheel",
																																																																																																																																																																																																									  "pip_wheel_env_run",
																																																																																																																																																																																																								]
																																																																																																																																																																																																								PK  5L  Z ê ÊE Ï Ï!virtualenv / seed / wheels / acquire.py "" "Bootstrap." ""

																																																																																																																																																																																																								from __future__ import annotations

																																																																																																																																																																																																								import logging
																																																																																																																																																																																																								import sys
																																																																																																																																																																																																								from operator import eq, lt
																																																																																																																																																																																																								from pathlib import Path
																																																																																																																																																																																																								from subprocess import PIPE, CalledProcessError, Popen

																																																																																																																																																																																																								from.bundle import from_bundle
																																																																																																																																																																																																								from.periodic_update import add_wheel_to_update_log
																																																																																																																																																																																																								from.util import Version, Wheel, discover_wheels

																																																																																																																																																																																																								LOGGER = logging.getLogger(__name__)


																																																																																																																																																																																																								def get_wheel(
#noqa: PLR0913
																																																																																																																																																																																																									      distribution,
																																																																																																																																																																																																									      version,
																																																																																																																																																																																																									      for_py_version,
																																																																																																																																																																																																									      search_dirs,
																																																																																																																																																																																																									      download,
																																																																																																																																																																																																									      app_data,
																																																																																																																																																																																																									      do_periodic_update,
																																																																																																																																																																																																									      env,
																																																																																																																																																																																																								):
																																																																																																																																																																																																								"" "Get a wheel with the given distribution-version-for_py_version trio, by using the extra search dir + download." ""
#not all wheels are compatible with all python versions, so we need to py version qualify it
																																																																																																																																																																																																								wheel = None

																																																																																																																																																																																																								if not download or version != Version.bundle:
#1. acquire from bundle
																																																																																																																																																																																																								wheel = from_bundle(distribution, version, for_py_version, search_dirs, app_data, do_periodic_update, env)

																																																																																																																																																																																																									if download and wheel is None and version != Version.embed:
#2. download from the internet
																																																																																																																																																																																																									wheel = download_wheel(
																																																																																																																																																																																																											       distribution = distribution,
																																																																																																																																																																																																											       version_spec = Version.as_version_spec(version),
																																																																																																																																																																																																											       for_py_version = for_py_version,
																																																																																																																																																																																																											       search_dirs = search_dirs,
																																																																																																																																																																																																											       app_data = app_data,
																																																																																																																																																																																																											       to_folder = app_data.house,
																																																																																																																																																																																																											       env = env,
																																																																																																																																																																																																									)
																																																																																																																																																																																																										if wheel is not None and app_data.can_update:
																																																																																																																																																																																																										add_wheel_to_update_log(wheel, for_py_version, app_data)

																																																																																																																																																																																																											return wheel


																																																																																																																																																																																																											def download_wheel(distribution, version_spec, for_py_version, search_dirs, app_data, to_folder, env):
#noqa: PLR0913
																																																																																																																																																																																																											to_download = f "{distribution}{version_spec or ''}"
																																																																																																																																																																																																											LOGGER.debug("download wheel %s %s to %s", to_download, for_py_version, to_folder)
																																																																																																																																																																																																											cmd =[
																																																																																																																																																																																																											      sys.executable,
																																																																																																																																																																																																											      "-m",
																																																																																																																																																																																																											      "pip",
																																																																																																																																																																																																											      "download",
																																																																																																																																																																																																											      "--progress-bar",
																																																																																																																																																																																																											      "off",
																																																																																																																																																																																																											      "--disable-pip-version-check",
																																																																																																																																																																																																											      "--only-binary=:all:",
																																																																																																																																																																																																											      "--no-deps",
																																																																																																																																																																																																											      "--python-version",
																																																																																																																																																																																																											      for_py_version,
																																																																																																																																																																																																											      "-d",
																																																																																																																																																																																																											      str(to_folder),
																																																																																																																																																																																																											      to_download,
																																																																																																																																																																																																											]
#pip has no interface in python - must be a new sub-process
																																																																																																																																																																																																											env = pip_wheel_env_run(search_dirs, app_data, env)
																																																																																																																																																																																																											process = Popen(cmd, env = env, stdout = PIPE, stderr = PIPE, universal_newlines = True, encoding = "utf-8")
																																																																																																																																																																																																											out, err = process.communicate()
																																																																																																																																																																																																											if process.returncode != 0:
																																																																																																																																																																																																											kwargs = {"output":out, "stderr":err}
																																																																																																																																																																																																raise CalledProcessError(process.returncode, cmd, **kwargs)
																																																																																																																																																																																																	result = _find_downloaded_wheel(distribution, version_spec, for_py_version, to_folder, out)
																																																																																																																																																																																																	LOGGER.debug("downloaded wheel %s", result.name)
																																																																																																																																																																																																	return result


																																																																																																																																																																																																	def _find_downloaded_wheel(distribution, version_spec, for_py_version, to_folder, out):
																																																																																																																																																																																																	for line in out.splitlines()
																																																																																																																																																																																																		:
																																																																																																																																																																																																		stripped_line = line.lstrip()
																																																																																																																																																																																																		for marker in("Saved ", "File was already downloaded ")
																																																																																																																																																																																																			:
																																																																																																																																																																																																			if stripped_line.startswith(marker)
																																																																																																																																																																																																				:
																																																																																																																																																																																																				return Wheel(Path(stripped_line[len(marker):]).absolute())
#if for some reason the output does not match fallback to the latest version with that spec
																																																																																																																																																																																																				return find_compatible_in_house(distribution, version_spec, for_py_version, to_folder)


																																																																																																																																																																																																				def find_compatible_in_house(distribution, version_spec, for_py_version, in_folder):
																																																																																																																																																																																																				wheels = discover_wheels(in_folder, distribution, None, for_py_version)
																																																																																																																																																																																																				start, end = 0, len(wheels)
																																																																																																																																																																																																				if version_spec is not None and version_spec:
																																																																																																																																																																																																				if version_spec.startswith("<")
																																																																																																																																																																																																					:
																																																																																																																																																																																																					from_pos, op = 1, lt
																																																																																																																																																																																																					elif version_spec.startswith("=="):
																																																																																																																																																																																																					from_pos, op = 2, eq
																																																																																																																																																																																																					else
																																																																																																																																																																																																					:
																																																																																																																																																																																																					raise ValueError(version_spec)
																																																																																																																																																																																																					version = Wheel.as_version_tuple(version_spec[from_pos:])
																																																																																																																																																																																																					start = next((at for at, w in enumerate(wheels) if op(w.version_tuple, version)), len(wheels))

																																																																																																																																																																																																						return None if start == end
																																																																																																																																																																																																						else
																																																																																																																																																																																																						wheels[start]


																																																																																																																																																																																																							def pip_wheel_env_run(search_dirs, app_data, env):
																																																																																																																																																																																																							env = env.copy()
																																																																																																																																																																																																							env.update({"PIP_USE_WHEEL":"1", "PIP_USER":"0", "PIP_NO_INPUT":"1"})
																																																																																																																																																																																																wheel = get_wheel(
																																																																																																																																																																																																		  distribution = "pip",
																																																																																																																																																																																																		  version = None,
																																																																																																																																																																																																		  for_py_version = f "{sys.version_info.major}.{sys.version_info.minor}",
																																																																																																																																																																																																		  search_dirs = search_dirs,
																																																																																																																																																																																																		  download = False,
																																																																																																																																																																																																		  app_data = app_data,
																																																																																																																																																																																																		  do_periodic_update = False,
																																																																																																																																																																																																		  env = env,
																																																																																																																																																																																																)
																																																																																																																																																																																																if wheel is None:
																																																																																																																																																																																																msg = "could not find the embedded pip"
																																																																																																																																																																																																raise RuntimeError(msg)
																																																																																																																																																																																																	env["PYTHONPATH"] = str(wheel.path)
																																																																																																																																																																																																	return env


																																																																																																																																																																																																	__all__ =[
																																																																																																																																																																																																		  "download_wheel",
																																																																																																																																																																																																		  "get_wheel",
																																																																																																																																																																																																		  "pip_wheel_env_run",
																																																																																																																																																																																																	]
																																																																																																																																																																																																	PK  5L  Z5 · AbG  G  virtualenv / seed / wheels / bundle.pyfrom __future__ import annotations

																																																																																																																																																																																																	from virtualenv.seed.wheels.embed import get_embed_wheel

																																																																																																																																																																																																	from.periodic_update import periodic_update
																																																																																																																																																																																																	from.util import Version, Wheel, discover_wheels


																																																																																																																																																																																																	def from_bundle(distribution, version, for_py_version, search_dirs, app_data, do_periodic_update, env):
#noqa: PLR0913
																																																																																																																																																																																																	"" "Load the bundled wheel to a cache directory." ""
																																																																																																																																																																																																	of_version = Version.of_version(version)
																																																																																																																																																																																																	wheel = load_embed_wheel(app_data, distribution, for_py_version, of_version)

																																																																																																																																																																																																	if version != Version.embed:
#2. check if we have upgraded embed
																																																																																																																																																																																																	if app_data.can_update:
																																																																																																																																																																																																	per = do_periodic_update
																																																																																																																																																																																																	wheel = periodic_update(distribution, of_version, for_py_version, wheel, search_dirs, app_data, per, env)

#3. acquire from extra search dir
																																																																																																																																																																																																		found_wheel = from_dir(distribution, of_version, for_py_version, search_dirs)
																																																																																																																																																																																																		if found_wheel is not None and(wheel is None or found_wheel.version_tuple > wheel.version_tuple)
																																																																																																																																																																																																			:
																																																																																																																																																																																																			wheel = found_wheel
																																																																																																																																																																																																			return wheel


																																																																																																																																																																																																			def load_embed_wheel(app_data, distribution, for_py_version, version):
																																																																																																																																																																																																			wheel = get_embed_wheel(distribution, for_py_version)
																																																																																																																																																																																																			if wheel is not None:
																																																																																																																																																																																																			version_match = version == wheel.version
																																																																																																																																																																																																			if version is None or version_match:
																																																																																																																																																																																																			with app_data.ensure_extracted(wheel.path, lambda:app_data.house)
																																																																																																																																																																																																				as wheel_path:
																																																																																																																																																																																																				wheel = Wheel(wheel_path)
																																																																																																																																																																																																				else
																																																																																																																																																																																																				:
#if version does not match ignore
																																																																																																																																																																																																				wheel = None
																																																																																																																																																																																																				return wheel


																																																																																																																																																																																																				def from_dir(distribution, version, for_py_version, directories):
																																																																																																																																																																																																				"" "Load a compatible wheel from a given folder." ""
																																																																																																																																																																																																				for folder in directories:
																																																																																																																																																																																																				for wheel in discover_wheels(folder, distribution, version, for_py_version)
																																																																																																																																																																																																					:
																																																																																																																																																																																																					return wheel
																																																																																																																																																																																																					return None


																																																																																																																																																																																																					__all__ =[
																																																																																																																																																																																																						  "from_bundle",
																																																																																																																																																																																																						  "load_embed_wheel",
																																																																																																																																																																																																					]
																																																																																																																																																																																																					PK  5L  Z Ü Ñ‚<‚<) virtualenv / seed / wheels / periodic_update.py "" "Periodically update bundled versions." ""

																																																																																																																																																																																																					from __future__ import annotations

																																																																																																																																																																																																					import json
																																																																																																																																																																																																					import logging
																																																																																																																																																																																																					import os
																																																																																																																																																																																																					import ssl
																																																																																																																																																																																																					import sys
																																																																																																																																																																																																					from datetime import datetime, timedelta, timezone
																																																																																																																																																																																																					from itertools import groupby
																																																																																																																																																																																																					from pathlib import Path
																																																																																																																																																																																																					from shutil import copy2
																																																																																																																																																																																																					from subprocess import DEVNULL, Popen
																																																																																																																																																																																																					from textwrap import dedent
																																																																																																																																																																																																					from threading import Thread
																																																																																																																																																																																																					from urllib.error import URLError
																																																																																																																																																																																																					from urllib.request import urlopen

																																																																																																																																																																																																					from virtualenv.app_data import AppDataDiskFolder
																																																																																																																																																																																																					from virtualenv.seed.wheels.embed import BUNDLE_SUPPORT
																																																																																																																																																																																																					from virtualenv.seed.wheels.util import Wheel
																																																																																																																																																																																																					from virtualenv.util.subprocess import CREATE_NO_WINDOW

																																																																																																																																																																																																					LOGGER = logging.getLogger(__name__)
																																																																																																																																																																																																					GRACE_PERIOD_CI = timedelta(hours = 1)
#prevent version switch in the middle of a CI run
																																																																																																																																																																																																					GRACE_PERIOD_MINOR = timedelta(days = 28)
																																																																																																																																																																																																					UPDATE_PERIOD = timedelta(days = 14)
																																																																																																																																																																																																					UPDATE_ABORTED_DELAY = timedelta(hours = 1)


																																																																																																																																																																																																					def periodic_update(
#noqa: PLR0913
																																																																																																																																																																																																							    distribution,
																																																																																																																																																																																																							    of_version,
																																																																																																																																																																																																							    for_py_version,
																																																																																																																																																																																																							    wheel,
																																																																																																																																																																																																							    search_dirs,
																																																																																																																																																																																																							    app_data,
																																																																																																																																																																																																							    do_periodic_update,
																																																																																																																																																																																																							    env,
																																																																																																																																																																																																					):
																																																																																																																																																																																																					if do_periodic_update:
																																																																																																																																																																																																					handle_auto_update(distribution, for_py_version, wheel, search_dirs, app_data, env)

																																																																																																																																																																																																						now = datetime.now(tz = timezone.utc)

																																																																																																																																																																																																						def _update_wheel(ver):
																																																																																																																																																																																																						updated_wheel = Wheel(app_data.house / ver.filename)
																																																																																																																																																																																																						LOGGER.debug("using %supdated wheel %s", "periodically " if updated_wheel
																																																																																																																																																																																																							     else
																																																																																																																																																																																																							     "", updated_wheel)
																																																																																																																																																																																																							return updated_wheel

																																																																																																																																																																																																							u_log = UpdateLog.from_app_data(app_data, distribution, for_py_version)
																																																																																																																																																																																																							if of_version is None:
																																																																																																																																																																																																							for _, group in groupby(u_log.versions, key = lambda v:v.wheel.version_tuple[0:2])
																																																																																																																																																																																																								:
#use only latest patch version per minor, earlier assumed to be buggy
																																																																																																																																																																																																								all_patches = list(group)
																																																																																																																																																																																																								ignore_grace_period_minor = any(version for version in all_patches if version.use(now))
																																																																																																																																																																																																									for version in all_patches:
																																																																																																																																																																																																									if wheel is not None and Path(version.filename)
																																																																																																																																																																																																										.name == wheel.name:
																																																																																																																																																																																																										return wheel
																																																																																																																																																																																																										if version.use(now, ignore_grace_period_minor)
																																																																																																																																																																																																											:
																																																																																																																																																																																																											return _update_wheel(version)
																																																																																																																																																																																																											else
																																																																																																																																																																																																											:
																																																																																																																																																																																																											for version in u_log.versions:
																																																																																																																																																																																																											if version.wheel.version == of_version:
																																																																																																																																																																																																											return _update_wheel(version)

																																																																																																																																																																																																												return wheel


																																																																																																																																																																																																												def handle_auto_update(distribution, for_py_version, wheel, search_dirs, app_data, env):
#noqa: PLR0913
																																																																																																																																																																																																												embed_update_log = app_data.embed_update_log(distribution, for_py_version)
																																																																																																																																																																																																												u_log = UpdateLog.from_dict(embed_update_log.read())
																																																																																																																																																																																																												if u_log.needs_update:
																																																																																																																																																																																																												u_log.periodic = True
																																																																																																																																																																																																												u_log.started = datetime.now(tz = timezone.utc)
																																																																																																																																																																																																													embed_update_log.write(u_log.to_dict())
																																																																																																																																																																																																													trigger_update(distribution, for_py_version, wheel, search_dirs, app_data, periodic = True, env = env)


																																																																																																																																																																																																													def add_wheel_to_update_log(wheel, for_py_version, app_data):
																																																																																																																																																																																																													embed_update_log = app_data.embed_update_log(wheel.distribution, for_py_version)
																																																																																																																																																																																																													LOGGER.debug("adding %s information to %s", wheel.name, embed_update_log.file)
																																																																																																																																																																																																													u_log = UpdateLog.from_dict(embed_update_log.read())
																																																																																																																																																																																																													if any(version.filename == wheel.name for version in u_log.versions)
																																																																																																																																																																																																														:
																																																																																																																																																																																																														LOGGER.warning("%s already present in %s", wheel.name, embed_update_log.file)
																																																																																																																																																																																																														return
#we don't need a release date for sources other than "periodic"
																																																																																																																																																																																																														version = NewVersion(wheel.name, datetime.now(tz = timezone.utc), None, "download")
																																																																																																																																																																																																														u_log.versions.append(version)
#always write at the end for proper updates
																																																																																																																																																																																																														embed_update_log.write(u_log.to_dict())


																																																																																																																																																																																																														DATETIME_FMT = "%Y-%m-%dT%H:%M:%S.%fZ"


																																																																																																																																																																																																														def dump_datetime(value):
																																																																																																																																																																																																														return None if value is None
																																																																																																																																																																																																														else
																																																																																																																																																																																																														value.strftime(DATETIME_FMT)


																																																																																																																																																																																																															def load_datetime(value):
																																																																																																																																																																																																															return None if value is None
																																																																																																																																																																																																															else
																																																																																																																																																																																																															datetime.strptime(value, DATETIME_FMT)
																																																																																																																																																																																																																.replace(tzinfo = timezone.utc)


																																																																																																																																																																																																																class NewVersion:
#noqa: PLW1641
																																																																																																																																																																																																																def __init__(self, filename, found_date, release_date, source)->None:
																																																																																																																																																																																																																self.filename = filename
																																																																																																																																																																																																																self.found_date = found_date
																																																																																																																																																																																																																self.release_date = release_date
																																																																																																																																																																																																																self.source = source

																																																																																																																																																																																																																@ classmethod
																																																																																																																																																																																																																def from_dict(cls, dictionary):
																																																																																																																																																																																																																return cls(
																																																																																																																																																																																																																	   filename = dictionary["filename"],
																																																																																																																																																																																																																	   found_date = load_datetime(dictionary["found_date"]),
																																																																																																																																																																																																																	   release_date = load_datetime(dictionary["release_date"]),
																																																																																																																																																																																																																	   source = dictionary["source"],
																																																																																																																																																																																																																)

																																																																																																																																																																																																																def to_dict(self):
																																																																																																																																																																																																																return {
																																																																																																																																																																																																																"filename":self.filename,
																																																																																																																																																																																																																"release_date":dump_datetime(self.release_date),
																																																																																																																																																																																																																"found_date":dump_datetime(self.found_date),
																																																																																																																																																																																																																"source":self.source,
																																																																																																																																																																																																																}

																																																																																																																																																																																																def use(self, now, ignore_grace_period_minor = False, ignore_grace_period_ci = False):
#noqa: FBT002
																																																																																																																																																																																																if self.source == "manual":
																																																																																																																																																																																																return True
																																																																																																																																																																																																if self.source == "periodic" and(self.found_date < now - GRACE_PERIOD_CI or ignore_grace_period_ci)
																																																																																																																																																																																																	:
																																																																																																																																																																																																	if not ignore_grace_period_minor:
																																																																																																																																																																																																	compare_from = self.release_date or self.found_date
																																																																																																																																																																																																	return now - compare_from >= GRACE_PERIOD_MINOR
																																																																																																																																																																																																	return True
																																																																																																																																																																																																	return False

																																																																																																																																																																																																	def __repr__(self)
																																																																																																																																																																																																		->str:
																																																																																																																																																																																																		return (
																																																																																																																																																																																																			f "{self.__class__.__name__}(filename={self.filename}), found_date={self.found_date}, "
																																																																																																																																																																																																			f "release_date={self.release_date}, source={self.source})"
																																																																																																																																																																																																		)

																																																																																																																																																																																																		def __eq__(self, other):
																																																																																																																																																																																																		return type(self) == type(other) and all(
#noqa: E721
																																																																																																																																																																																																							 getattr(self, k) == getattr(other, k) for k in["filename", "release_date", "found_date", "source"]
																																																																																																																																																																																																		)

																																																																																																																																																																																																			def __ne__(self, other):
																																																																																																																																																																																																			return not(self == other)

																																																																																																																																																																																																			@ property
																																																																																																																																																																																																			def wheel(self):
																																																																																																																																																																																																			return Wheel(Path(self.filename))


																																																																																																																																																																																																			class UpdateLog:
																																																																																																																																																																																																			def __init__(self, started, completed, versions, periodic)->None:
																																																																																																																																																																																																			self.started = started
																																																																																																																																																																																																			self.completed = completed
																																																																																																																																																																																																			self.versions = versions
																																																																																																																																																																																																			self.periodic = periodic

																																																																																																																																																																																																			@ classmethod
																																																																																																																																																																																																			def from_dict(cls, dictionary):
																																																																																																																																																																																																			if dictionary is None:
																																																																																																																																																																																																			dictionary = {}
																																																																																																																																																																																																return cls(
																																																																																																																																																																																																	   load_datetime(dictionary.get("started")),
																																																																																																																																																																																																	   load_datetime(dictionary.get("completed")),
																																																																																																																																																																																																	   [NewVersion.from_dict(v) for v in dictionary.get("versions",[])],
																																																																																																																																																																																																	   dictionary.get("periodic"),
																																																																																																																																																																																																)

																																																																																																																																																																																																	@classmethod
																																																																																																																																																																																																	def from_app_data(cls, app_data, distribution, for_py_version):
																																																																																																																																																																																																	raw_json = app_data.embed_update_log(distribution, for_py_version).read()
																																																																																																																																																																																																	return cls.from_dict(raw_json)

																																																																																																																																																																																																	def to_dict(self):
																																																																																																																																																																																																	return {
																																																																																																																																																																																																	"started":dump_datetime(self.started),
																																																																																																																																																																																																	"completed":dump_datetime(self.completed),
																																																																																																																																																																																																	"periodic":self.periodic,
																																																																																																																																																																																																	"versions":[r.to_dict() for r in self.versions]
																																																																																																																																																																																																		,
																																																																																																																																																																																																		}

																																																																																																																																																																																																		@property
																																																																																																																																																																																																		def needs_update(self):
																																																																																																																																																																																																		now = datetime.now(tz = timezone.utc)
																																																																																																																																																																																																		if self.completed is None:
#never completed
																																																																																																																																																																																																		return self._check_start(now)
																																																																																																																																																																																																			if now - self.completed <= UPDATE_PERIOD:
																																																																																																																																																																																																			return False
																																																																																																																																																																																																			return self._check_start(now)

																																																																																																																																																																																																				def _check_start(self, now):
																																																																																																																																																																																																				return self.started is None or now - self.started > UPDATE_ABORTED_DELAY


																																																																																																																																																																																																				def trigger_update(distribution, for_py_version, wheel, search_dirs, app_data, env, periodic):
#noqa: PLR0913
																																																																																																																																																																																																				wheel_path = None if wheel is None
																																																																																																																																																																																																				else
																																																																																																																																																																																																				str(wheel.path)
																																																																																																																																																																																																					cmd =[
																																																																																																																																																																																																					      sys.executable,
																																																																																																																																																																																																					      "-c",
																																																																																																																																																																																																					      dedent(
																																																																																																																																																																																																						     "" "
																																																																																																																																																																																																						     from virtualenv.report import setup_report, MAX_LEVEL
																																																																																																																																																																																																						     from virtualenv.seed.wheels.periodic_update import do_update
																																																																																																																																																																																																						     setup_report(MAX_LEVEL, show_pid = True)
																																																																																																																																																																																																						     do_update({!r}, {!r}, {!r}, {!r}, {!r}, {!r})
																																																																																																																																																																																																					"" ",
																																																																																																																																																																																																					)
																																																																																																																																																																																																					.strip()
																																																																																																																																																																																																					.format(distribution, for_py_version, wheel_path, str(app_data),[str(p) for p in search_dirs], periodic)
																																																																																																																																																																																																						,
																																																																																																																																																																																																						]
																																																																																																																																																																																																						debug = env.get("_VIRTUALENV_PERIODIC_UPDATE_INLINE") == "1"
																																																																																																																																																																																																						pipe = None if debug
																																																																																																																																																																																																						else
																																																																																																																																																																																																						DEVNULL
																																																																																																																																																																																																						kwargs = {"stdout":pipe, "stderr":pipe}
																																																																																																																																																																																																					if not debug and sys.platform == "win32":
																																																																																																																																																																																																					kwargs["creationflags"]
																																																																																																																																																																																																						= CREATE_NO_WINDOW
																																																																																																																																																																																																						process = Popen(cmd, **kwargs)
																																																																																																																																																																																																						LOGGER.info(
																																																																																																																																																																																																							    "triggered periodic upgrade of %s%s (for python %s) via background process having PID %d",
																																																																																																																																																																																																							    distribution,
																																																																																																																																																																																																							    "" if wheel is None
																																																																																																																																																																																																							    else
																																																																																																																																																																																																							    f "=={wheel.version}",
																																																																																																																																																																																																							    for_py_version,
																																																																																																																																																																																																							    process.pid,
																																																																																																																																																																																																						)
																																																																																																																																																																																																							if debug:
																																																																																																																																																																																																							process.communicate()
#on purpose not called to make it a background process
																																																																																																																																																																																																								else
																																																																																																																																																																																																								:
#set the returncode here -> no ResourceWarning on main process exit if the subprocess still runs
																																																																																																																																																																																																								process.returncode = 0


																																																																																																																																																																																																								def do_update(distribution, for_py_version, embed_filename, app_data, search_dirs, periodic):
#noqa: PLR0913
																																																																																																																																																																																																								versions = None
																																																																																																																																																																																																								try:
																																																																																																																																																																																																								versions = _run_do_update(app_data, distribution, embed_filename, for_py_version, periodic, search_dirs)
																																																																																																																																																																																																								finally:
																																																																																																																																																																																																								LOGGER.debug("done %s %s with %s", distribution, for_py_version, versions)
																																																																																																																																																																																																								return versions


																																																																																																																																																																																																								def _run_do_update(
#noqa: C901, PLR0913
																																																																																																																																																																																																										   app_data,
																																																																																																																																																																																																										   distribution,
																																																																																																																																																																																																										   embed_filename,
																																																																																																																																																																																																										   for_py_version,
																																																																																																																																																																																																										   periodic,
																																																																																																																																																																																																										   search_dirs,
																																																																																																																																																																																																								):
																																																																																																																																																																																																								from virtualenv.seed.wheels import acquire
#noqa: PLC0415

																																																																																																																																																																																																								wheel_filename = None if embed_filename is None
																																																																																																																																																																																																								else
																																																																																																																																																																																																								Path(embed_filename)
																																																																																																																																																																																																									embed_version = None if wheel_filename is None
																																																																																																																																																																																																									else
																																																																																																																																																																																																									Wheel(wheel_filename)
																																																																																																																																																																																																										.version_tuple
																																																																																																																																																																																																										app_data = AppDataDiskFolder(app_data) if isinstance(app_data, str)
																																																																																																																																																																																																											else
																																																																																																																																																																																																											app_data
																																																																																																																																																																																																											search_dirs =[Path(p) if isinstance(p, str)
																																																																																																																																																																																																												      else
																																																																																																																																																																																																												      p for p in search_dirs]
																																																																																																																																																																																																												wheelhouse = app_data.house
																																																																																																																																																																																																												embed_update_log = app_data.embed_update_log(distribution, for_py_version)
																																																																																																																																																																																																												u_log = UpdateLog.from_dict(embed_update_log.read())
																																																																																																																																																																																																												now = datetime.now(tz = timezone.utc)

																																																																																																																																																																																																												update_versions, other_versions =[],[]
																																																																																																																																																																																																												for version in u_log.versions:
																																																																																																																																																																																																												if version.source in {"periodic", "manual"}:
																																																																																																																																																																																																	update_versions.append(version)
																																																																																																																																																																																																		else
																																																																																																																																																																																																		:
																																																																																																																																																																																																		other_versions.append(version)

																																																																																																																																																																																																		if periodic:
																																																																																																																																																																																																		source = "periodic"
																																																																																																																																																																																																		else
																																																																																																																																																																																																		:
																																																																																																																																																																																																		source = "manual"
#mark the most recent one as source "manual"
																																																																																																																																																																																																		if update_versions:
																																																																																																																																																																																																		update_versions[0]
																																																																																																																																																																																																			.source = source

																																																																																																																																																																																																			if wheel_filename is not None:
																																																																																																																																																																																																			dest = wheelhouse / wheel_filename.name
																																																																																																																																																																																																			if not dest.exists()
																																																																																																																																																																																																				:
																																																																																																																																																																																																				copy2(str(wheel_filename), str(wheelhouse))
																																																																																																																																																																																																				last, last_version, versions, filenames = None, None,[], set()
																																																																																																																																																																																																				while last is None or not last.use(now, ignore_grace_period_ci = True)
																																																																																																																																																																																																					:
																																																																																																																																																																																																					download_time = datetime.now(tz = timezone.utc)
																																																																																																																																																																																																					dest = acquire.download_wheel(
																																																																																																																																																																																																								      distribution = distribution,
																																																																																																																																																																																																								      version_spec = None if last_version is None
																																																																																																																																																																																																								      else
																																																																																																																																																																																																								      f "<{last_version}",
																																																																																																																																																																																																								      for_py_version = for_py_version,
																																																																																																																																																																																																								      search_dirs = search_dirs,
																																																																																																																																																																																																								      app_data = app_data,
																																																																																																																																																																																																								      to_folder = wheelhouse,
																																																																																																																																																																																																								      env = os.environ,
																																																																																																																																																																																																					)
																																																																																																																																																																																																						if dest is None or(update_versions and update_versions[0].filename == dest.name)
																																																																																																																																																																																																							:
																																																																																																																																																																																																							break
																																																																																																																																																																																																							release_date = release_date_for_wheel_path(dest.path)
																																																																																																																																																																																																							last = NewVersion(filename = dest.path.name, release_date = release_date, found_date = download_time, source = source)
																																																																																																																																																																																																							LOGGER.info("detected %s in %s", last, datetime.now(tz = timezone.utc) - download_time)
																																																																																																																																																																																																							versions.append(last)
																																																																																																																																																																																																							filenames.add(last.filename)
																																																																																																																																																																																																							last_wheel = last.wheel
																																																																																																																																																																																																							last_version = last_wheel.version
																																																																																																																																																																																																							if embed_version is not None and embed_version >= last_wheel.version_tuple:
																																																																																																																																																																																																							break
#stop download if we reach the embed version
																																																																																																																																																																																																							u_log.periodic = periodic
																																																																																																																																																																																																							if not u_log.periodic:
																																																																																																																																																																																																							u_log.started = now
#update other_versions by removing version we just found
																																																																																																																																																																																																							other_versions =[version for version in other_versions if version.filename not in filenames]
																																																																																																																																																																																																								u_log.versions = versions + update_versions + other_versions
																																																																																																																																																																																																								u_log.completed = datetime.now(tz = timezone.utc)
																																																																																																																																																																																																								embed_update_log.write(u_log.to_dict())
																																																																																																																																																																																																								return versions


																																																																																																																																																																																																								def release_date_for_wheel_path(dest):
																																																																																																																																																																																																								wheel = Wheel(dest)
#the most accurate is to ask PyPi - e.g. https://pypi.org/pypi/pip/json,
#see https://warehouse.pypa.io/api-reference/json/ for more details
																																																																																																																																																																																																								content = _pypi_get_distribution_info_cached(wheel.distribution)
																																																																																																																																																																																																								if content is not None:
																																																																																																																																																																																																								try:
																																																																																																																																																																																																								upload_time = content["releases"]
																																																																																																																																																																																																									[wheel.version][0]["upload_time"]
																																																																																																																																																																																																									return datetime.strptime(upload_time, "%Y-%m-%dT%H:%M:%S").replace(tzinfo = timezone.utc)
																																																																																																																																																																																																									except Exception as exception:
#noqa: BLE001
																																																																																																																																																																																																									LOGGER.error("could not load release date %s because %r", content, exception)
#noqa: TRY400
																																																																																																																																																																																																									return None


																																																																																																																																																																																																									def _request_context():
																																																																																																																																																																																																									yield None
#fallback to non verified HTTPS (the information we request is not sensitive, so fallback)
																																																																																																																																																																																																									yield ssl._create_unverified_context()
#noqa: S323, SLF001


																																																																																																																																																																																																									_PYPI_CACHE = {}


																																																																																																																																																																																																	def _pypi_get_distribution_info_cached(distribution):
																																																																																																																																																																																																	if distribution not in _PYPI_CACHE:
																																																																																																																																																																																																	_PYPI_CACHE[distribution]
																																																																																																																																																																																																		= _pypi_get_distribution_info(distribution)
																																																																																																																																																																																																		return _PYPI_CACHE[distribution]


																																																																																																																																																																																																		def _pypi_get_distribution_info(distribution):
																																																																																																																																																																																																		content, url = None, f "https://pypi.org/pypi/{distribution}/json"
																																																																																																																																																																																																		try:
																																																																																																																																																																																																		for context in _request_context()
																																																																																																																																																																																																			:
																																																																																																																																																																																																			try:
																																																																																																																																																																																																			with urlopen(url, context = context) as file_handler:
#noqa: S310
																																																																																																																																																																																																			content = json.load(file_handler)
																																																																																																																																																																																																			break
																																																																																																																																																																																																			except URLError as exception:
																																																																																																																																																																																																			LOGGER.error("failed to access %s because %r", url, exception)
#noqa: TRY400
																																																																																																																																																																																																			except Exception as exception:
#noqa: BLE001
																																																																																																																																																																																																			LOGGER.error("failed to access %s because %r", url, exception)
#noqa: TRY400
																																																																																																																																																																																																			return content


																																																																																																																																																																																																			def manual_upgrade(app_data, env):
																																																																																																																																																																																																			threads =[]

																																																																																																																																																																																																			for for_py_version, distribution_to_package in BUNDLE_SUPPORT.items()
																																																																																																																																																																																																				:
#load extra search dir for the given for_py
																																																																																																																																																																																																				for distribution in distribution_to_package:
																																																																																																																																																																																																				thread = Thread(target = _run_manual_upgrade, args = (app_data, distribution, for_py_version, env))
																																																																																																																																																																																																					thread.start()
																																																																																																																																																																																																					threads.append(thread)

																																																																																																																																																																																																					for thread in threads:
																																																																																																																																																																																																					thread.join()


																																																																																																																																																																																																						def _run_manual_upgrade(app_data, distribution, for_py_version, env):
																																																																																																																																																																																																						start = datetime.now(tz = timezone.utc)
																																																																																																																																																																																																						from.bundle import from_bundle
#noqa: PLC0415

																																																																																																																																																																																																						current = from_bundle(
																																																																																																																																																																																																								      distribution = distribution,
																																																																																																																																																																																																								      version = None,
																																																																																																																																																																																																								      for_py_version = for_py_version,
																																																																																																																																																																																																								      search_dirs =[],
																																																																																																																																																																																																								      app_data = app_data,
																																																																																																																																																																																																								      do_periodic_update = False,
																																																																																																																																																																																																								      env = env,
																																																																																																																																																																																																						)
																																																																																																																																																																																																						LOGGER.warning(
																																																																																																																																																																																																							       "upgrade %s for python %s with current %s",
																																																																																																																																																																																																							       distribution,
																																																																																																																																																																																																							       for_py_version,
																																																																																																																																																																																																							       "" if current is None
																																																																																																																																																																																																							       else
																																																																																																																																																																																																							       current.name,
																																																																																																																																																																																																						)
																																																																																																																																																																																																							versions = do_update(
																																																																																																																																																																																																									     distribution = distribution,
																																																																																																																																																																																																									     for_py_version = for_py_version,
																																																																																																																																																																																																									     embed_filename = current.path,
																																																																																																																																																																																																									     app_data = app_data,
																																																																																																																																																																																																									     search_dirs =[],
																																																																																																																																																																																																									     periodic = False,
																																																																																																																																																																																																							)

																																																																																																																																																																																																							args =[
																																																																																																																																																																																																							       distribution,
																																																																																																																																																																																																							       for_py_version,
																																																																																																																																																																																																							       datetime.now(tz = timezone.utc) - start,
																																																																																																																																																																																																							]
																																																																																																																																																																																																							if versions:
																																																																																																																																																																																																							args.append("\n".join(f "\t{v}" for v in versions))
																																																																																																																																																																																																								ver_update = "new entries found:\n%s" if versions
																																																																																																																																																																																																								else
																																																																																																																																																																																																								"no new versions found"
																																																																																																																																																																																																								msg = f "upgraded %s for python %s in %s {ver_update}"
																																																																																																																																																																																																								LOGGER.warning(msg, *args)


																																																																																																																																																																																																									__all__ =[
																																																																																																																																																																																																										  "NewVersion",
																																																																																																																																																																																																										  "UpdateLog",
																																																																																																																																																																																																										  "add_wheel_to_update_log",
																																																																																																																																																																																																										  "do_update",
																																																																																																																																																																																																										  "dump_datetime",
																																																																																																																																																																																																										  "load_datetime",
																																																																																																																																																																																																										  "manual_upgrade",
																																																																																																																																																																																																										  "periodic_update",
																																																																																																																																																																																																										  "release_date_for_wheel_path",
																																																																																																																																																																																																										  "trigger_update",
																																																																																																																																																																																																									]
																																																																																																																																																																																																									PK  5L  Z 11263 ”u ¶ z  z  virtualenv / seed / wheels / util.pyfrom __future__ import annotations

																																																																																																																																																																																																									from operator import attrgetter
																																																																																																																																																																																																									from zipfile import ZipFile


																																																																																																																																																																																																									class Wheel:
																																																																																																																																																																																																									def __init__(self, path)->None:
#https://www.python.org/dev/peps/pep-0427/#file-name-convention
#The wheel filename is {distribution}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}.whl
																																																																																																																																																																																																									self.path = path
																																																																																																																																																																																																									self._parts = path.stem.split("-")

																																																																																																																																																																																																									@ classmethod
																																																																																																																																																																																																									def from_path(cls, path):
																																																																																																																																																																																																									if path is not None and path.suffix == ".whl" and len(path.stem.split("-"))
																																																																																																																																																																																																										>=5:
#noqa: PLR2004
																																																																																																																																																																																																										return cls(path)
																																																																																																																																																																																																										return None

																																																																																																																																																																																																										@ property
																																																																																																																																																																																																										def distribution(self):
																																																																																																																																																																																																										return self._parts[0]

																																																																																																																																																																																																										@ property
																																																																																																																																																																																																										def version(self):
																																																																																																																																																																																																										return self._parts[1]

																																																																																																																																																																																																										@ property
																																																																																																																																																																																																										def version_tuple(self):
																																																																																																																																																																																																										return self.as_version_tuple(self.version)

																																																																																																																																																																																																										@ staticmethod
																																																																																																																																																																																																										def as_version_tuple(version):
																																																																																																																																																																																																										result =[]
																																																																																																																																																																																																										for part in version.split(".")
																																																																																																																																																																																																											[0:3]:
																																																																																																																																																																																																											try:
																																																																																																																																																																																																											result.append(int (part))
																																																																																																																																																																																																											except ValueError:
#noqa: PERF203
																																																																																																																																																																																																											break
																																																																																																																																																																																																											if not result:
																																																																																																																																																																																																											raise ValueError(version)
																																																																																																																																																																																																												return tuple(result)

																																																																																																																																																																																																												@ property
																																																																																																																																																																																																												def name(self):
																																																																																																																																																																																																												return self.path.name

																																																																																																																																																																																																												def support_py(self, py_version):
																																																																																																																																																																																																												name = f "{'-'.join(self.path.stem.split('-')[0:2])}.dist-info/METADATA"
																																																																																																																																																																																																												with ZipFile(str(self.path), "r") as zip_file:
																																																																																																																																																																																																												metadata = zip_file.read(name).decode("utf-8")
																																																																																																																																																																																																												marker = "Requires-Python:"
																																																																																																																																																																																																												requires = next((i[len(marker):] for i in metadata.splitlines() if i.startswith(marker)), None)
																																																																																																																																																																																																													if requires is None:
#if it does not specify a python requires the assumption is compatible
																																																																																																																																																																																																													return True
																																																																																																																																																																																																													py_version_int = tuple(int (i) for i in py_version.split("."))
																																																																																																																																																																																																														for require in(i.strip() for i in requires.split(","))
																																																																																																																																																																																																															:
#https://www.python.org/dev/peps/pep-0345/#version-specifiers
																																																																																																																																																																																																															for operator, check in[
																																																																																																																																																																																																																	       ("!=", lambda v:py_version_int != v),
																																																																																																																																																																																																																	       ("==", lambda v:py_version_int == v),
																																																																																																																																																																																																																	       ("<=", lambda v:py_version_int <= v),
																																																																																																																																																																																																																	       (">=", lambda v:py_version_int >= v),
																																																																																																																																																																																																																	       ("<", lambda v:py_version_int < v),
																																																																																																																																																																																																																	       (">", lambda v:py_version_int > v),
																																																																																																																																																																																																															]
																																																																																																																																																																																																																:
																																																																																																																																																																																																																if require.startswith(operator)
																																																																																																																																																																																																																	:
																																																																																																																																																																																																																	ver_str = require[len(operator):].strip()
																																																																																																																																																																																																																	version = tuple((int (i) if i != "*"
																																																																																																																																																																																																																			 else
																																																																																																																																																																																																																			 None)for i in ver_str.split("."))
																																																																																																																																																																																																																		[0:2]
